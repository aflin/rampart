<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
<style>

.reset, html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
    margin: 0;
    padding: 0;
    border: 0;
    font: inherit;
    font-size: 100%;
    vertical-align: baseline;
}


.reset_2, caption, th, td {
    text-align: left;
    font-weight: normal;
    vertical-align: middle;
}

code {
    font-family: monospace;
    font-size: 0.9em; 
    color:black;
} 

strong {
    font-weight:bold; 
}


em {
    font-weight:bold;
    font-style: italic; 
}

html {
    line-height: 1;
    position: relative;
    height: 100%;
    font-size: 15px;
    font-family: Arial, sans-serif;
}

body {
    height: 100%;
    width: 100%;
    margin: 0;
    padding-top: 53px;
    padding-bottom: 64px;
}

blockquote {
    quotes: none;
}

blockquote:before {
    content: "";
    content: none;
}

blockquote:after {
    content: "";
    content: none;
}

a img {
    border: none;
}

q {
    quotes: none;
}

q:before {
    content: "";
    content: none;
}

q:after {
    content: "";
    content: none;
}

ol {
    list-style: none;
}

ul {
    list-style: none;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}

article {
    display: block;
}

aside {
    display: block;
}

details {
    display: block;
}

figure {
    display: block;
}

figcaption {
    display: block;
}

footer {
    display: block;
}

header {
    display: block;
}

hgroup {
    display: block;
}

menu {
    display: block;
}

nav {
    display: block;
}

section {
    display: block;
}

summary {
    display: block;
}

main {
    display: block;
}

* {
    -moz-box-sizing: border-box;
         box-sizing: border-box;
}

.commandbar {
    position: fixed;
    top: 0;
    left: 0;
    background-color:#c0c0c0;
    height: 20px;
    width: 100%;
}

.header {
    position: fixed;
    top: 0;
    left: 0;
    height: 53px;
    width: 100%;
}

.main {
    height: 100%;
}

.footer {
    position: absolute;
    left: 0;
    bottom: 0;
    height: 64px;
    width: 100%;
}

.hamburger-menu {
    position: relative;
    width: 220px;
    height: 53px;
    line-height: 53px;
    font-weight: 900;
    padding: 0 1rem;
    color: #ffffff;
    background: #202020;    //#3e313c;
    border-bottom: 2px solid #c0c0c0; //#372c36;
    float: left;
    cursor: pointer;
}

.channel-menu_name {
    display: inline-block;
    padding: 0 .5rem 0 1.5rem;
    color: #555459;
    font-size: 1.4rem;
    font-weight: 900;
    line-height: 53px;
    cursor: pointer;
}

.channel-menu_prefix {
    color: #9e9ea6;
    padding-right: .1rem;
    font-weight: 500;
}

.listings {
    height: 100%;
    width: 220px;
    float: left;
    color: #c0c0c0; /*#ab9ba9;*/
    background-color: #202020; /*#4d394b;*/
    overflow-y: auto;
    overflow-x: hidden;
}

.message-history {
    margin-left: 220px;
    overflow-y: auto;
    overflow-x: hidden;
    height: 100%;
    padding: 0 18px 1rem 1.5rem;
    overflow: scroll;
    overflow-x: hidden;
}

.dropping {
    border: 2px blue dashed;
    opacity: .5;
}

.listings_channels {
    margin: 1rem 0 2rem;
}

.listings_header {
    text-align: left;
    font-size: .8rem;
    line-height: 1.25rem;
    margin: 0 1rem .1rem;
    text-transform: uppercase;
    font-weight: 700;
    color: #c0c0c0;/*#ab9ba9; */
    width: 165px;
    //position: relative; // This causes a z-index problem for some unknown reason
    z-index:0;
}

.channel_list {
    list-style-type: none;
    text-align: left;
    color: #ab9ba9;
}
/* WTF: If a name is too long it wll mess up the display; The CSS for channel_name is wrong*/
.channel_name {
  overflow: hidden;
  //white-space: nowrap;
  text-overflow:ellipsis;    
}

.channel {
    height: 24px;
    line-height: 24px;
    border-top-right-radius: 0.25rem;
    border-bottom-right-radius: 0.25rem;
    margin-right: 17px;
    color: #ffffff;
    padding-left: 1rem;
    cursor: pointer;
}

.channel.active {
    background: #2020ff; /*#4c9689; */
}

.unread {
    color: #ffffff;
    background: #eb4d5c;
    border-radius: 9px;
    padding: 2px 9px;
    font-size: .8rem;
    line-height: 14px;
    font-weight: 700;
    vertical-align: baseline;
    white-space: nowrap;
    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
    float: right;
    margin-right: 3px;
    margin-top: 3px;
}

.status_prefix {
    color:#c0c0c0;
    font-size:1.5em;
    padding-right:3px;
}

.status_available {
    color:green;
}



.disclaimer {
    font-size: 0.8rem;
    padding-left: 1rem;
    margin-right: 17px;
}

.message {
    position: relative;
    margin-top: .5rem;
    /* padding: .25rem 2rem .1rem 3rem; */
    padding: .25rem 2rem .1rem 3.5rem;
    min-height: 36px;
}

.message_profile-pic {
    position: absolute;
    left: 0;
    display: block;
    border-radius: 0.2rem;
    width: 36px;
    height: 36px;
    /* background-image: url(http://findicons.com/icon/download/102283/fh02/300/png);*/
    /* background-image: url(/profpics/emblem_person_blue_small.jpg); */
    background-size: cover;
}

#preview .message_profile-pic {
    background-image: initial;
}

.message_username {
    font-weight: 900;
    padding-right: .25rem;
    color: #3d3c40 !important;
    margin-left: 0;
    font-style: normal;
    text-decoration: none;
}

.message_timestamp {
    text-align: left;
    display: inline;
    position: relative;
    top: 0;
    left: 0;
    color: #babbbf;
    font-size: 12px;
    line-height: 1.2rem;
    width: 36px;
    margin-right: 0;
    margin-left: 0;
}

.message_content {
    color: #8b898f;
    display: block;
    min-height: 1rem;
    // border: 1px solid red;
    word-wrap:break-word;
}

.message_content img {
    max-height: 250px;
    max-width: 500px;
}

.user-menu {
    float: left;
    width: 220px;
    height: 100%;
    cursor: pointer;
    background: #202020;/* #3e313c; */
    border-top: 2px solid #c0c0c0; /*#372c36; */
    padding: 7px 0 9px 8px;
    /* height: 4rem; */
    /* position: fixed; */
    bottom: 0;
    left: 0;
}

.user-menu_profile-pic {
    display: inline-block;
    float: left;
    border-radius: 0.2rem;
    width: 48px;
    height: 48px;
    /*background-image: /url(http://findicons.com/icon/download/102283/fh02/300/png);*/
    background-size: cover;
    margin-right: 8px;
}

.user-menu_username {
    display: block;
    color: #ffffff;
    font-weight: 900;
    line-height: 1.5rem;
    margin-top: .2rem;
    /* max-width: 120px; */
    max-width: 200px;
}

.connection_icon {
    width: 12px;
    height: 12px;
}

.connection_status {
    color: #ab9ba9;
}

.input-box {
    display:flex;
    height: 100%;
    margin-left: 220px;
    align-items:center;
}
/*
#sendArrow {
    margin:5px;
    text-decoration:none;
    font-size:30px;
    color:white;
    background:green;
    border:1px solid #c0c0c0;
    position: absolute;
    right: 50px;
    transform: rotate(90deg);
    border-radius: 5px;
}

#sendArrow::before {
    content: "â–²";
    color:green;
    position: absolute;
    font-size: 17px;
    left: 7px;
    bottom: 0px;
}
*/

/* this still ain't right, but it's a start */
#sendArrow {
    margin: 5px;
    text-decoration: none;
    font-size: 25px;
    color: white;
    background: green;
    border: 1px solid #c0c0c0;
    position: absolute;
    right: 43px;
    transform: rotate(90deg);
    border-radius: 5px;
    padding: 5px;
}

#sendArrow::before {
    content: "|";
    color: green;
    position: absolute;
    font-size: 14px;
    left: 16px;
    bottom: 3px;
    transform: scale(2.5,1);
}

.input-box_text_bak {
    font-size: .95rem;
    width: 90%;
    margin-left: 2%;
    margin-bottom: auto;
    line-height: 1.2rem;
    border: 2px solid #e0e0e0;
    border-radius: 0.2rem;
    background-clip: padding-box;
    color: #3d3c40;
    box-shadow: none;
    outline: 0;
    bottom: 2px;
    position:relative;
    min-height: 41px !important;
    padding: 9px 5px 9px 8px;
}    
.input-box_text {
    font-size: .95rem;
    width: calc(100% - 340px);
    margin-left: 2%;
    margin-bottom: auto;
    line-height: 1.2rem;
    border: 2px solid #e0e0e0;
    border-radius: 0.2rem;
    background-clip: padding-box;
    color: #3d3c40;
    box-shadow: none;
    outline: 0;
    bottom: 10px;
    position: absolute;
    min-height: 41px !important;
    padding: 9px 5px 9px 8px;
    display: block;
    left: 220px;
    max-height:50%;
    max-width: calc(100% - 340px);
    overflow: auto;
}

.message_content pre { 
  background-color:#f0f0f0;  
  border-radius: 5px;
  border: 1px solid #c0c0ff;
  overflow-x:scroll;
  padding: 10px; 
  //width: 200px;
  //height: 150px;  
}

// For COMMAND MENU


/* Dropdown Button */
.dropbtn {
  background-color: #3498DB;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
  cursor: pointer;
}

/* Dropdown button on hover & focus */
.dropbtn:hover, .dropbtn:focus {
  background-color: #2980B9;
}

/* The container <div> - needed to position the dropdown content */
.dropdown {
  position: relative;
  display: inline-block;
  //background-color:#c0c0c0;
}

/* Dropdown Content (Hidden by Default) */
.dropdown-content {
  display: none;
  flex-direction:column;
  flex-wrap:nowrap;
  position:fixed;
  top: 53px;
  left: 0px;
  width: 220px;
  cursor: pointer;
  background-color: #d0d0d0;
  font-size:12px;
  //border: 1px solid #c0c0c0; this was just to debug CSS issues
}

.dropdown-content ul {
 height:100rem;    
}

.dropdown-content li {
    height:2em;
    width:219px;
} 

/* Links inside the dropdown */
.dropdown-content a { 
  color: black;
  margin:5px;
  text-decoration: none;
  //background-color:#d0d0d0;
  //border: 1px solid #c0c0c0; this was just to debug CSS issues
}

/* Change color of dropdown links on hover */
.dropdown-content a:hover {background-color:#c0c0c0;}

/* Show the dropdown menu (use JS to add this class to the .dropdown-content container when the user clicks on the dropdown button) */
.show {display:block;}

#hamburger-icon {
color:white;
}



.overlord {width:100%;height:100%;margin:0;padding:0;}
.modal {
    display:none;
    position:fixed;
    width:100%;
    height:100%;
    z-index:99999;
    background:#202020;
    top:52px;left:0;
    color:white;
    border-top:2px solid #c0c0c0;
}

.closeModal {
        background: #c0c0c0;// #606061;
        width:20px;
        height:20px;
        color: #FFFFFF;
        //line-height: 25px;
        position: relative;
        text-align: center;
        vertical-align: middle;
        top:5px;
        left:5px;
        text-decoration: none;
        border:1px solid white;
}
.closeModal:hover {background:white;color:black;border:1px solid #c0c0c0;}

.modalDialog  {
    position:relative;
    width:50%;
    margin: 10% auto;
    color: #c0c0c0; 
    background-color: #202020; 
    overflow-y: auto;
    overflow-x: hidden;
    display:none;
} 

.modalDialog form   {line-height: 1.3rem;}
.modalDialog input  {width:100%;font-size:12pt;padding:5px;}
.modalDialog input[type="checkbox"] {width:auto;}
.modalDialog label  { }
.modalDialog button {font-size:12pt;padding:8px;margin-top:5px;margin-left:0;display:block;}
.modalDialog p      {margin-bottom:1.5rem;}
.modalDialog h2     {font-size:1.5rem;margin-bottom:1.5rem;}

.isTyping { position:relative; left:0px;}

 </style>


  <title>Quack!</title>
  <meta name="description" content="A quick hack slack">
  <meta name="author" content="The HTML & CSS was derived from https://www.bootdey.com/snippets/view/slack-desing many thanks!">
</head>

<body>

<div class="modal" id="modal">
    <div class="closeModal" onclick="closeModal()">X</div>
    <div class="modalDialog" id="form1">
          <h2>Modal Form #1</h2>
        <form>
            <label for="input1">Label for input1:</label>
            <input name="input1" id="input1" placeholder="Enter something here">
            <label for="input2">Label for input2:</label>
            <input name="input2" id="input2" placeholder="Enter something else here">
            <button>click me</button>
            <p>This is a sample modal box that can be created using the powers of CSS3.</p>
            <p>You could do a lot of things here like not having a pop-up ad that shows when your website loads, or create a login register form for users.</p>
        </form>
     </div>

     <div class="modalDialog" id="form2">
          <h2>Modal Form #2</h2>
        <form>
            <label for="input3">Label for input3:</label>
            <input name="input3" id="input3" placeholder="Enter something here">
            <label for="input4">Label for input4:</label>
            <input name="input4" id="input4" placeholder="Enter something else here">
            <button>click me</button>
            <p>This is form #2 within the modal
        </form>
     </div>

     <div class="modalDialog" id="invite">
         <h2>Invite someone new</h2>
          <p>To invite someone to this Quack session type their email address below.</p>
         <form>
            <label for="newInvite">New person's email:</label>
            <input name="email" id="newInvite" placeholder="user@somewhere.org">
            <button>Send invitation</button>    
        </form>
     </div>

     <div class="modalDialog" id="preferences">
         <h2>Preferences</h2>
         <form>
             <label for="newInvite">Change your screen name</label>
            <input name="email" id="newScreenName" placeholder="anonymous">
            <label for="newInvite">Change your email</label>
            <input name="email" id="newEmail" placeholder="user@somewhere.org">
            <label>
            <input type="checkbox" name="playSound" id="playSound" checked> Play notice sound on new messages
            </label>
            <button>Send invitation</button>    
        </form>
     </div>

</div>


 <div class="overlord">

    <div class="header">
        <div class="hamburger-menu dropdown"><a onclick="toggle_dropdown()" ><span id="hamburger-icon" style="font-size:1.5em;">&#9776;</span> QUACK</a> 
            <!-- hamburger menu items -->
              <div id="hamburger-dropdown" class="dropdown-content">
                  <ul>
                  <li><a href="#openModal" onclick="openModal('#preferences')">Preferences</a></li>
                <li><a href="#openModal" onclick="openModal('#form1')">Open Modal form1</a></li>
                <li><a href="#openModal" onclick="openModal('#form2')">Open Modal form2</a></li>
                <li><a href="#" onclick="openModal('#invite')">Invite new user</a></li>
                <li><a href="#">Pick nose</a></li>
                <li><a href="#">Pay developers</a></li>
                </ul>
              </div>
            <!-- end of hamburger menu items -->
        </div>

        <div class="channel-menu">
            <span id="org_messages" style="position:relative;margin-left:15px;top:5px;"></span>
            <span style="position:absolute;right:5px;top:5px;">
                <input name="search" placeholder="Search"/>
           </span>
        </div>
    </div> <!-- end header -->

    <div class="main">
        <div class="listings">
            
            <div class="listings_channels">
                <h2 class="listings_header">Channels</h2>
                <ul class="channel_list" id="channel_list">
                    <!--
                    <li class="channel active"><a class="channel_name"><span class="unread">0</span><span><span class="prefix">#</span>admin</span></a></li>
                    
                    <li class="channel"><a class="channel_name"><span class="unread">10</span><span><span class="prefix">#</span>general</span></a></li>
                    -->
                </ul>
            </div>

            <div class="listings_direct-messages">
                <h2 class="listings_header">Direct Messages</h2>
                <ul class="channel_list" id="user_list">
                    <!--
                    <li class="channel">
                        <a class="channel_name">
                            <span class="unread">20</span>
                            <span><span class="prefix">*</span>Aaron</span>
                        </a>
                    </li>
                    <li class="channel">
                        <a class="channel_name">
                            <span class="unread">18</span>
                            <span><span class="status_prefix status_available">&#9702;</span>Ben</span>
                        </a>
                    </li>
                    -->
                </ul>
            </div>
        </div>
        <div class="message-history" id="messages">
            <!-- div class="message"><a class="message_profile-pic" href=""></a><a class="message_username" href="">Cube</a><span class="message_timestamp">1:31 AM</span><span class="message_star"></span><span class="message_content">Slack Technologies, Inc. (originally Tiny Speck) is a computer software startup founded in 2009, with personnel located in Vancouver, San Francisco and Dublin. The core team is largely drawn from the founders of Ludicorp, the company that created Flickr. Slack is the fastest company to receive a billion dollar valuation.</span></div>
            <div class="message"><a class="message_profile-pic" href=""></a><a class="message_username" href="">Cube</a><span class="message_timestamp">1:31 AM</span><span class="message_star"></span><span class="message_content">Rather than trying to make your own, use RocketMail instead.</span></div -->
        </div>
    </div> <!-- end main -->

    <div class="footer">
        <div class="user-menu">
            <span class="unset-pic user-menu_profile-pic"></span>
            <span class="user-menu_username" id="username">Cube</span>
            <input type="checkbox" id="online_status"  onchange="online_status_change()">
            <!--img class="connection_icon" src="data:image/png;base64,iVBORw0KGgoAAAAN..." /-->
            <span class="connection_status">online</span>
        </div>
        <div class="input-box">
             <!-- textarea  class="input-box_text" id="message_input"  onkeydown="check_message_key(event)"
             onkeyup="preview_message()"></textarea -->
             <a href="#" id="sendArrow" onclick="send_the_message()">&#9650;</a><!-- input class="input-box_text" type="text" / -->
             <!-- orig, &#9650;. &#8648; &#8648; &#8687; alt arrows -->
        </div>
    </div>  <!-- end footer -->
    <!-- must be outside in order to grow -->
    <span role="textbox" contenteditable=""  class="input-box_text" id="message_input" onkeyup="check_message_key(event)"></span>
    
</div> <!-- overlord -->

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/commonmark/0.29.3/commonmark.min.js"></script>

<script>

 var messdiv=$('#messages')

// these are for the websocket connection
 var socket;
 var userId, userName, orgId, curStream;
 var cd = $('#chatdiv');
 var prot;

 if (/^https:/.test(window.location.href))
  prot='wss://'
 else
  prot='ws://'

// these are for markdown
 var md_reader = new commonmark.Parser({smart:true,safe:true,softbreak:"<br />"});
 var md_writer = new commonmark.HtmlRenderer({smart:true,safe:true,softbreak:"<br />"});
 

/* ********************************************************************************************* */
// Deal with the hamburger menu and modal dialog windows
/* ********************************************************************************************* */


 // these open and close the modal dialogs as specified by the hamburger menu
 function closeModal(){
     $('.modalDialog').css("display","none");
     $('#modal').css("display","none");
 }

 function openModal(name){
     var modal=$('#modal');
     $(modal).css("display","block");
     $(name).css("display","block");
     // this doesn't work as expected the desired effect is for ESC to close the modal
     $(modal).on('keydown', function(event) {
        switch(event.keyCode){
               case 27: { closeModal(); return(true); } 
        }
        });
 }

// opens and closes the menu when the hamburger is clicked 
function toggle_dropdown() {
     var dropdown=$(".dropdown-content");
     if($(dropdown).css("display")!="flex"){
          $(dropdown).css("display","flex");
          $("#hamburger-icon").html("&#9851;");
      }    
      else {
        $("#hamburger-icon").html("&#9776;");
          $(dropdown).css("display","none");
          closeModal();    
      }
 }
    

/* ********************************************************************************************* */
// Handle the things related to showing and entering messages
/* ********************************************************************************************* */

// force a leading zero on date items
function leading_zero(n){
    n = n.toString();
    while (n.length < 2) n = "0" + n;
    return(n);
}

 function date_string(when){
     var day_names = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
     var month_names = ['Jan','Feb','Mar','April','May','June','July','Aug','Sep','Oct','Nov','Dec'];
     return(`${day_names[when.getDay()]} ${month_names[when.getMonth()]} ${when.getDate()} ${leading_zero(when.getHours())}:${leading_zero(when.getMinutes())}:${leading_zero(when.getSeconds())}`);
 }
 
 // generates the HTML for a message
 function format_message(entry){
    var msgobj = entry.value;
    var msgid  = entry.id;
    var obj, message_json=msgobj.msg, from=msgobj.from;

    if(typeof message_json == "string")
        obj=JSON.parse(message_json);
    else
        obj=message_json;

    if(typeof obj != "object")
    {
        console.log("Error",entry);
        return;
    }

    var  when=obj.when;
    //accept Date or date_string or number
    if (typeof when != "object")
        when = new Date(when);

//console.log("MESSAGE:", obj);
//console.log("FROM:", from);

    if(!obj.message) {
        console.log("DANGER WILL ROBINSON!!!");
        return;
    }

    var  parsed  = md_reader.parse(obj.message);
    var  result  = md_writer.render(parsed);

    return (`
                    <div id="${msgid}" class="message">
                            <a class="unset-pic message_profile-pic" href="" data-id="${from}"></a>
                            <a class="message_username" href="">${obj.who}</a>
                            <span class="message_timestamp">${date_string(when)}</span>
                            <span class="message_star"></span>
                            <span class="message_content">${result}</span>
                    </div>
            `);
 } 

var updated_pics={};

function checkimg(img,func, errfunc, param){
    $("<img>")
        .on("load", function() {
            func(param); 
        })
        .on("error", function(){
            errfunc(param);
        })
        .attr("src", img);
}

function updatePics(){
    var upics = $(".unset-pic");
    upics.each(function(){
        var t=$(this);
        var id=t.attr("data-id");
        if(!id)
            return;

        var img=`/profpics/${id}.jpg`;
        if ( updated_pics[id]===undefined){
            //first check of this id.jpg
            checkimg(
                img, 
                //success function
                function(id){
                    t.css("background-image", "url(" + img + ")");
                    updated_pics[id]=true;
                }, 
                //error function
                function(id) {
                    updated_pics[id]=false;
                }, 
                id
            );
        }
        else if (updated_pics[id])//we checked it already and its good
            t.css("background-image", "url(" + img + ")");
        // else if false, leave blank

        t.removeClass('unset-pic');
    });
}


 // print a new message to the message window
 function append_message(msg) {
     var  div=$(messages);
     $(div).append(format_message(msg));
     $(div).animate({scrollTop: $(div).prop("scrollHeight")},0);
 }

 // in case you need to scroll back in time 
 function prepend_message(msg) {
     var  div=$(messages);
     $(div).prepend(format_message(msg));

 }

 // transmit a new message to the server
 function send_the_message() {
    // the setTimeout is executed after the key event
    setTimeout(function(){
        $("#preview").remove(); 
        //$("#message_input").val("");
        $("#message_input").html("");
    },0);
    var txt = $("#message_input").text();
    if(txt.length)
        wsSend ({who:userName,when:Date.now(),message:txt});
        //wsSend (JSON.stringify({who:userName,when:Date.now(),message:txt}));
 }

// this is for the message textarea to turn SHIFT-ENTER into a send
function check_message_key(event) { 

    if (event.keyCode == 13) {  
        if(event.shiftKey){
            event.stopPropagation();
            event.stopImmediatePropagation();
            send_the_message();   
        } 
    } else {
        // executed after the key event
        setTimeout(preview_message,0);
        return(true);
    }
}
var isTyping=false;
// show the markdown version of the textarea in the message window 
function preview_message() {
    var txt = $("#message_input").text();

    $("#preview").remove();
    
    // this removes the preview if the text in the box was deleted or if there is none, but
    // the shift or control key is pressed.  We might want to filter out keyup event where 
    // it's the shift/ctrl/meta or whatever.
    if(txt.length)
    {
        var message_obj=JSON.stringify({who:"unsent:",when:Date.now(),message:txt});
        //var message_obj=JSON.stringify({who:"unsent:",when:Date.now(),message:$("#message_input").val()});
        var div=$(messages);
        var html=format_message({id:"unsent-msg", value:{msg:message_obj, from:userId}});

        if(haveMostRecentMsg(curStream))
            div.animate({scrollTop: $(div).prop("scrollHeight")},0);
        else //we scrolled up to far, must grab most current messages again.
        // Problem is that we'd have to wait for a reply from the server, and 
        // for messages to be displayed before adding the preview html.
        // So for now, if you are scrolled up too far and type, it will not
        // show the preview.
            return;

        html='<span id="preview">'+html+'</span>';
        div.append(html);
        
        if(!isTyping) {
            setTimeout(function(){ isTyping=false; }, 2000);
            isTyping=true;
            wsSend({orgMsg: "isTyping", who:userName});
        }
    }
}




/* ********************************************************************************************* */
// User Interactions
/* ********************************************************************************************* */

var quack_users=[];     // this maintains the list of Quack users 
var online;
// This handles the checkbox interaction with the current user
function online_status_change(){
    online=$("#online_status").prop("checked");
    if(online)    
        wsSend("onln");        
    else
        wsSend("slep");
}

function make_user_listing(user){
    var unread="";
    //user.status is "online", "offline" or "sleep"
    var online = (user.status=="online" || user.status=="sleep");
    var status = user.status=="online";

    if(user.unread)
            unread=`<span class="unread">${user.unread}</span>`;
    return(`
        <li class="channel" id="user${user.user_id}">
            <a class="channel_name channel_name_outer">
              ${unread}
              <span class="status_prefix ${status?'status_available':''}">${online?'&#x29BF;':'&#x29BE;'}</span><span class="channel_name">${user.username}</span>
            </a>
        </li>`
    );    
}

function display_user(user) {
    var  div=$("#user_list");
    var  id='#user'+user.user_id;
    if(userName==user.username) // don't display self
        return;
    $(id).remove(); // ensure that id is not already shown
    $(div).append(make_user_listing(user));    
}

// CALL THIS UPON INITIALIZATION OR REFRESH
function add_user(user) {
    var i;
    for(i=0;i<quack_users.length;i++)
        if(quack_users[i].user_id==user.user_id)
            return; // user already exists

    quack_users[i]=user;
    display_user(user);
    init_channel_onclick();            
}

// change an attribute of a user and update the html
function update_user(user_id,key,val)
{
      var  i;

    for(i=0;i<quack_users.length;i++)
        if(quack_users[i].user_id==user_id){
            var id='#user'+quack_users[i].user_id,
                iddiv=$(id),
                isactive;
            quack_users[i][key]=val;
            isactive = iddiv.hasClass('active');
            iddiv.replaceWith(make_user_listing(quack_users[i]));
            if(isactive)
                $(id).addClass('active');
            return;
        }
}

// retrieve an attribute of a user
function user_attr(user_id,key)
{
    var  i;

    for(i=0;i<quack_users.length;i++)
        if(quack_users[i].user_id==user_id){
            return quack_users[i][key];
        }
    return; //undefined
}

// removes all the channels from both the array and the UI 
function clear_users(){
    var  id="";
    var  user={};
    while(quack_users.length){
        user=quack_users.pop();
        id='#user'+user.user_id;
        $(id).remove();
    }
}

/* ********************************************************************************************* */
// Channel Interactions
/* ********************************************************************************************* */

var quack_channels=[];    // and these are the channels

function make_channel_listing(channel){
    var unread="";

    if(channel.unread)
            unread=`<span class="unread">${channel.unread}</span>`;
    return(`
        <li class="channel" id="channel${channel.channel_id}">
            <a class="channel_name channel_name_outer">
              ${unread}
              #<span class="channel_name">${channel.channel_name}</span>
            </a>
        </li>`
    );        
}

function display_channel(channel) {
    var  div=$("#channel_list");
    var  id='#channel'+channel.channel_id;
    $(id).remove(); // ensure that id is not already shown
    $(div).append(make_channel_listing(channel));    
}

// CALL THIS  UPON INITIALIZATION or REFRESH
function add_channel(channel) {
    var i;
    for(i=0;i<quack_channels.length;i++)
        if(quack_channels[i].channel_id==channel.channel_id)
            return; // channel already exists

    quack_channels[i]=channel;
    display_channel(channel);
    init_channel_onclick();        
}


// retrieve an attribute of a channel and update the html
function channel_attr(channel_id,key)
{
    var  i;

    for(i=0;i<quack_channels.length;i++)
        if(quack_channels[i].channel_id==channel_id){
            return quack_channels[i][key];
        }

    return;//undefined
}

// change an attribute of a channel and update the html
function update_channel(channel_id,key,val)
{
    var  i;

    for(i=0;i<quack_channels.length;i++)
        if(quack_channels[i].channel_id==channel_id){
            var id='#channel'+channel_id, 
                iddiv=$(id),
                isactive;
            quack_channels[i][key]=val;
            isactive = iddiv.hasClass('active');
            iddiv.replaceWith(make_channel_listing(quack_channels[i]));
            if(isactive) $(id).addClass('active');
            return;
        }
}

// removes all the channels from both the array and the UI 
function clear_channels(){
    var  id="";
    var channel={};
    while(quack_channels.length){
        channel=quack_channels.pop();
        id='#channel'+channel.channel_id;
        $(id).remove();
    }
}

// given an html tag id for a user or channel, find the record and return the name and type
function lookup_name_by_tag_id(id){
     var i;
    id= /[0-9a-f]{8,}/.exec(id);  // strip off "user" and "channel from the id" 
   
     for(i=0;i<quack_users.length;i++)
         if(id==quack_users[i].user_id)
             return({type:"@",name:quack_users[i].username});

      for(i=0;i<quack_channels.length;i++)
         if(id==quack_channels[i].channel_id)
             return({type:"#",name:quack_channels[i].channel_name});

  return({type:"!",name:"error"});
}

/* cache of channel/dm messages */
//var cacheWindow=100

//testing
var cacheWindow=25;

var nCacheItems=2*cacheWindow;
var msgcache={};

function haveCache(stream) {
    if(msgcache[stream])
        return true;
    return false;
}

/* set/get scroll position */
function cacheLastScroll(stream, top) {
    var cache = msgcache[stream];

    if(!cache)
        return;//undefined

    if(top===undefined)
        return cache.lastScroll;
    else
        cache.lastScroll=top;

    return true;
}

/* set the most recent redis id of a given stream.  
   Note the id may have been evicted from the cache.  */
function mostRecentMsg(stream,id) {
    var cache = msgcache[stream];


    if(id===undefined)
    {
        if(!cache || !cache.mostRecent)
            return;//undefined
        return cache.mostRecent;
    } 
    else
        cache.mostRecent=id;

    return true;
}

/* get whether we have in the cache the latest message available for a stream */
function haveMostRecentMsg(stream) {
    var cache = msgcache[stream];
    var id = mostRecentMsg(stream);
    
    if (!id || !cache || !cache.entries || !cache.entries.length)
        return true; //this might seem odd, but in this case we are saying our cache is not in the middle of the stream

    var lastid = cache.entries[cache.entries.length-1].id
    return lastid == id;
}

/* get/set whether we have in the cache the earliest message available for a stream */
function scrollAtTop(stream, val) {
    var cache = msgcache[stream];
    if(val === undefined) {
        if(!cache)
            return false;

        return (cache.scrollTopped == true);
    }

    if(!cache)
        return;

    cache.scrollTopped=val;

    return true;
}

function cacheMsg(stream, msg) {
    if(!msgcache[stream])
        msgcache[stream]={lastScroll:0, entries:[]};

    var cache = msgcache[stream];
    cache.entries.push(msg);
    if(cache.entries.length > nCacheItems)
    {
        cache.scrollTopped=false;
        cache.entries.shift();
    }
}

function cacheMsgRev(stream, msg) {
    if(!msgcache[stream])
        msgcache[stream]={lastScroll:0, entries:[]};

    var cache = msgcache[stream];
    cache.entries.unshift(msg);
    if(cache.entries.length > nCacheItems)
        cache.entries.pop();

}

function getCacheLastRedisId(stream){
    var cache = msgcache[stream];
    if (cache && cache.entries && cache.entries.length)
        return cache.entries[cache.entries.length-1].id
    else
        return '-';
}
function getCacheFirstRedisId(stream){
    var cache = msgcache[stream];
    if (cache && cache.entries && cache.entries.length)
        return cache.entries[0].id
    else
        return '+';
}

function getCacheMsgs(stream, func) {
    var cache_entries, cache = msgcache[stream], i=0;

    if(cache && cache.entries && cache.entries.length)
        cache_entries=cache.entries;
    else
        return 0;

    for ( ; i<cache_entries.length; i++) 
        func(cache_entries[i]);

    return i;
}

// this attaches a click handler to each channel or user that'll switch the ui to that channel or user
function init_channel_onclick(){
    var name_info={};
//    this needs to match dynamically/live because when userstatus is updated, the .channel span is replaced
//    $(".channel").on('click', function(event){
    $('body').on('click', '.channel', function(event){
        if($(".channel.active").length && $(this)[0] == $(".channel.active")[0])
            return;

        var id = $(this).attr('id');
        $(".channel").removeClass('active');
        $(this).addClass('active');
        name_info=lookup_name_by_tag_id(id);
        $("#channel_banner").html(`<span class="channel-menu_prefix">${name_info.type} </span>${name_info.name}`);
        $("#messages").html(""); 

        if(/channel/.test(id))
            curStream = id.substr(7); //i.e. - 60715c529
        else
            curStream = [userId,id.substr(4)].sort().join(":"); //i.e. - 60735f529:60735f530


        var count = getCacheMsgs(curStream, append_message);

        if(!count) {
            wsSend({subStream: curStream, nUpdate:cacheWindow});
            scrollAtTop(curStream, false);
        } else {
            var saved_top = cacheLastScroll(curStream);

            updatePics();

            if (saved_top !== undefined)
                messdiv.scrollTop(saved_top);

            wsSend({subStream: curStream, nUpdate:0});//tell server we switched channels, but don't need messages
        }

        $(this).find('.unread').remove();
        event.stopPropagation();
        event.stopImmediatePropagation();
    });
}

function playquack() {
  var audio = new Audio('/quack_redis_chat/quacker.mp3');
  audio.play();
}

/* turn xxx:xxx -> userxxx
   or   yyyy    -> channelyyy    */
function streamToChanId(sname){
    var chanid, ids = sname.split(':');
    if (ids.length==1)
        chanid="channel"+ids[0];
    else
    {
        if(ids[0]==userId)
            chanid="user"+ids[1];
        else
            chanid="user"+ids[0];
    }
    return chanid;
}

/* turn xxx:xxx -> xxx
   or   yyyy    -> yyyy    */
function streamToChannel(sname){
    var chanid, ids = sname.split(':');
    if (ids.length==1)
        return {channel:ids[0]};
    else
    {
        if(ids[0]==userId)
            return {user: ids[1]};
        else
            return {user: ids[0]};
    }
}



/* ***************************************
    send/handle websocket messages  
   *************************************** */

var to_id={},ti_id={};

/* handle organization wide messages 
   Currently it is for "is-typing" updates only
   but framework is in place for other 
   messages that could be sent to every 
   user in an organization              */
function proc_org_msg(msg) {
    var jmsg;
    var msgStream = msg.value.stream;
    try {
        jmsg=JSON.parse(msg.value.msg);
    } catch(e){console.log(e)}

    if(jmsg) {
        if(jmsg.orgMsg=="isTyping" && msg.value.from !=userId) {

            /* ... in the channel label */
            var chanli = $('#'+streamToChanId(msgStream));
            clearTimeout(to_id[msgStream]);
            if(!chanli.find('.isTyping').length) {
                chanli.append('<span class="isTyping">...</span>');
                //animate first loop
                chanli.find('.isTyping').stop(true,true).animate({left: 8}, 500, function(){ 
                    $(this).stop(true,true).animate({left: 0}, 500); 
                });
                //continue to animate
                ti_id[msgStream]=setInterval(function(){
                    chanli.find('.isTyping').stop(true,true).animate({left: 8}, 500, function(){ 
                        $(this).stop(true,true).animate({left: 0}, 500); 
                    });
                }, 1000);
            }
            to_id[msgStream]=setTimeout(function(){
                clearInterval(ti_id[msgStream]);
                chanli.find(".isTyping").remove();
            },2500);

            /* "[user] is typing" message somewhere */
            if(msgStream==curStream)
            {
                clearTimeout(to_id.orgmsg);
                $('#org_messages').text( jmsg.who+" is typing" );
                to_id.orgmsg=setTimeout(function(){
                    $('#org_messages').text("");
                },2500)
            }
        }
        else if (jmsg.status)
        {
            //console.log("new status for " + msg.value.from+": "+jmsg.status);
            update_user(msg.value.from, "status", jmsg.status);
        }
//        console.log(jmsg.who+" is typing");
    }
}

/* handle drag and drop of files */
function handle_drop(e){
    e.preventDefault();
    e.stopPropagation();
    messdiv.removeClass("dropping");
    e = e.originalEvent;

    function sendfile(file) {
        var reader = new FileReader()
        reader.onload = function (event) {
            socket.send(event.target.result);
        };
        reader.readAsArrayBuffer(file);
        //displaydrop({from:name,file:{name:file.name,type:file.type}}, file);
    }

    if (e.dataTransfer.items) {
        // Use DataTransferItemList interface to access the file(s)
        for (var i = 0; i < e.dataTransfer.items.length; i++) {
            // If dropped items aren't files, reject them
            if (e.dataTransfer.items[i].kind === 'file') {
                var file = e.dataTransfer.items[i].getAsFile();
                wsSend( {file:{name:file.name,type:file.type}} );
                sendfile(file);
            }
        }
    } else {
        // Use DataTransfer interface to access the file(s)
        for (var i = 0; i < e.dataTransfer.files.length; i++) {
            var file = e.dataTransfer.files[i];
            wsSend({file:file}); 
            sendfile(file);
        }
    }
}

messdiv.on("drop",handle_drop).on("dragover",function(e){
    e.preventDefault();  
    e.stopPropagation();
    messdiv.addClass("dropping");
}).on("dragleave",function(e){
    e.preventDefault();  
    e.stopPropagation();
    messdiv.removeClass("dropping");
});

/* redo messages from the cache */
function redraw_messages(stream) {
    //find the first visible message and get it's position
    var first, msgs=messdiv.find('.message');
    var diff = messdiv.position().top;

    /* find first visible message */
    msgs.each(function(){
        var t=$(this);
        first=t.attr('id');
        if(t.position().top>0)
            return false;
    });

    scrollAtTop(curStream, true); //temporarily prevent scroll=0 trigger
    messdiv.html("");
    
    getCacheMsgs(stream, append_message);    

    var newscroll =  $('#'+first).position().top + messdiv.scrollTop() - diff;

    messdiv.scrollTop(newscroll);
    scrollAtTop(curStream, false);
}

function updateCount(stream, diff) {
    var userchan = streamToChannel(stream);

    if(userchan.channel) {
        var count = channel_attr(userchan.channel,"unread");
        if(count===undefined) return;
        update_channel(userchan.channel,"unread",count+diff);
    } else {
        var count = user_attr(userchan.user,"unread");
        if(count===undefined) return;
        update_user(userchan.user,"unread",count+diff);
    }

    if(online)
        playquack();

}

function resetCount(stream,count) {
    var userchan = streamToChannel(stream);

    if(userchan.channel) {
        update_channel(userchan.channel,"unread",count);
    } else {
        update_user(userchan.user,"unread",count);
    }

}

/* handle messages */
function ws_procmess(msg) {
    var data;

    if(msg.data=='pong')
        return;

    try{
        data = JSON.parse(msg.data);
    } catch (e) {
        alert('error parsing websocket message');
    }

//console.log("incoming ws",data);

    // upon connecting
    if(data.from=="System" && data.msg=="connected")
    {
        $('#online_status').prop( "checked", true );
        online=true;
        if(data.lastchan)
        {
            var chanid = streamToChanId(data.lastchan);
            var chanli = $('#'+chanid);
            if(chanli.length)
                chanli.click();
            else
                $('.channel').eq(0).click();
        }
        else
            $('.channel').eq(0).click();
    }
    // an organizational wide message
    else if (data.stream == orgId)
    {
        proc_org_msg(data.data[0])
    }
    //a message for the active stream/channel
    else if (data.stream == curStream)
    {
        var msgs = data.data;
        if(msgs)
        {
            if(data.prepend) { //scrolling up
                var i=msgs.length;
                if(!i){
                    scrollAtTop(curStream, true);
                    return;
                }
                while (i--)
                    cacheMsgRev(curStream, msgs[i]);

                redraw_messages(curStream);
            } else if (data.append) { //scrolling down (after scrolling up and cache items were evicted)
                var i=0;

                if(!msgs.length)
                    return;

                for(var i=0; i<msgs.length; i++)
                    cacheMsg(curStream, msgs[i]);

                redraw_messages(curStream);
            } else {
                // update the message list.  However if we are scrolled up
                // we can't display the message or add to the cache.  Just update count.
                var doappend = haveMostRecentMsg(curStream);
                if(doappend) {
                    for (var i=0;i<msgs.length;i++) {
                        append_message(msgs[i]);
                        /* add to cache only if grabbing history when switching channels
                           or if we already have a cache entry                      */
                        if(haveCache(curStream)|| data.isHistory)
                            cacheMsg(curStream, msgs[i]);
                    }
                    resetCount(curStream,0);
                } else {
                    // this should only happen when a single message is coming in, 
                    // isHistory==false and we are scrolled up enough to invalidate recent cache
                    updateCount(curStream, 1);
                }
                //this is our most recent message
                mostRecentMsg(curStream, msgs[msgs.length-1].id);
            }
            updatePics();
        }
    } 
    else if (data.stream)
    {
        var msgs = data.data;

        //currently we should always have msgs and msgs.length == 1
        if(msgs && haveCache(data.stream)) {
            for (var i=0; i<msgs.length; i++)
                    cacheMsg(data.stream, msgs[i]);
        }
        updateCount(data.stream, 1)
    }
}

var connected=false;
/* send message */
function wsSend(msg){

    var data;
    if(msg){
        //4 char strings are status update or ping.  Just send text
        if(typeof msg=="string" && msg.length==4)
            data=msg;
        else
            //msg should be an object
            data = JSON.stringify({
                msg: msg,
                from: userId,
                stream: curStream
            });
    } else {
        //calling without a message is a ping
        data="ping";
    }

    if(connected)
        socket.send(data);//connection errors don't throw, so must manually check.

    if(socket && socket.readyState > 1) { //if closing or closed
        connected=false;
        $('#online_status').prop( "checked", false );
        online=false;
        socket = new WebSocket(prot + window.location.host + `/wsapps/quack_redis_chat/quackchat.json?userid=${userId}&orgid=${orgId}`);
        // kinda useless for our purposes
        // socket.addEventListener('error', function(e){ console.log("error",e);});
        socket.addEventListener('open', function(e){
            connected=true;
            socket.send(data);
            //console.log("RECONNECT");
            socket.onmessage = ws_procmess;
        });
        return;
    }
//    if(data!="ping")
//        console.log(data);
}

//https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
function getParameterByName(name, url = window.location.href) {
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}


/* *************************************************************************************************** */
// The main event
/* *************************************************************************************************** */

//temporary to set account
var username = getParameterByName("user");

if(!username) username="Aaron";

/* TODO: test for errors */
$.get(`/apps/quack_redis_chat/quackerjax.json?orgname=Quack,+Inc&user=${username}`, function(res){
    var i=0;

    orgId=res.orgid;

    for(i=0;i<res.users.length;i++)
    {
        if(res.users[i].user_id == res.id)
        {
            $('#username').text(res.users[i].username);
            $('.user-menu_profile-pic').attr("data-id", res.id);
            userName=res.users[i].username;
            userId=res.id;
            updatePics();
            break;
        }
    }
    if(i==res.users.length)
    {
        alert("current user info missing");
        return;
    }
    // display users
    for(i=0;i<res.users.length;i++)
      add_user(res.users[i]);

    // display channels
    for(i=0;i<res.channels.length;i++)
      add_channel(res.channels[i]);

    if(socket)
        socket.close();
    
    socket = new WebSocket(prot + window.location.host + `/wsapps/quack_redis_chat/quackchat.json?userid=${userId}&orgid=${orgId}`);
    socket.addEventListener('open', function(e){
        connected=true;
        socket.onmessage = ws_procmess;
        //check for disconnect every x seconds with a ping
        setInterval(wsSend,5000);
    });
});


function load_prev_messages() {
    if(scrollAtTop(curStream))
        return;
    var firstId = getCacheFirstRedisId(curStream);
    wsSend({subStream: curStream, nUpdate:cacheWindow, firstId:firstId});
}

function load_next_messages() {
    if(haveMostRecentMsg(curStream))
    {
        resetCount(curStream,0);
        return;
    }
    var lastId = getCacheLastRedisId(curStream);
    wsSend({subStream: curStream, nUpdate:cacheWindow, lastId:lastId});
}

var lastspos=0;
/* handle scroll up and history */
messdiv.scroll(function(e){
    var msgHeight = messdiv.prop('scrollHeight');
    var divHeight = messdiv.innerHeight();
    var smax = messdiv.prop('scrollHeight') - messdiv.innerHeight();
    var spos = messdiv.scrollTop();
    //console.log(spos,smax, haveMostRecentMsg(curStream));

    if(msgHeight<=divHeight)
        return;

    if(spos == 0)
        load_prev_messages();
    else if(spos >= smax && lastspos < smax)
    {
        //console.log("That's a bingo");
        load_next_messages();
    }

    lastspos = spos; //safari goes past the bottom when it does its little animation
    cacheLastScroll(curStream, spos);
});



</script>
</body>
</html>