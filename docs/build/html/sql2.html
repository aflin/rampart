

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Queries Involving Calculated Values &mdash; Rampart 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/hacks.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Rampart 0.1.0 documentation" href="index.html"/>
        <link rel="up" title="The rampart-sql module" href="sqltoc.html"/>
        <link rel="next" title="Intelligent Text Search Queries" href="sql3.html"/>
        <link rel="prev" title="Introduction to Texis SQL" href="sql1.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Rampart
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="rampart-main.html">Rampart JavaScript</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-utils.html">Rampart Utility Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="sqltoc.html">The rampart-sql module</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="rampart-sql.html">Preface</a></li>
<li class="toctree-l2"><a class="reference internal" href="rampart-sql.html#loading-the-javascript-module">Loading the Javascript Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="rampart-sql.html#database-functions">Database Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="rampart-sql.html#string-functions">String Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql1.html">Introduction to Texis SQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql1.html#creating-a-database">Creating a Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql1.html#table-definition">Table Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql1.html#a-first-look-at-queries">A First Look at Queries</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Queries Involving Calculated Values</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-calculations">Arithmetic Calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#manipulating-information-by-date">Manipulating Information By Date</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summarizing-values-group-by-clause-and-aggregate-functions">Summarizing Values: GROUP BY Clause and Aggregate Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#groups-with-conditions-having-clause">Groups With Conditions: HAVING Clause</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-queries">Advanced Queries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#retrieving-data-from-multiple-tables">Retrieving Data From Multiple Tables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#command-discussion">Command Discussion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nesting-queries">Nesting Queries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Command Discussion</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#forming-complex-queries">Forming Complex Queries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#joining-a-table-to-itself">Joining a Table to Itself</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correlated-subqueries">Correlated Subqueries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#subquery-using-exists">Subquery Using EXISTS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#virtual-fields">Virtual Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#column-aliasing">Column Aliasing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sql3.html">Intelligent Text Search Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql-server-funcs.html">Server functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql4.html">Indexing for Increased Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql4.html#keeping-the-database-current">Keeping the Database Current</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql4.html#security">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql4.html#administration-of-the-database">Administration of the Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="sql-set.html">Server Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="tsql.html">Tsql Command Line Utility</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm2.html">Metamorph: The Program Inside the Program</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm2.html#hits-intersections-and-sets">Hits, Intersections and Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm3.html">Thesaurus Customization</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm4.html">Tailoring Metamorph’s Linguistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm5.html">Types of Searches in Metamorph</a></li>
<li class="toctree-l2"><a class="reference internal" href="mm6.html">REX On Its Own</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rampart-server.html">The rampart-server module</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-html.html">The rampart-html module</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-crypto.html">The rampart-crypto module</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-curl.html">The rampart-curl module</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-lmdb.html">The rampart-lmdb module</a></li>
<li class="toctree-l1"><a class="reference internal" href="rampart-robots.html">The rampart-robots module</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Rampart</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="sqltoc.html">The rampart-sql module</a> &raquo;</li>
        
      <li>Queries Involving Calculated Values</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/sql2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="queries-involving-calculated-values">
<h1>Queries Involving Calculated Values<a class="headerlink" href="#queries-involving-calculated-values" title="Permalink to this headline">¶</a></h1>
<p>While Texis focuses on manipulation of textual information, data can
also be operated on numerically. Queries can be constructed which
combine calculated values with text search.</p>
<p>To illustrate the material in this section, this example uses an employee
table which the Personnel Department keeps to manage salaries and benefits.
A sampling of the data stored in this table follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EID  ENAME               DEPT   SALARY   BENEFITS
101  Aster, John A.      MKT    32000    FULL
102  Barrington, Kyle    MGT    45000    FULL
103  Chapman, Margaret   LIB    22000    PART
104  Jackson, Herbert    RND    30000    FULL
105  Price, Stella       FIN    42000    FULL
106  Sanchez, Carla      MKT    35000    FULL
107  Smith, Roberta      RND    25000    PART
</pre></div>
</div>
<div class="section" id="arithmetic-calculations">
<h2>Arithmetic Calculations<a class="headerlink" href="#arithmetic-calculations" title="Permalink to this headline">¶</a></h2>
<p>This section covers the computational features of Texis. They
allow the user to perform computations on the data and/or
retrieve rows based on conditions involving computations. For example,
salaries can be adjusted for a 5 percent across-the-board increase, or
weekly salaries can be computed (i.e., salary divided by 52).</p>
<p>Arithmetic calculations are performed on fields, or columns, in the
database. An <em>arithmetic expression</em> is used to describe the desired
computation. The expression consists of column names and numeric
constants connected by parentheses and arithmetic operators.
The table below shows the arithmetic operators used in Texis.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 29%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Arithmetic Operation</p></th>
<th class="head"><p>Texis Operator</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Addition</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">+</span> <span class="pre">2000</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Subtraction</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">-</span> <span class="pre">1000</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Multiplication</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">*</span> <span class="pre">1.05</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Division</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">/</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">/</span> <span class="pre">26</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Modulus <a class="footnote-reference brackets" href="#id3" id="id1">1</a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">%</span> <span class="pre">52</span></code></p></td>
</tr>
</tbody>
</table>
<p>Typically, the arithmetic expression is used in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause to
perform calculations on data stored in the table.</p>
<p><strong>Example:</strong> Next year every employee will receive a 5 percent salary
increase. List the names of each employee, his or her current salary,
and next year’s salary.</p>
<p>Enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>  <span class="n">ENAME</span><span class="p">,</span> <span class="n">SALARY</span><span class="p">,</span> <span class="n">SALARY</span> <span class="o">*</span> <span class="mi">1</span><span class="p">.</span><span class="mi">05</span>
<span class="k">FROM</span>    <span class="n">EMPLOYEE</span> <span class="p">;</span>
</pre></div>
</div>
<p>Where “<code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">*</span> <span class="pre">1.05</span></code>” is the arithmetic expression.</p>
<p>The results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME               SALARY     SALARY * 1.05
Aster, John A.      32000      33600
Barrington, Kyle    45000      47250
Chapman, Margaret   22000      23100
Jackson, Herbert    30000      31500
Price, Stella       42000      44100
Sanchez, Carla      35000      36750
Smith, Roberta      25000      26250
</pre></div>
</div>
<p>The expression “<code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">*</span> <span class="pre">1.05</span></code>” results in each value in the salary
column being multiplied by 1.05. The results are then displayed in a new
column that is labeled <code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">*</span> <span class="pre">1.05</span></code>.</p>
<p><strong>Example:</strong> What is John Aster’s weekly pay?</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>  <span class="n">ENAME</span><span class="p">,</span> <span class="n">SALARY</span> <span class="o">/</span> <span class="mi">52</span> <span class="k">as</span> <span class="n">WEEKLY_DOLLARS</span><span class="p">,</span>
<span class="n">SALARY</span> <span class="o">%</span> <span class="mi">52</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">52</span> <span class="k">as</span> <span class="n">WEEKLY_CENTS</span>
<span class="k">FROM</span>    <span class="n">EMPLOYEE</span> <span class="k">WHERE</span> <span class="n">ENAME</span> <span class="o">=</span> <span class="s1">&#39;Aster, John A.&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>The results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME             WEEKLY_DOLLARS  WEEKLY_CENTS

Aster, John A.    615             38
</pre></div>
</div>
<p>If more than one arithmetic operator is used in an arithmetic
expression, parentheses can be used to control the order in which the
arithmetic calculations are performed. The operations enclosed in
parentheses are computed before operations that are not enclosed in
parentheses. For example, the expression:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>12 * (SALARY + BONUS)
</pre></div>
</div>
<p>means bonus is added to salary, and then this result is multiplied by
12.</p>
<p>If parentheses are omitted or if several operations are included within
the parentheses, the order in which calculations are performed is as
follows:</p>
<ol class="arabic simple">
<li><p>First, all multiplication, division and modulo operations are
performed.</p></li>
<li><p>Then, all addition and subtraction operations are performed.</p></li>
</ol>
<p>For example, in the expression:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SALARY + SALARY * .05
</pre></div>
</div>
<p>the value in the SALARY column is multiplied by .05, and then the salary
value is added to this intermediate result.</p>
<p>When two or more computations in an expression are at the same level
(e.g., multiplication and division), the operations are executed from
left to right. For example, in the expression:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SALARY / 12 * 1.05
</pre></div>
</div>
<p>the salary value is first divided by 12, and then this result is
multiplied by 1.05.</p>
<p>Arithmetic calculation can also be used in a <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause to select
rows based on a calculated condition. In addition, arithmetic
expressions can be used in the <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> and <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clauses, which will
be discussed in later sections.</p>
<p><strong>Example:</strong> List the names of all employees earning a monthly salary
above $3000.</p>
<p>This query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>  <span class="n">ENAME</span>
<span class="k">FROM</span>    <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>   <span class="p">(</span><span class="n">SALARY</span><span class="o">/</span><span class="mi">12</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3000</span> <span class="p">;</span>
</pre></div>
</div>
<p>results in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME
Barrington, Kyle
Price, Stella
</pre></div>
</div>
<p>The rows in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table are retrieved if the condition
“salary divided by 12” is greater than $3000. This was true only for
Barrington and for Price, whose annual salaries (respectively $45,000
and $42,000) are greater than $3000 when divided by 12 months.</p>
</div>
<div class="section" id="manipulating-information-by-date">
<h2>Manipulating Information By Date<a class="headerlink" href="#manipulating-information-by-date" title="Permalink to this headline">¶</a></h2>
<p>In Texis dates are stored as integers representing an absolute number of
seconds from January 1, 1970, Greenwich Mean Time.  This is done for
efficiency, and to avoid confusions stemming from differences in relative
times assigned to files from different time zones.  On many 32 bit systems,
the allowable range of years is limited to 1970 through 2037.  See
<a class="reference external" href="https://en.wikipedia.org/wiki/Year_2038_problem">Year 2038 problem</a>
for a full discussion.</p>
<p>Years between 1902 and 1970 may be stored and compared for equality (<code class="docutils literal notranslate"><span class="pre">=</span></code>)
but will not compare correctly using less than (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>) and greater than
(<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>).</p>
<p>Counters may also be treated as dates for comparison purposes. They may
be compared to date fields or date strings. When compared with dates
only the date portion of the counter is considered and the sequence
number is ignored.</p>
<p>The comparison operators as given in
<a class="reference internal" href="sql1.html#compop"><span class="std std-ref">the comparison operators table</span></a> are used to
compare date values, so that dates may be used as qualifying statements
in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause.</p>
<p>A Date field may be compared to a number representing the number of
seconds since 1/1/70 0:0:0 GMT (e.g.: 778876248). It may also be
compared to a string representing a human readable date in the format
<code class="docutils literal notranslate"><span class="pre">'YYYY-MM-DD</span> <span class="pre">[HH:MM[:SS]</span> <span class="pre">[AM|PM]]'</span></code> (e.g.: <code class="docutils literal notranslate"><span class="pre">'1994-03-05</span> <span class="pre">06:30</span> <span class="pre">pm'</span></code>
or <code class="docutils literal notranslate"><span class="pre">'1994-07-04'</span></code>). The date string may also be preceded by
“<code class="docutils literal notranslate"><span class="pre">begin</span> <span class="pre">of</span></code>” or “<code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">of</span></code>” meaning the first or last second of a
day, respectively.</p>
<p>Example from a “NEWS” table:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">NDATE</span><span class="p">,</span> <span class="n">SUBJECT</span>
<span class="k">FROM</span>     <span class="n">NEWS</span>
<span class="k">WHERE</span>    <span class="n">NDATE</span> <span class="k">BETWEEN</span> <span class="s1">&#39;begin of 1993-07-30&#39;</span>
                   <span class="k">AND</span> <span class="s1">&#39;end of 1993-07-30&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>Although the date column is stored with an absolute value, it is converted
to the correct relative value when displayed.  However, a date assigned to a
file is to the second, and to match that time, you must match the same
number of seconds.  Stating the date as <code class="docutils literal notranslate"><span class="pre">1993-07-30</span></code> refers to a
particular second of that day.  A row with the date <code class="docutils literal notranslate"><span class="pre">1993-07-30</span> <span class="pre">14:02:01</span></code>
would not match in seconds.  Thus you state the range of seconds that span
the 24 hour period by specifying a range between the first to last moment of
the day.</p>
<p>In this example, all rows with dates/times on July 30, 1993
are displayed with their subject lines. The date as formatted by Texis
when displaying the date column is the format used inside the single
quotes. It is put in quotes because it is a text string rather than an
absolute value.</p>
<p>Dates are usually used to limit the amount of text retrieved based on
some other search requirement, and would be so used along with other
qualifying statements in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause. The next query is
identical to the last, but it adds another requirement.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">NDATE</span><span class="p">,</span> <span class="n">SUBJECT</span>
<span class="k">FROM</span>     <span class="n">NEWS</span>
<span class="k">WHERE</span>    <span class="n">NDATE</span> <span class="k">BETWEEN</span> <span class="s1">&#39;begin of 1993-07-30&#39;</span>
                   <span class="k">AND</span> <span class="s1">&#39;end of 1993-07-30&#39;</span>
<span class="k">AND</span>      <span class="n">BODY</span> <span class="k">LIKE</span> <span class="s1">&#39;bill gates&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>Now we can retrieve articles from July 30, 1993, but only a list of
those articles whose text body mentions Bill Gates. A listing of Date
and Subject of the article will be displayed, as dictated in <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>.
Now we know which articles are available and can pick any we would want
to read in full.</p>
<p>This example uses a text query to find sentences in the body of the
information with reference to “Bill Gates”. Use of this type of query in
the <code class="docutils literal notranslate"><span class="pre">LIKE</span></code> clause is explained in the <a class="reference internal" href="sql3.html#intelligent-text-search-queries"><span class="std std-ref">Intelligent Text Search Queries</span></a> section.</p>
<p>In this example, the following rows might be retrieved:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>NDATE                SUBJECT
1993-30-07 04:46:04  High-Technology R&amp;D Has Lost Its Cost-Effect...
1993-30-07 13:10:08  Heavy R&amp;D Spending No Longer the Magic Route...
</pre></div>
</div>
<p>Date fields can use any of the comparison operators as shown in
<a class="reference internal" href="sql1.html#compop"><span class="std std-ref">the comparison operators table</span></a> to manipulate information.
We could broaden the date range of this search could be broadened by
increasing the <code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code> range, or as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">NDATE</span><span class="p">,</span> <span class="n">SUBJECT</span>
<span class="k">FROM</span>     <span class="n">NEWS</span>
<span class="k">WHERE</span>    <span class="n">BODY</span> <span class="k">LIKE</span> <span class="s1">&#39;bill gates&#39;</span>
<span class="k">AND</span>      <span class="n">NDATE</span> <span class="o">&gt;</span> <span class="s1">&#39;begin of 1993-07-30&#39;</span>
<span class="k">AND</span>      <span class="n">NDATE</span> <span class="o">&lt;</span> <span class="s1">&#39;end of 1993-08-01&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>Note that the actual value of the date is still a number of seconds.
Therefore, greater than (<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>) translates to “a greater number of
seconds than the stated value”, and therefore means “newer than”, while
lesser than (<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>) translates to “a fewer number of seconds than the
stated value”, and therefore means “older than”.</p>
<p>This would increase the output list to include dates in the specified
range; that is, between July 30th and August 1st 1993.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>NDATE       SUBJECT
1993-07-30 04:46:04  High-Technology R&amp;D Has Lost Its Cost-Effect...
1993-07-30 13:10:08  Heavy R&amp;D Spending No Longer the Magic Route...
1993-07-31 07:56:44  Microsoft-Novell battle out in the open
1993-07-31 16:40:28  Microsoft to Undergo Justice Department Scrutiny
1993-08-01 09:50:24  Justice Dept. Reportedly to Study Complaints ...
</pre></div>
</div>
<p>Date strings have some additional operators, “today” and “now”. When
used following DATE they are converted to today’s date and time in
seconds for both “today” and “now”. A time period of seconds, minutes,
hours, days, weeks, or months, can also be specified. A leading plus
(<code class="docutils literal notranslate"><span class="pre">+</span></code>) or minus (<code class="docutils literal notranslate"><span class="pre">-</span></code>) may also be specified to indicate past or
future. Using our example from the <code class="docutils literal notranslate"><span class="pre">NEWS</span></code> table, the form of the
command would be:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">NDATE</span><span class="p">,</span> <span class="n">SUBJECT</span>
<span class="k">FROM</span>     <span class="n">NEWS</span>
<span class="k">WHERE</span>    <span class="n">NDATE</span> <span class="o">&gt;</span> <span class="s1">&#39;-7 days&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>This query requests all articles less than seven days old and would
produce a list of their subjects and date.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">NDATE</span><span class="p">,</span> <span class="n">SUBJECT</span>
<span class="k">FROM</span>     <span class="n">NEWS</span>
<span class="k">WHERE</span>    <span class="n">NDATE</span> <span class="o">&lt;</span> <span class="s1">&#39;-1 minute&#39;</span>
  <span class="k">AND</span>    <span class="n">NDATE</span> <span class="o">&gt;</span> <span class="s1">&#39;-1 hour&#39;</span> <span class="p">;</span>
</pre></div>
</div>
<p>This query would produce a list of articles which came in over the last
hour. The date must be older than 1 minute ago, but newer than 1 hour
ago.</p>
</div>
<div class="section" id="summarizing-values-group-by-clause-and-aggregate-functions">
<span id="groupby"></span><h2>Summarizing Values: GROUP BY Clause and Aggregate Functions<a class="headerlink" href="#summarizing-values-group-by-clause-and-aggregate-functions" title="Permalink to this headline">¶</a></h2>
<p>So far, the examples presented have shown how to retrieve and manipulate
values from individual rows in a table. This section
illustrates how summary information can be obtained from groups of rows
in a table.</p>
<p>Often it is useful to group data by some characteristic of the
group, such as department or division, or benefit level, so that summary
statistics about the group (totals, averages, etc.) can be calculated.
For example, to calculate average departmental salaries, the user could
group the salaries of all employees by department. In Texis, the
<code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause is used to combine the rows of a table into groups that
have matching values in one or more columns. The form of this clause is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>GROUP BY   column-name1 [,column-name2] ...
</pre></div>
</div>
<p>and it fits into the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> expression in the following manner.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="p">...</span>
<span class="k">FROM</span>       <span class="k">table</span><span class="o">-</span><span class="n">name</span>
<span class="p">[</span><span class="k">WHERE</span>     <span class="k">search</span><span class="o">-</span><span class="n">condition</span><span class="p">]</span>
<span class="p">[</span><span class="k">GROUP</span> <span class="k">BY</span>  <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="p">...</span> <span class="p">]</span>
<span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span>  <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[</span><span class="k">DESC</span><span class="p">]</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="p">[</span><span class="k">DESC</span><span class="p">]</span> <span class="p">]</span> <span class="p">...</span> <span class="p">;</span>
</pre></div>
</div>
<p>The column(s) listed in the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause are used to form groups. The
grouping is based on rows with the same value in the specified column or
columns being placed in the same group. It is important to note that
grouping is conceptual; the table is not physically rearranged.</p>
<p>As an extension Texis also allows the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause to consist of
expressions instead of just column names. This should be used with
caution, and the same expression should be used in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> as in
the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause. This is especially true if the expression will fold
multiple values together, such as dividing a number by 1000 to group
quantities together if they are in the same 1000. If you select <code class="docutils literal notranslate"><span class="pre">SALARY</span></code>,
and <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span> <span class="pre">SALARY/1000</span></code> you will see one sample salary from the
matching group.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause is normally used along with five built-in,
“aggregate” functions. These functions perform special operations on an
entire table or on a set, or group, of rows rather than on each row and
then return one row of values for each group.</p>
<p>The table below lists the aggregate functions available with Texis.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 52%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Function Name</p></th>
<th class="head"><p>Meaning</p></th>
<th class="head"><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SUM(column name)</p></td>
<td><p>Total of the values in a numeric column</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">SUM(SALARY)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>AVG(column name)</p></td>
<td><p>Average of the values in a column</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">AVG(SALARY)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>MAX(column name)</p></td>
<td><p>Largest value in a column</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MAX(SALARY)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>MIN(column name)</p></td>
<td><p>Smallest value in a column</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MIN(SALARY)</span></code></p></td>
</tr>
<tr class="row-even"><td><p>COUNT(*)</p></td>
<td><p>Count of the number of rows selected</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">COUNT(*)</span></code></p></td>
</tr>
</tbody>
</table>
<p>Aggregate functions are used in place of column names in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>
statement. The form of the function is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Function_name ([DISTINCT] argument)
</pre></div>
</div>
<p>In all situations the argument represents the column name to which the
function applies. For example, if the sum of all salaries is needed,
then the function <code class="docutils literal notranslate"><span class="pre">SUM</span></code> is used and the argument is the column <code class="docutils literal notranslate"><span class="pre">SALARY</span></code>.
When <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> is used, an <code class="docutils literal notranslate"><span class="pre">*</span></code> (asterisk) can be placed within the parentheses
instead of a column name to count all the rows without regard to field.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code> keyword is used then only the unique values are
processed. This is most useful with <code class="docutils literal notranslate"><span class="pre">COUNT</span></code> to find the number of unique
values. If you use <code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code> then you must supply a column name. <code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code>
will work with the other aggregate functions, although there is
typically very little need for them.</p>
<p><strong>Example:</strong> What is the average salary paid in each department?</p>
<p>Enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="n">DEPT</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span>
<span class="k">GROUP</span> <span class="k">BY</span>   <span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AVG</span></code> is the aggregate function name.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(SALARY)</span></code> is the column on which the average is computed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DEPT</span></code> is the column by which the rows will be grouped.</p></li>
</ul>
<p>The above statement will produce the following results:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEPT      AVG(SALARY)

MKT       33500
MGT       45000
LIB       22000
RND       27500
FIN       42000
</pre></div>
</div>
<p>In this query, all rows in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table that have the same
department codes are grouped together. The aggregate function <code class="docutils literal notranslate"><span class="pre">AVG</span></code> is
calculated for the salary column in each group. The department code and
the average departmental salary are displayed for each department.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause that contains an aggregate function cannot contain
any column name that does not apply to a group; for example:</p>
<p>The statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="n">ENAME</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span>
<span class="k">GROUP</span> <span class="k">BY</span>   <span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p>results in the message</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Error at Line 1: Not a GROUP BY Expression
</pre></div>
</div>
<p>It is not permissible to include column names in a <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause
that are not referenced in the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause. The only column names
that can be displayed, along with aggregate functions, must be listed in
the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause. Since <code class="docutils literal notranslate"><span class="pre">ENAME</span></code> is not included in the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code>
clause, an error message results.</p>
<p><strong>Example:</strong> The following statement can be used to determine the average
salary paid to the Marketing Department employees:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">),</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>      <span class="n">DEPT</span> <span class="o">=</span> <span class="s1">&#39;MKT&#39;</span>
</pre></div>
</div>
<p>Results in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>COUNT(*)   AVG(SALARY)

2          33500
</pre></div>
</div>
<p>In this example, the aggregate function <code class="docutils literal notranslate"><span class="pre">AVG</span></code> is used in a <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>
statement that has a <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause. Texis selects the rows that
represent Marketing Department employees and then applies the aggregate
function to these rows.</p>
<p>The rows of a table can be combined into groups based on values in more
than one column. For example, it is possible to compute total salary by
department and then, within a department, the subtotals by benefits
classification.</p>
<p><strong>Example:</strong> What is the total salary paid by benefits classification in
each department?</p>
<p>Enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="n">DEPT</span><span class="p">,</span> <span class="n">BENEFITS</span><span class="p">,</span> <span class="k">SUM</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span>
<span class="k">GROUP</span> <span class="k">BY</span>   <span class="n">DEPT</span><span class="p">,</span> <span class="n">BENEFITS</span> <span class="p">;</span>
</pre></div>
</div>
<p>In this example, results are grouped by department, and within department,
by benefits classification.</p>
<p>The following results are returned:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEPT      BENEFITS    SUM(SALARY)

FIN       FULL        42000
LIB       PART        22000
MGT       FULL        45000
MKT       FULL        67000
RND       FULL        30000
RND       PART        25000
</pre></div>
</div>
<p>In this query, the rows are grouped by department and, within each
department, employees with the same benefits are grouped so that totals
can be computed. Notice that the columns <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> and <code class="docutils literal notranslate"><span class="pre">BENEFITS</span></code> can appear in
the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> statement since both columns appear in the GROUP BY
clause.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause is omitted when an aggregate function is used,
then the entire table is considered as one group, and the group function
displays a single value for the entire table.</p>
<p><strong>Example:</strong> What is the total salary paid to all employees?</p>
<p>The statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="k">SUM</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span> <span class="p">;</span>
</pre></div>
</div>
<p>results in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SUM(SALARY)

231000
</pre></div>
</div>
</div>
<div class="section" id="groups-with-conditions-having-clause">
<h2>Groups With Conditions: HAVING Clause<a class="headerlink" href="#groups-with-conditions-having-clause" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> clause allows the specification of a condition that applies
to groups rather than to individual rows.  For example, formulating a
statement that performs a grouping of departments where the average
departmental salary is above $30,000 can be achieved with <code class="docutils literal notranslate"><span class="pre">HAVING</span></code>.  This
clause specifies which groups should be selected and is used in combination
with the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause.  The form of this clause is as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="k">GROUP</span> <span class="k">BY</span>  <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="p">...</span>
<span class="p">[</span><span class="k">HAVING</span>    <span class="k">search</span><span class="o">-</span><span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">search-condition</span></code>s in the HAVING clause are applied after groups are
formed.  The search condition of the HAVING clause examines the grouped rows
and produces a row for each group where the search condition in the
<code class="docutils literal notranslate"><span class="pre">HAVING</span></code> clause is true.  The clause is similar to the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause,
except the <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> clause applies to groups.</p>
<p><strong>Example:</strong> Which departments have an average salary above $30,000?
Order the results by average salary, with highest average salary
appearing first.</p>
<p>The statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>     <span class="n">DEPT</span><span class="p">,</span> <span class="k">AVG</span><span class="p">(</span><span class="n">SALARY</span><span class="p">)</span> <span class="k">AS</span> <span class="n">AVG_SALARY</span>
<span class="k">FROM</span>       <span class="n">EMPLOYEE</span>
<span class="k">GROUP</span> <span class="k">BY</span>   <span class="n">DEPT</span>
<span class="k">HAVING</span>     <span class="n">AVG_SALARY</span> <span class="o">&gt;</span> <span class="mi">30000</span>
<span class="k">ORDER</span> <span class="k">BY</span>   <span class="n">AVG_SALARY</span> <span class="k">DESC</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p>When <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> is used, it always follows a <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause.</p></li>
<li><p>When referring to aggregate values in the <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> and <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clauses
of a <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code>, an alternative name must be assigned to the field
and that name must be used in the <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> and <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clauses, as
<code class="docutils literal notranslate"><span class="pre">AVG_SALARY</span></code> is used in the above example.</p></li>
</ul>
<p>The results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEPT      AVG_SALARY

MGT       45000
FIN       42000
MKT       33500
</pre></div>
</div>
<p>In this query, the average salary for all departments is computed, but
only the names of those departments having an average salary above
$30,000 are displayed. Notice that Research and Development’s average of
$27,500 is not displayed, nor is the Library’s average of $22,000.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause does not sort the results, thus the need for the
<code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clause. Finally, note that the <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clause must be placed
after the <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> and <code class="docutils literal notranslate"><span class="pre">HAVING</span></code> clauses.</p>
</div>
</div>
<div class="section" id="advanced-queries">
<h1>Advanced Queries<a class="headerlink" href="#advanced-queries" title="Permalink to this headline">¶</a></h1>
<p>This section is divided into three parts. The first one focuses on
using the join operation to retrieve data from multiple tables. The
second section covers nesting of queries, also known as subqueries. The
final section introduces several advanced query techniques, including
self-joins, correlated subqueries, subqueries using the <code class="docutils literal notranslate"><span class="pre">EXISTS</span></code> operator.</p>
<div class="section" id="retrieving-data-from-multiple-tables">
<h2>Retrieving Data From Multiple Tables<a class="headerlink" href="#retrieving-data-from-multiple-tables" title="Permalink to this headline">¶</a></h2>
<p>All the queries looked at so far have been answered by accessing data
from one table. Sometimes, however, answers to a query may require data
from two or more tables.</p>
<p>For example, for the Corporate Librarian to display a list of
contributing authors with their long form department name requires data
from the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table (author) and data from the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>
table (department name). Obtaining the data you need requires the
ability to combine two or more tables. This process is commonly referred
to as “<em>joining the tables</em>”.</p>
<p>Two or more tables can be combined to form a single virtual table by using
the <em>join operation</em>.  The join operation is based on the premise that there
is a logical association between two tables based on a common attribute that
links the tables.  Therefore, there must be a common column in each table
for a join operation to be executed.  For example, both the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table
and the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table have the department identification code in
common.  Thus, they can be joined.</p>
<p>Joining two tables in Texis is accomplished by using a <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>
statement. The general form of the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> statement when a join
operation is involved is:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="p">...</span>
<span class="k">FROM</span>     <span class="k">table</span><span class="o">-</span><span class="n">name1</span><span class="p">,</span> <span class="k">table</span><span class="o">-</span><span class="n">name2</span>
<span class="k">WHERE</span>    <span class="k">table</span><span class="o">-</span><span class="n">name1</span><span class="p">.</span><span class="k">column</span><span class="o">-</span><span class="n">name</span> <span class="o">=</span> <span class="k">table</span><span class="o">-</span><span class="n">name2</span><span class="p">.</span><span class="k">column</span><span class="o">-</span><span class="n">name</span> <span class="p">;</span>
</pre></div>
</div>
<p>The combination of table name with column name as stated in the
<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause describes the Join condition.</p>
<div class="section" id="command-discussion">
<h3>Command Discussion<a class="headerlink" href="#command-discussion" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p>A join operation pulls data from two or more tables listed in the
<code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause. These tables represent the source of the data to be
joined.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause specifies the relationship between the tables to
be joined. This relationship represents the <em>join condition</em>.
Typically, the join condition expresses a relationship between rows
from each table that match on a common attribute.</p></li>
<li><p>When the tables to be joined have the same column name, the column
name is prefixed with a table name in order for Texis to know from
which table the column comes. Texis uses the notation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span><span class="o">-</span><span class="n">name</span><span class="o">.</span><span class="n">column</span><span class="o">-</span><span class="n">name</span>
</pre></div>
</div>
<p>The table name in front of the column name is referred to as a
<em>qualifier</em>.</p>
</li>
<li><p>The common attributes in the join condition need not have the same
column name, but they should represent the same kind of information.
For example, where the attribute representing names of people
submitting resumes was named <code class="docutils literal notranslate"><span class="pre">RNAME</span></code> in table 1, and the attribute
for names of employees was named <code class="docutils literal notranslate"><span class="pre">ENAME</span></code> in table 2, you could
still join the tables on the common character field by specifying:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WHERE</span> <span class="n">table</span><span class="o">-</span><span class="n">name1</span><span class="o">.</span><span class="n">RNAME</span> <span class="o">=</span> <span class="n">table</span><span class="o">-</span><span class="n">name2</span><span class="o">.</span><span class="n">ENAME</span>
</pre></div>
</div>
<p>While the above is true, it is still a good rule of thumb in database
design to give the same name to all columns referring to data of the
same type and meaning. Columns which are designed to be a key, and
intended as the basis for joining tables would normally be given the
same name.</p>
</li>
<li><p>If a row from one of the tables never satisfies the join condition,
that row will not appear in the joined table.</p></li>
<li><p>The tables are joined together, and then Texis extracts the data, or
columns, listed in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause.</p></li>
<li><p>Although tables can be combined if you omit the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause,
this would result in a table of all possible combinations of rows
from the tables in the <code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause. This output is usually not
intended, nor meaningful, and can waste much computer processing
time. Therefore, be careful in forming queries that involve multiple
tables.</p></li>
</ol>
<p><strong>Example:</strong> The corporate librarian wants to distribute a list of
authors who have contributed reports to the corporate library, along
with the name of that author’s department. To fulfill this request, data
from both the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table (author) and the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table
(department name) are needed.</p>
<p>You would enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">AUTHOR</span><span class="p">,</span> <span class="n">DNAME</span>
<span class="k">FROM</span>     <span class="n">REPORT</span><span class="p">,</span> <span class="n">DEPARTMENT</span>
<span class="k">WHERE</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">REPORT</span></code> and <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> indicate the tables to be joined.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause statement defines the condition for the join.</p></li>
<li><p>The notation “<code class="docutils literal notranslate"><span class="pre">REPORT.</span></code>” in “<code class="docutils literal notranslate"><span class="pre">REPORT.DEPT</span></code>”, and
“<code class="docutils literal notranslate"><span class="pre">DEPARTMENT.</span></code>” in “<code class="docutils literal notranslate"><span class="pre">DEPARTMENT.DEPT</span></code>” are the qualifiers which
indicate from which table to find the column.</p></li>
</ul>
<p>This statement will result in the following joined table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>AUTHOR                   DNAME
Jackson, Herbert         Research and Development
Sanchez, Carla           Product Marketing and Sales
Price, Stella            Finance and Accounting
Smith, Roberta           Research and Development
Aster, John A.           Product Marketing and Sales
Jackson, Herbert         Research and Development
Barrington, Kyle         Management and Administration
</pre></div>
</div>
<p>In this query, we are joining data from the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> and the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>
tables. The common attribute in these two tables is the department code.
The conditional expression:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>REPORT.DEPT = DEPARTMENT.DEPT
</pre></div>
</div>
<p>is used to describe how the rows in the two tables are to be matched.
Each row of the joined table is the result of combining a row from the
<code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table and a row from the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table for each
comparison with matching codes.</p>
<p>To further illustrate how the join works, look at the rows in the
<code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table below where <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> is <code class="docutils literal notranslate"><span class="pre">MKT</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  TITLE                    AUTHOR           DEPT FILENAME
  Disappearing Ink         Jackson, Herbert RND  /data/rnd/ink.txt
&gt; INK PROMOTIONAL CAMPAIGN SANCHEZ, CARLA   MKT  /data/MKT/PROMO.RPT
  Budget for 4Q 92         Price, Stella    FIN  /data/ad/4q.rpt
  Round Widgets            Smith, Roberta   RND  /data/rnd/widge.txt
&gt; PAPERCLIPS               ASTER, JOHN A.   MKT  /data/MKT/CLIP.RPT
  Color Panorama           Jackson, Herbert RND  /data/rnd/color.txt
  Meeting Schedule         Barrington, Kyle MGT  /data/mgt/when.rpt
</pre></div>
</div>
<p>Now look at the rows in the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table below where <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> is
<code class="docutils literal notranslate"><span class="pre">MKT</span></code>. These are matching rows since the department code (<code class="docutils literal notranslate"><span class="pre">MKT</span></code>) is the
same.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>  DEPT DNAME                               DHEAD      DIV  BUDGET
  MGT  Management and Administration       Barrington CORP 22000
  FIN  Finance and Accounting              Price      CORP 26000
  LEG  Corporate Legal Support             Thomas     CORP 28000
  SUP  Supplies and Procurement            Sweet      CORP 10500
  REC  Recruitment and Personnel           Harris     CORP 15000
  RND  Research and Development            Jones      PROD 27500
  MFG  Manufacturing                       Washington PROD 32000
  CSS  Customer Support and Service        Ferrer     PROD 11000
&gt; MKT  PRODUCT MARKETING AND SALES         BROWN      PROD 25000
  ISM  Information Systems Management      Dedrich    INFO 22500
  LIB  Corporate Library                   Krinski    INFO 18500
  SPI  Strategic Planning and Intelligence Peters     INFO 28500
</pre></div>
</div>
<p>The matching rows can be conceptualized as combining a row from the
<code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table with a matching row from the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table.
Below is a sample of rows from both tables, matched on the department
code <code class="docutils literal notranslate"><span class="pre">MKT</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEPT DNAME     DHEAD DIV  BUDGET TITLE      AUTHOR  FILENAME
MKT  Marketing Brown PROD 25000  Ink        Sanchez /data/mkt/promo.rpt
MKT  Marketing Brown PROD 25000  Paperclips Aster   /data/mkt/clip.rpt
</pre></div>
</div>
<p>This operation is carried out for all matching rows; i.e., each row in
the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table is combined, or matched, with a row having the same
department code in the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DEPT DNAME      DHEAD DIV  BUDGET TITLE      AUTHOR  FILENAME
RND  Research   Jones PROD 27500  Ink        Jackson /data/rnd/ink.txt
MKT  Marketing  Brown PROD 25000  Ink Promo  Sanchez /data/mkt/promo.rpt
FIN  Finance    Price CORP 26000  Budget     Price   /data/ad/4q.rpt
RND  Research   Jones PROD 27500  Widgets    Smith   /data/rnd/widge.txt
MKT  Marketing  Brown PROD 25000  Paperclips Aster   /data/mkt/clip.rpt
RND  Research   Jones PROD 27500  Panorama   Jackson /data/rnd/color.txt
MGT  Management Barri CORP 22000  Schedule   Barring /data/mgt/when.rpt
</pre></div>
</div>
<p>The columns requested in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> statement determine the final
output for the joined table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>AUTHOR                   DNAME
Jackson, Herbert         Research and Development
Sanchez, Carla           Product Marketing and Sales
Price, Stella            Finance and Accounting
Smith, Roberta           Research and Development
Aster, John A.           Product Marketing and Sales
Jackson, Herbert         Research and Development
Barrington, Kyle         Management and Administration
</pre></div>
</div>
<p>Observe that the joined table does not include any data on several
departments from the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table, where that department did not
produce any contributing authors as listed in the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table. The
joined table includes only rows where a match has occurred between rows
in both tables. If a row in either table does not match any row in the
other table, the row is not included in the joined table.</p>
<p>In addition, notice that the <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> column is not included in the final
joined table. Only two columns are included in the joined table since
just two columns are listed in the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause, and <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> is not
one of them.</p>
<p>The next example illustrates that conditions other than the join
condition can be used in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause. It also shows that even
though the results come from a single table, the solution may require
that data from two or more tables be joined in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause.</p>
<p><strong>Example:</strong> Assume that you cannot remember the department code for
Research and Development, but you want to know the titles of all reports
submitted from that department.</p>
<p>Enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">TITLE</span>
<span class="k">FROM</span>     <span class="n">DEPARTMENT</span><span class="p">,</span> <span class="n">REPORT</span>
<span class="k">WHERE</span>    <span class="n">DNAME</span> <span class="o">=</span> <span class="s1">&#39;RESEARCH AND DEVELOPMENT&#39;</span>
  <span class="k">AND</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p>The tables to be joined are listed after <code class="docutils literal notranslate"><span class="pre">FROM</span></code>.</p></li>
<li><p>The condition for the join operation is specified after AND (as part
of <code class="docutils literal notranslate"><span class="pre">WHERE</span></code>).</p></li>
</ul>
<p>The results follow:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>TITLE
Innovations in Disappearing Ink
Improvements in Round Widgets
Ink Color Panorama
</pre></div>
</div>
<p>Since you don’t know Research and Development’s department code, you use
the department name found in the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table in order to find
the row that stores Research and Development’s code, which is <code class="docutils literal notranslate"><span class="pre">RND</span></code>.
Conceptually, visualize the join operation to occur as follows:</p>
<ol class="arabic simple">
<li><p>The conditional expression DNAME = ’RESEARCH AND DEVELOPMENT’
references one row from the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table; i.e., the <code class="docutils literal notranslate"><span class="pre">RND</span></code>
row.</p></li>
<li><p>Now that the RND code is known, this row in the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table
is joined with the rows in the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table that have <code class="docutils literal notranslate"><span class="pre">DEPT</span> <span class="pre">=</span> <span class="pre">RND</span></code>.
The joined table represents the titles of the reports submitted by
authors from the Research and Development department.</p></li>
</ol>
<p>As the next example illustrates, more than two tables can be joined
together.</p>
<p><strong>Example:</strong> Provide a list of salaries paid to those people in the
Product Division who contributed reports to the Corporate Library. The
report should include the author’s name, department name, and annual
salary.</p>
<p>You would enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">AUTHOR</span><span class="p">,</span> <span class="n">DNAME</span><span class="p">,</span> <span class="n">SALARY</span>
<span class="k">FROM</span>     <span class="n">REPORT</span><span class="p">,</span> <span class="n">DEPARTMENT</span><span class="p">,</span> <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DIV</span> <span class="o">=</span> <span class="s1">&#39;PROD&#39;</span>
  <span class="k">AND</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DEPT</span>
  <span class="k">AND</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">EMPLOYEE</span><span class="p">.</span><span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p>The order of the joins in the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause is not important.</p></li>
<li><p>The three tables to be joined are listed after <code class="docutils literal notranslate"><span class="pre">FROM</span></code>.</p></li>
<li><p>The first AND statement (in <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause) is the condition for
joining the REPORT and <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> tables.</p></li>
<li><p>The second AND statement (in <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause) is the condition for
joining the REPORT and <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> tables.</p></li>
<li><p>While department code happens to be a column which all three tables
have in common, it would be possible to join two tables with a common
column, and the other two tables with a different common column, such
as <code class="docutils literal notranslate"><span class="pre">ENAME</span></code> in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table and AUTHOR in the REPORT
table. (The latter would not be as efficient, nor as reliable, so
department name was chosen instead.)</p></li>
</ul>
<p>The results would be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>AUTHOR               DNAME                           SALARY
Jackson, Herbert     Research and Development        30000
Sanchez, Carla       Product Marketing and Sales     35000
Smith, Roberta       Research and Development        25000
Aster, John A.       Product Marketing and Sales     32000
</pre></div>
</div>
<p>In this example, data from three tables (<code class="docutils literal notranslate"><span class="pre">REPORT</span></code>, <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>,
<code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>) are joined together.</p>
<p>Conceptually, the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code> table references the rows that contain
<code class="docutils literal notranslate"><span class="pre">PROD</span></code>; this gives us the departments in the Product Division.  The
departments in the Product Division (<code class="docutils literal notranslate"><span class="pre">RND</span></code>, <code class="docutils literal notranslate"><span class="pre">MFG</span></code>, <code class="docutils literal notranslate"><span class="pre">CSS</span></code>, <code class="docutils literal notranslate"><span class="pre">MKT</span></code>) are
matched against the departments in the <code class="docutils literal notranslate"><span class="pre">DEPT</span></code> column of the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code>
table.  The tables are joined for the Research and Development (<code class="docutils literal notranslate"><span class="pre">RND</span></code>) and
Product Marketing and Sales (<code class="docutils literal notranslate"><span class="pre">MKT</span></code>) departments.  This yields an
intermediate table containing all the columns from both the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>
and <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> tables for <code class="docutils literal notranslate"><span class="pre">RND</span></code> and <code class="docutils literal notranslate"><span class="pre">MKT</span></code>.</p>
<p>This intermediate table is joined with the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, based on
the second join condition <code class="docutils literal notranslate"><span class="pre">REPORT.DEPT</span> <span class="pre">=</span> <span class="pre">EMPLOYEE.DEPT</span></code> to form a
combination of columns from all 3 tables, for the matching rows.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause indicates which columns in the
intermediate joined table that you want displayed. Thus the author,
department name, and annual salary are shown as in the above example.</p>
<p>As a final point, the order in which you place the conditions in the
<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause does not affect the way Texis accesses the data. Texis
contains an “<em>optimizer</em>” in its underlying software, which chooses the
best access path to the data based on factors such as index
availability, size of tables involved, number of unique values in an
indexed column, and other statistical information. Thus, the results
would not be affected by writing the same query in the following order:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">AUTHOR</span><span class="p">,</span> <span class="n">DNAME</span><span class="p">,</span> <span class="n">SALARY</span>
<span class="k">FROM</span>     <span class="n">REPORT</span><span class="p">,</span> <span class="n">DEPARTMENT</span><span class="p">,</span> <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">EMPLOYEE</span><span class="p">.</span><span class="n">DEPT</span>
  <span class="k">AND</span>    <span class="n">REPORT</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DEPT</span>
  <span class="k">AND</span>    <span class="n">DEPARTMENT</span><span class="p">.</span><span class="n">DIV</span> <span class="o">=</span> <span class="s1">&#39;PROD&#39;</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="nesting-queries">
<h2>Nesting Queries<a class="headerlink" href="#nesting-queries" title="Permalink to this headline">¶</a></h2>
<p>At times you may wish to retrieve rows in one table based on conditions
in a related table. For example, suppose Personnel needed to call in any
employees in the Information Division receiving only partial benefits,
to discuss options for upgrading to the full benefit program. To answer
this query, you have to retrieve the names of all departments in the
Information Division, found in the DEPARTMENT table, and then the
employees with partial benefits in the Information Division departments,
found in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table.</p>
<p>In other situations, you may want to formulate a query from one table
that required you to make two passes through the table in order to
obtain the desired results. For example, you may want to retrieve a list
of staff members earning a salary higher than Jackson, but you don’t
know Jackson’s salary. To answer this query, you first find Jackson’s
salary; then you compare the salary of each staff member to his.</p>
<p>One approach is to develop a <em>subquery</em>, which involves embedding a
query (<code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">\verb</span></code>FROM“-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block) within the
<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause of another query. This is sometimes referred to as a
“<em>nested query</em>”.</p>
<p>The format of a nested query is:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="k">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="k">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span>
<span class="k">FROM</span>     <span class="k">table</span><span class="o">-</span><span class="n">name</span>
<span class="k">WHERE</span>    <span class="k">column</span><span class="o">-</span><span class="n">name</span> <span class="k">IN</span>
  <span class="p">(</span><span class="k">SELECT</span>   <span class="k">column</span><span class="o">-</span><span class="n">name</span>
   <span class="k">FROM</span>     <span class="k">table</span><span class="o">-</span><span class="n">name</span>
   <span class="k">WHERE</span>    <span class="k">search</span><span class="o">-</span><span class="n">condition</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p>The first <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block is the outer
query.</p></li>
<li><p>The second <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block in
parentheses is the subquery.</p></li>
<li><p>The IN operator is normally used if the inner query returns many rows
and one column.</p></li>
</ul>
<div class="section" id="id2">
<h3>Command Discussion<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Here are some points concerning the use of nested queries:</p>
<ol class="arabic">
<li><p>The above statement contains two <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code>
blocks. The portion in parentheses is called the subquery. The
subquery is evaluated first; then the outer query is evaluated based
on the result of the subquery. In effect, the nested query can be
looked at as being equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span>   <span class="n">column</span><span class="o">-</span><span class="n">name1</span> <span class="p">[,</span><span class="n">column</span><span class="o">-</span><span class="n">name2</span><span class="p">]</span> <span class="o">...</span>
<span class="n">FROM</span>     <span class="n">table</span><span class="o">-</span><span class="n">name</span>
<span class="n">WHERE</span>    <span class="n">column</span><span class="o">-</span><span class="n">name</span> <span class="n">IN</span> <span class="p">(</span><span class="nb">set</span> <span class="n">of</span> <span class="n">values</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">subquery</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>where the set of values is determined from the inner
<code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block.</p>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">IN</span></code> operator is used to link the outer query to the subquery when
the subquery returns a set of values (one or more). Other comparison
operators, such as <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, etc., can be used to link an
outer query to a subquery when the subquery returns a single value.</p></li>
<li><p>The subquery must have only a single column or expression in the
<code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause, so that the resulting set of values can be passed
back to the next outer query for evaluation.</p></li>
<li><p>You are not limited to one subquery. Though it isn’t advised, there
could be as many as 16 levels of subqueries, with no fixed limitation
except limits of memory and disk-space on the machine in use. Any of
the operators (<code class="docutils literal notranslate"><span class="pre">IN</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, etc.) can be used to link
the subquery to the next higher level.</p></li>
</ol>
<p><strong>Example:</strong> List the names of all personnel in the Information Division
by entering this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">ENAME</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">DEPT</span> <span class="k">IN</span>
  <span class="p">(</span><span class="k">SELECT</span>   <span class="n">DEPT</span>
   <span class="k">FROM</span>     <span class="n">DEPARTMENT</span>
   <span class="k">WHERE</span>    <span class="n">DIV</span> <span class="o">=</span> <span class="s1">&#39;INFO&#39;</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>Parentheses are placed around the subquery, as shown below the outer
<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause.</p>
<p>The results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME
Chapman, Margaret
Dedrich, Franz
Krinski, Wanda
Peters, Robert
</pre></div>
</div>
<p>To understand how this expression retrieves its results, work from the
bottom up in evaluating the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> statement. In other words, the
subquery is evaluated first. This results in a set of values that can be
used as the basis for the outer query. The innermost <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> block
retrieves the following set of department codes, as departments in the
Information (<code class="docutils literal notranslate"><span class="pre">INFO</span></code>) Division: <code class="docutils literal notranslate"><span class="pre">ISM</span></code>, <code class="docutils literal notranslate"><span class="pre">LIB</span></code>, <code class="docutils literal notranslate"><span class="pre">SPI</span></code>.</p>
<p>In the outermost <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> block, the <code class="docutils literal notranslate"><span class="pre">IN</span></code> operator tests whether any
department code in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table is contained in the set of
department codes values retrieved from the inner <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> block; i.e.,
<code class="docutils literal notranslate"><span class="pre">ISM</span></code>, <code class="docutils literal notranslate"><span class="pre">LIB</span></code>, or <code class="docutils literal notranslate"><span class="pre">SPI</span></code>.</p>
<p>In effect, the outer <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> block is equivalent to:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">ENAME</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">DEPT</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">&#39;ISM&#39;</span><span class="p">,</span> <span class="s1">&#39;LIB&#39;</span><span class="p">,</span> <span class="s1">&#39;SPI&#39;</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>where the values in parentheses are values from the subquery.</p>
<p>Thus, the employee names Chapman, Dedrich, Krinski and Peters are
retrieved.</p>
<p>Subqueries can be nested several levels deep within a query, as the next
example illustrates.</p>
<p><strong>Example:</strong> Acme Industrial’s ink sales are up, and management wishes
to reward everyone in the division(s) most responsible. List the names
of all employees in any division whose personnel have contributed
reports on ink to the corporate library, along with their department and
benefit level.</p>
<p>Use this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">ENAME</span><span class="p">,</span> <span class="n">DEPT</span><span class="p">,</span> <span class="n">BENEFITS</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">DEPT</span> <span class="k">IN</span>
  <span class="p">(</span><span class="k">SELECT</span>   <span class="n">DEPT</span>
   <span class="k">FROM</span>     <span class="n">DEPARTMENT</span>
   <span class="k">WHERE</span>    <span class="n">DIV</span> <span class="k">IN</span>
     <span class="p">(</span><span class="k">SELECT</span>   <span class="n">DIV</span>
      <span class="k">FROM</span>     <span class="n">DEPARTMENT</span>
      <span class="k">WHERE</span>    <span class="n">DEPT</span> <span class="k">IN</span>
        <span class="p">(</span><span class="k">SELECT</span>   <span class="n">DEPT</span>
         <span class="k">FROM</span>     <span class="n">REPORT</span>
         <span class="k">WHERE</span>    <span class="n">TITLE</span>  <span class="k">LIKE</span> <span class="s1">&#39;ink&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IN</span></code> is used for each subquery since in each case it is possible to
retrieve several values. You could use ‘<code class="docutils literal notranslate"><span class="pre">=</span></code>’ instead where you knew
only one value would be retrieved; e.g. where you wanted only the
division with the greatest number of reports rather than all divisions
contributing reports.</p>
<p>Results of the above nested query are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME                DEPT   BENEFITS
Aster, John A.       MKT    FULL
Jackson, Herbert     RND    FULL
Sanchez, Carla       MKT    FULL
Smith, Roberta       MKT    PART
Jones, David         RND    FULL
Washington, G.       MFG    FULL
Ferrer, Miguel       CSS    FULL
Brown, Penelope      MKT    FULL
</pre></div>
</div>
<p>Again, remember that a nested query is evaluated from the bottom up;
i.e., from the innermost query to the outermost query. First, a text
search is done (<code class="docutils literal notranslate"><span class="pre">TITLE</span> <span class="pre">LIKE</span> <span class="pre">'ink'</span></code>) of report titles from the <code class="docutils literal notranslate"><span class="pre">REPORT</span></code>
table. Two such titles are located: “Disappearing Ink” by Herbert
Jackson from Research and Development (<code class="docutils literal notranslate"><span class="pre">RND</span></code>), and “Ink Promotional
Campaign” by Carla Sanchez from Product Marketing and Sales (<code class="docutils literal notranslate"><span class="pre">MKT</span></code>). Thus
the results of the innermost query produces a list of two department
codes: <code class="docutils literal notranslate"><span class="pre">RND</span></code> and <code class="docutils literal notranslate"><span class="pre">MKT</span></code>.</p>
<p>Once the departments are known, a search is done of the <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>
table, to locate the division or divisions to which these departments
belong. Both departments belong to the Product Division (<code class="docutils literal notranslate"><span class="pre">PROD</span></code>); thus the
results of the next subquery produces one item: <code class="docutils literal notranslate"><span class="pre">PROD</span></code>.</p>
<p>A second pass is made through the same table, <code class="docutils literal notranslate"><span class="pre">DEPARTMENT</span></code>, to find all
departments which belong to the Product Division.  This search produces a
list of four Product Division departments: <code class="docutils literal notranslate"><span class="pre">MKT</span></code>, <code class="docutils literal notranslate"><span class="pre">RND</span></code>, <code class="docutils literal notranslate"><span class="pre">MFG</span></code>, and
<code class="docutils literal notranslate"><span class="pre">CSS</span></code>, adding Manufacturing as well as Customer Support and Service to the
list.</p>
<p>This list is passed to the outermost query so that the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>
table may be searched for all employees in those departments. The final
listing is retrieved, as above.</p>
<p>Here is another example specifically designed to illustrate the use of a
subquery making two passes through the same table to find the desired
results.</p>
<p><strong>Example:</strong> List the names of employees who have salaries greater than
that of Herbert Jackson. Assume you do not know Jackson’s salary.</p>
<p>Enter this statement:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">ENAME</span><span class="p">,</span> <span class="n">SALARY</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="n">SALARY</span> <span class="o">&gt;</span>
  <span class="p">(</span><span class="k">SELECT</span>   <span class="n">SALARY</span>
   <span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
   <span class="k">WHERE</span>    <span class="n">ENAME</span> <span class="o">=</span> <span class="s1">&#39;Jackson, Herbert&#39;</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>The compare operator <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> can be used (as could <code class="docutils literal notranslate"><span class="pre">=</span></code> and other compare
operators) where a single value only will be returned from the subquery.</p>
<p>Using the sample information in our <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, the results are
as follows:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME              SALARY
Aster, John A.     32000
Barrington, Kyle   45000
Price Stella       42000
Sanchez, Carla     35000
</pre></div>
</div>
<p>The subquery searches the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table and returns the value
<code class="docutils literal notranslate"><span class="pre">30000</span></code>, the salary listed for Herbert Jackson. Then the outer
<code class="docutils literal notranslate"><span class="pre">SELECT</span></code> block searches the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table again to retrieve all
employees with <code class="docutils literal notranslate"><span class="pre">SALARY</span> <span class="pre">&gt;</span> <span class="pre">30000</span></code>. Thus the above employees with higher
salaries are retrieved.</p>
</div>
</div>
<div class="section" id="forming-complex-queries">
<h2>Forming Complex Queries<a class="headerlink" href="#forming-complex-queries" title="Permalink to this headline">¶</a></h2>
<p>The situations covered in this section are more technical than most end
users have need to conceptualize. However, a system administrator may
require such complex query structures to efficiently obtain the desired
results.</p>
<div class="section" id="joining-a-table-to-itself">
<h3>Joining a Table to Itself<a class="headerlink" href="#joining-a-table-to-itself" title="Permalink to this headline">¶</a></h3>
<p>In some situations, you may find it necessary to join a table to itself,
as though you were joining two separate tables. This is referred to as a
<em>self join</em>. In the self join, the combined result consists of two rows
from the same table.</p>
<p>For example, suppose that within the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, personnel are
assigned a RANK of “STAFF”, “DHEAD”, and so on. To obtain a list of
employees that includes employee name and the name of his or her
department head requires the use of a self join.</p>
<p>To join a table to itself, the table name appears twice in the <code class="docutils literal notranslate"><span class="pre">FROM</span></code>
clause. To distinguish between the appearance of the same table name, a
temporary name, called an <em>alias</em> or a <em>correlation name</em>, is assigned
to each mention of the table name in the <code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause. The form of
the <code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause with an alias is:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span>   <span class="k">table</span><span class="o">-</span><span class="n">name</span> <span class="p">[</span><span class="n">alias1</span><span class="p">]</span> <span class="p">[,</span><span class="k">table</span><span class="o">-</span><span class="n">name</span> <span class="p">[</span><span class="n">alias2</span><span class="p">]</span> <span class="p">]</span> <span class="p">...</span>
</pre></div>
</div>
<p>To help clarify the meaning of the query, the alias can be used as a
qualifier, in the same way that the table name serves as a qualifier, in
<code class="docutils literal notranslate"><span class="pre">SELECT</span></code> and <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clauses.</p>
<p><strong>Example:</strong> As part of an analysis of Acme’s salary structure, you want
to identify the names of any regular staff who are earning more than a
department head.</p>
<p>Enter this query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">STAFF</span><span class="p">.</span><span class="n">ENAME</span><span class="p">,</span> <span class="n">STAFF</span><span class="p">.</span><span class="n">SALARY</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span> <span class="n">DHEAD</span><span class="p">,</span> <span class="n">EMPLOYEE</span> <span class="n">STAFF</span>
<span class="k">WHERE</span>    <span class="n">DHEAD</span><span class="p">.</span><span class="n">RANK</span> <span class="o">=</span> <span class="s1">&#39;DHEAD&#39;</span> <span class="k">AND</span> <span class="n">STAFF</span><span class="p">.</span><span class="n">RANK</span> <span class="o">=</span> <span class="s1">&#39;STAFF&#39;</span>
  <span class="k">AND</span>    <span class="n">STAFF</span><span class="p">.</span><span class="n">SALARY</span> <span class="o">&gt;</span> <span class="n">DHEAD</span><span class="p">.</span><span class="n">SALARY</span> <span class="p">;</span>
</pre></div>
</div>
<p>Using a sampling of information from the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, we would
get these results:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME               SALARY

Sanchez, Carla      35000
</pre></div>
</div>
<p>In this query, the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, using the alias feature, is
treated as two separate tables named <code class="docutils literal notranslate"><span class="pre">DHEAD</span></code> and <code class="docutils literal notranslate"><span class="pre">STAFF</span></code>, as shown
here (in shortened form):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DHEAD Table                         STAFF Table
EID ENAME   DEPT RANK  BEN  SALARY  EID ENAME   DEPT RANK  BEN  SALARY
101 Aster   MKT  STAFF FULL 32000   101 Aster   MKT  STAFF FULL 32000
109 Brown   MKT  DHEAD FULL 37500   109 Brown   MKT  DHEAD FULL 37500
103 Chapman LIB  STAFF PART 22000   103 Chapman LIB  STAFF PART 22000
110 Krinski LIB  DHEAD FULL 32500   110 Krinski LIB  DHEAD FULL 32500
106 Sanchez MKT  STAFF FULL 35000   106 Sanchez MKT  STAFF FULL 35000
</pre></div>
</div>
<p>Now the join operation can be made use of, as if there were two separate
tables, evaluated as follows.</p>
<p>First, using the following compound condition:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="n">DHEAD</span><span class="p">.</span><span class="n">RANK</span> <span class="o">=</span> <span class="s1">&#39;DHEAD&#39;</span> <span class="k">AND</span> <span class="n">STAFF</span><span class="p">.</span><span class="n">RANK</span> <span class="o">=</span> <span class="s1">&#39;STAFF&#39;</span>
</pre></div>
</div>
<p>each department head record (Brown, Krinski) in the <code class="docutils literal notranslate"><span class="pre">DHEAD</span></code> table is
joined with each staff record (Aster, Chapman, Sanchez) from the
<code class="docutils literal notranslate"><span class="pre">STAFF</span></code> table to form the following intermediate result:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>DHEAD Table                         STAFF Table
EID ENAME   DEPT RANK  BEN  SALARY  EID ENAME   DEPT RANK  BEN  SALARY
109 Brown   MKT  DHEAD FULL 37500   101 Aster   MKT  STAFF FULL 32000
109 Brown   MKT  DHEAD FULL 37500   103 Chapman LIB  STAFF PART 22000
109 Brown   MKT  DHEAD FULL 37500   106 Sanchez MKT  STAFF FULL 35000
110 Krinski LIB  DHEAD FULL 32500   101 Aster   MKT  STAFF FULL 32000
110 Krinski LIB  DHEAD FULL 32500   103 Chapman LIB  STAFF PART 22000
110 Krinski LIB  DHEAD FULL 32500   106 Sanchez MKT  STAFF FULL 35000
</pre></div>
</div>
<p>Notice that every department head row is combined with each staff
record.</p>
<p>Next, using the condition:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>STAFF.SALARY &gt; DHEAD.SALARY
</pre></div>
</div>
<p>for each row of the joined table, the salary value from the <code class="docutils literal notranslate"><span class="pre">STAFF</span></code>
portion is compared with the corresponding salary value from the
<code class="docutils literal notranslate"><span class="pre">DHEAD</span></code> portion. If <code class="docutils literal notranslate"><span class="pre">STAFF.SALARY</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">DHEAD.SALARY</span></code>,
then <code class="docutils literal notranslate"><span class="pre">STAFF.ENAME</span></code> and <code class="docutils literal notranslate"><span class="pre">STAFF.SALARY</span></code> are retrieved in the final
table.</p>
<p>The only row in the joined table satisfying this condition of staff
salary being greater than department head salary is the last one, where
Carla Sanchez from Marketing, at a salary of $35,000, is earning more
than Wanda Krinski, as department head for the Corporate Library, at a
salary of $32,500.</p>
</div>
<div class="section" id="correlated-subqueries">
<h3>Correlated Subqueries<a class="headerlink" href="#correlated-subqueries" title="Permalink to this headline">¶</a></h3>
<p>All the previous examples of subqueries evaluated the innermost query
completely before moving to the next level of the query. Some queries,
however, cannot be completely evaluated before the outer, or main, query
is evaluated. Instead, the search condition of a subquery depends on a
value in each row of the table named in the outer query. Therefore, the
subquery is evaluated repeatedly, once for each row selected from the
outer table. This type of subquery is referred to as a <em>correlated
subquery</em>.</p>
<p><strong>Example:</strong> Retrieve the name, department, and salary, of any employee
whose salary is above average for his or her department.</p>
<p>Enter this query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">POSSIBLE</span><span class="p">.</span><span class="n">ENAME</span><span class="p">,</span> <span class="n">POSSIBLE</span><span class="p">.</span><span class="n">DEPT</span><span class="p">,</span> <span class="n">POSSIBLE</span><span class="p">.</span><span class="n">SALARY</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span> <span class="n">POSSIBLE</span>
<span class="k">WHERE</span>    <span class="n">SALARY</span> <span class="o">&gt;</span>
  <span class="p">(</span><span class="k">SELECT</span>   <span class="k">AVG</span> <span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
   <span class="k">FROM</span>     <span class="n">EMPLOYEE</span> <span class="n">AVERAGE</span>
   <span class="k">WHERE</span>    <span class="n">POSSIBLE</span><span class="p">.</span><span class="n">DEPT</span> <span class="o">=</span> <span class="n">AVERAGE</span><span class="p">.</span><span class="n">DEPT</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p><strong>Syntax Notes:</strong></p>
<ul class="simple">
<li><p>The outer <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block is the main query.</p></li>
<li><p>The inner <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>-<code class="docutils literal notranslate"><span class="pre">FROM</span></code>-<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> block in parentheses is the
subquery.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> (following <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> in the outer query) and <code class="docutils literal notranslate"><span class="pre">AVERAGE</span></code>
(following <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> in the subquery) are alias table names for
the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table, so that the information may evaluated as
though it comes from two different tables.</p></li>
</ul>
<p>It results in:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ENAME               DEPT   SALARY
Krinski, Wanda      LIB    32500
Brown, Penelope     MKT    37500
Sanchez, Carla      MKT    35000
Jones, David        RND    37500
</pre></div>
</div>
<p>The column <code class="docutils literal notranslate"><span class="pre">AVERAGE.DEPT</span></code> correlates with <code class="docutils literal notranslate"><span class="pre">POSSIBLE.DEPT</span></code> in the main, or
outer, query. In other words, the average salary for a department is
calculated in the subquery using the department of each employee from
the table in the main query (<code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code>). The subquery computes the
average salary for this department and then compares it with a row in
the <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> table. If the salary in the <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> table is
greater than the average salary for the department, then that employee’s
name, department, and salary are displayed.</p>
<p>The process of the correlated subquery works in the following manner.
The department of the first row in <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> is used in the subquery to
compute an average salary. Let’s take Krinksi’s row, whose department is
the corporate library (<code class="docutils literal notranslate"><span class="pre">LIB</span></code>). In effect, the subquery is:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="k">AVG</span> <span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span> <span class="n">AVERAGE</span>
<span class="k">WHERE</span>    <span class="s1">&#39;LIB&#39;</span> <span class="o">=</span> <span class="n">AVERAGE</span><span class="p">.</span><span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LIB</span></code> is the value from the first row in <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code>, as alias for
<code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>.</p>
<p>This pass through the subquery results in a value of $27,250, the
average salary for the LIB dept. In the outer query, Krinski’s salary of
$32,500 is compared with the average salary for <code class="docutils literal notranslate"><span class="pre">LIB</span></code>; since it is
greater, Krinski’s name is displayed.</p>
<p>This process continues; next, Aster’s row in <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> is evaluated,
where <code class="docutils literal notranslate"><span class="pre">MKT</span></code> is the department. This time the subquery is evaluated as
follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="k">AVG</span> <span class="p">(</span><span class="n">SALARY</span><span class="p">)</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span> <span class="n">AVERAGE</span>
<span class="k">WHERE</span>    <span class="s1">&#39;MKT&#39;</span> <span class="o">=</span> <span class="n">AVERAGE</span><span class="p">.</span><span class="n">DEPT</span> <span class="p">;</span>
</pre></div>
</div>
<p>The results of this pass through the subquery is an average salary of
$34,833 for <code class="docutils literal notranslate"><span class="pre">MKT</span></code>, the Product Marketing and Sales Department. Since Aster
has a salary of $32,000, a figure lower than the average, this record is
not displayed.</p>
<p>Every department in <code class="docutils literal notranslate"><span class="pre">POSSIBLE</span></code> is examined in a similar manner before this
subquery is completed.</p>
</div>
<div class="section" id="subquery-using-exists">
<h3>Subquery Using EXISTS<a class="headerlink" href="#subquery-using-exists" title="Permalink to this headline">¶</a></h3>
<p>There may be situations in which you are interested in retrieving
records where there exists at least one row that satisfies a particular
condition. For example, the resume records stored in the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code>
table may include some individuals who are already employed at Acme
Industrial and so are entered in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table. If you wanted
to know which employees were seeking new jobs at the present time, an
existence test using the keyword <code class="docutils literal notranslate"><span class="pre">EXISTS</span></code> can be used to answer such a
query.</p>
<p>This type of query is developed with a subquery. The <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause of
the outer query is used to test the existence of rows that result from a
subquery. The form of the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause that is linked to the
subquery is:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">WHERE</span> <span class="p">[</span><span class="k">NOT</span><span class="p">]</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="n">subquery</span><span class="p">)</span>
</pre></div>
</div>
<p>This clause is satisfied if there is at least one row that would be
returned by the subquery. If so, the subquery does not return any
values; it just sets an indicator value to true. On the other hand, if
no elements satisfy the condition, or the set is empty, the indicator
value is false.</p>
<p>The subquery should return a single column only.</p>
<p><strong>Example:</strong> Retrieve a list of Acme employees who have submitted
resumes to personnel for a different job placement.</p>
<p>Enter this query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">EID</span><span class="p">,</span> <span class="n">ENAME</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="k">EXISTS</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">RNAME</span>
   <span class="k">FROM</span>   <span class="n">RESUME</span>
   <span class="k">WHERE</span>  <span class="n">EMPLOYEE</span><span class="p">.</span><span class="n">ENAME</span> <span class="o">=</span> <span class="n">RESUME</span><span class="p">.</span><span class="n">RNAME</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>The results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EID  ENAME
107  Smith, Roberta
113  Ferrer, Miguel
</pre></div>
</div>
<p>In this query, the subquery cannot be evaluated completely before the
outer query is evaluated. Instead, we have a correlated subquery. For
each row in <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>, a join of <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> and <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> tables
is performed (even though <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> is the only table that appears in
the subquery’s <code class="docutils literal notranslate"><span class="pre">FROM</span></code> clause) to determine if there is a resume name
in <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> that matches a name in <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>.</p>
<p>For example, for the first row in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table
(<code class="docutils literal notranslate"><span class="pre">ENAME</span> <span class="pre">=</span> <span class="pre">'Smith,</span> <span class="pre">Roberta'</span></code>) the subquery evaluates as <code class="docutils literal notranslate"><span class="pre">true</span></code> if at
least one row in the <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> table has RNAME = ’Smith, Roberta’;
otherwise, the expression evaluates as “false”.  Since there is a row in
<code class="docutils literal notranslate"><span class="pre">RESUME</span></code> with <code class="docutils literal notranslate"><span class="pre">RNAME</span> <span class="pre">=</span> <span class="pre">'Smith,</span> <span class="pre">Roberta'</span></code>, the expression is true and Roberta
Smith’s row is displayed.  Each row in <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> is evaluated in a
similar manner.</p>
<p>The following is an example of the interim join (in shortened form)
between the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> and <code class="docutils literal notranslate"><span class="pre">RESUME</span></code> Tables, for the above names
which satisfied the search requirement by appearing in both tables:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EMPLOYEE Table            RESUME Table
EID ENAME          DEPT   RES_ID  RNAME           JOB       EXISTS
                                                            (subquery)
107 Smith, Roberta RND    R406    Smith, Roberta  Engineer  TRUE
113 Ferrer, Miguel CSS    R425    Ferrer, Miguel  Analyst   TRUE
</pre></div>
</div>
<p>Note in this example that there is no key <code class="docutils literal notranslate"><span class="pre">ID</span></code> field connecting the two
tables; therefore the character field for name is being used to join the
two tables, which might have been entered differently and therefore is
not an altogether reliable join. This indicates that such a search is an
unusual rather than a usual action.</p>
<p>Such a search would be a good opportunity to use a Metamorph <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>
qualifier rather than a straight join on a column as above, where
<code class="docutils literal notranslate"><span class="pre">ENAME</span></code> must match exactly <code class="docutils literal notranslate"><span class="pre">RNAME</span></code>. A slightly more thorough way of
searching for names appearing in both tables which were not necessarily
intended to be matched exactly would use Metamorph’s approximate pattern
matcher, indicated by a <code class="docutils literal notranslate"><span class="pre">%</span></code> (percent sign) preceding the name. For
example:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">EID</span><span class="p">,</span> <span class="n">ENAME</span>
<span class="k">FROM</span>     <span class="n">EMPLOYEE</span>
<span class="k">WHERE</span>    <span class="k">EXISTS</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span>
   <span class="k">FROM</span>   <span class="n">RESUME</span>
   <span class="k">WHERE</span>  <span class="n">EMPLOYEE</span><span class="p">.</span><span class="n">ENAME</span> <span class="k">LIKE</span> <span class="s1">&#39;%&#39;</span> <span class="o">+</span> <span class="n">RESUME</span><span class="p">.</span><span class="n">RNAME</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>In this example a name approximately like each <code class="docutils literal notranslate"><span class="pre">RNAME</span></code> in the
<code class="docutils literal notranslate"><span class="pre">RESUME</span></code> table would be compared to each <code class="docutils literal notranslate"><span class="pre">ENAME</span></code> in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code>
table, increasing the likelihood of a match. (String concatenation is
used to append the name found in the resume table to the percent sign
(<code class="docutils literal notranslate"><span class="pre">%</span></code>) which signals the approximate pattern matcher XPM.)</p>
<p>Often, a query is formed to test if no rows are returned in a subquery.
In this case, the following form of the existence test is used:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">WHERE</span>   <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="p">(</span><span class="n">subquery</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Example:</strong> List any authors of reports submitted to the online
corporate library who are not current employees of Acme Industrial. To
find this out we would need to know which authors listed in the
<code class="docutils literal notranslate"><span class="pre">REPORT</span></code> table are not entered as employees in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> table.</p>
<p>Use this query:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span>   <span class="n">AUTHOR</span>
<span class="k">FROM</span>     <span class="n">REPORT</span>
<span class="k">WHERE</span>    <span class="k">NOT</span> <span class="k">EXISTS</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span>
   <span class="k">FROM</span>   <span class="n">EMPLOYEE</span>
   <span class="k">WHERE</span>  <span class="n">EMPLOYEE</span><span class="p">.</span><span class="n">ENAME</span> <span class="o">=</span> <span class="n">REPORT</span><span class="p">.</span><span class="n">AUTHOR</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>which would likely result in a list of former employees such as:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>AUTHOR
Acme, John Jacob Snr.
Barrington, Cedrick II.
Rockefeller, George G.
</pre></div>
</div>
<p>Again, we have an example of a correlated subquery. Below is illustrated
(in shortened form) how each row which satisfied the search requirement
above in <code class="docutils literal notranslate"><span class="pre">REPORT</span></code> is evaluated with the records in <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> to
determine which authors are not (or are no longer) Acme employees.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>REPORT Table                               EMPLOYEE Table  EXISTS
TITLE              AUTHOR
Company Origin     Acme, John Jacob Snr.                   FALSE
Management Art     Barrington, Cedrick II.                 FALSE
Financial Control  Rockefeller, George G.                  FALSE
</pre></div>
</div>
<p>In this example each of the above authors from the REPORT Table are
tested for existence in the <code class="docutils literal notranslate"><span class="pre">EMPLOYEE</span></code> Table. When they are not found
to exist there it returns a value of <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>. Since the query condition in
the <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause is that it <code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">EXISTS</span></code>, this changes the false value
to true, and these rows are displayed.</p>
<p>For each of the queries shown in this section, there are probably
several ways to obtain the same kind of result. Some correlated
subqueries can also be expressed as joins. These examples are given not
so much as the only definitive way to state these search requests, but
more so as to give a model for what kinds of things are possible.</p>
</div>
</div>
<div class="section" id="virtual-fields">
<h2>Virtual Fields<a class="headerlink" href="#virtual-fields" title="Permalink to this headline">¶</a></h2>
<p>To improve the capabilities of Texis, especially with regard to
Metamorph searching multiple fields we implemented the concept of
virtual fields. This allows you to treat the concatentation of any
number of text fields as a single field. As a single field you can
create an index on the fields, search the fields, and perform any other
operation allowable on a field. Concatenation is represented by the
<code class="docutils literal notranslate"><span class="pre">\</span></code> operator. For example:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span>SELECT TITLE
FROM   PAPERS
WHERE  ABSTRACT\BODY LIKE &#39;ink coloration&#39;;
</pre></div>
</div>
<p>would display the title of all papers whose abstract or body matched the
query <code class="docutils literal notranslate"><span class="pre">ink</span> <span class="pre">coloration</span></code>. By itself this is helpful, but the real change
is that you could create an index on this virtual field as follows:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span>CREATE METAMORPH INDEX IXMMABSBOD ON PAPERS(ABSTRACT\BODY);
</pre></div>
</div>
<p>which could greatly improve the performance of this query. You can
create any type of index on a virtual field, although it is important to
remember that for non Metamorph indices the sum of the fields should not
exceed 2048 bytes. If your keys are text fields this method allows you
to create a unique index across several fields.</p>
</div>
<div class="section" id="column-aliasing">
<h2>Column Aliasing<a class="headerlink" href="#column-aliasing" title="Permalink to this headline">¶</a></h2>
<p>Similar to the abililty to alias the name of a table in the from clause
it is also possible to alias column names. An alias can have up to 35
characters (case is significant).</p>
<p>This has several possible uses. One is simply to produce a more
informative report, for example:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">EMPLOYEES</span>
<span class="k">FROM</span>   <span class="n">EMPLOYEES</span><span class="p">;</span>
</pre></div>
</div>
<p>might produce the following output</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EMPLOYEES
   42
</pre></div>
</div>
<p>Another important use is when using the create table as select
statement. This allows you to rename a field, or to name a calculated
field.</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">INVENTORY</span> <span class="k">AS</span>
<span class="k">SELECT</span> <span class="n">PROD_ID</span><span class="p">,</span> <span class="n">SALES</span> <span class="o">*</span> <span class="mi">3</span> <span class="n">MAX_LEVEL</span><span class="p">,</span> <span class="n">SALES</span> <span class="n">MIN_LEVEL</span>
<span class="k">FROM</span>   <span class="n">SALES</span><span class="p">;</span>
</pre></div>
</div>
<p>Would create a new table with three fields, <code class="docutils literal notranslate"><span class="pre">PROD_ID</span></code>, <code class="docutils literal notranslate"><span class="pre">MAX_LEVEL</span></code>, and
<code class="docutils literal notranslate"><span class="pre">MIN_LEVEL</span></code>.</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The modulo operator (%) is supported for integral types.  Dividend floats
are cast (floor) to integer prior to the operation.  Divisor must be an integer
or an error is thrown. A Divisor of 0 returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
</dl>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sql3.html" class="btn btn-neutral float-right" title="Intelligent Text Search Queries" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="sql1.html" class="btn btn-neutral" title="Introduction to Texis SQL" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Moat Crossing Systems.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>