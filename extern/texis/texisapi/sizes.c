#include "txcoreconfig.h"
#ifdef _WIN32
#  include <windows.h>
#  ifdef __MINGW32__
#    define _PID_T_
#  endif /* __MINGW32__ */
typedef DWORD pid_t;                    /* NOTE: see PID_T in txconfig.h */
#endif /* _WIN32 */
/*#include "./txconfig_ind.h"*/       /* generated by Makefile  KNG 20070206 */
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include <errno.h>
#include "sys/types.h"
#include "time.h"
#include <math.h>

#ifdef __alpha
#  define USE_FPE_HANDLER
#endif /* __alpha */

#ifdef USE_FPE_HANDLER
#  include <signal.h>
#endif /* USE_FPE_HANDLER */
#ifdef MSDOS
#ifndef HAVE_STDLIB_H
#define HAVE_STDLIB_H
#endif /* HAVE_STDLIB_H */
int main(int argc, char *argv[]);
#endif /* MSDOS */
#ifdef HAVE_STDLIB_H /* JMT 96-03-29 - Stdlib for prototypes */
#include "stdlib.h"
#endif /* HAVE_STDLIB_H */
char *fn="sizes.h";
/* MAW 12-07-00 - add epi_xxx types */
char *bytefmt  ="#define     byte  %s\n#define epi_byte  %s\n";
char *wordfmt  ="#define     word  %s\n#define epi_word  %s\n";
char *dwordfmt ="#define     dword %s\n#define epi_dword %s\n";
char *qwordfmt ="#define     qword %s\n#define epi_qword %s\n";
char *bitfmt="#undef  EPI_OS_%s_BITS\n#define EPI_OS_%s_BITS %d\n";
char *undefBitfmt="#undef  EPI_OS_%s_BITS\n";
static const char AnyBitFmt[]=
  "#undef  EPI_%s_BITS\n"
  "#define EPI_%s_BITS EPI_%s_BITS\n";
char *hugeifmt  =
  "#ifndef EPI_HUGEINT_BITS\n"
  "typedef %s EPI_HUGEINT;   /* largest possible int */\n"
  "#  define EPI_HUGEINT_BITS %d\n"
  "#endif\n"
  "#undef  EPI_HUGEINTPN\n"
  "#define EPI_HUGEINTPN ((EPI_HUGEINT *)NULL)\n"
  "#undef  EPI_HUGEINT_PRINTF_PFX\n"
  "#define EPI_HUGEINT_PRINTF_PFX \"%s\"\n";
char *hugeuifmt =
  "#ifndef EPI_HUGEUINT_BITS\n"
  "typedef %s EPI_HUGEUINT;  /* largest possible unsigned */\n"
  "#  define EPI_HUGEUINT_BITS %d\n"
  "#endif\n"
  "#undef  EPI_HUGEUINTPN\n"
  "#define EPI_HUGEUINTPN ((EPI_HUGEUINT *)NULL)\n"
  "#undef  EPI_HUGEINT_PRINTF_PFX\n"
  "#define EPI_HUGEINT_PRINTF_PFX \"%s\"\n";

#ifdef RCS_ID
static const char RcsId[] = "$Id$";
#endif

static int  GotFpe = 0;

#ifdef USE_FPE_HANDLER
static void
fpe_handler(int sig)
{
  GotFpe = 1;
}
#endif /* USE_FPE_HANDLER */

int
main(int argc, char *argv[])
{
 static char enotempty[] = "Directory not empty";
 FILE *fh;
 int got;
 int c    = (int)sizeof( char              );
 int s    = (int)sizeof( short             );
 int i    = (int)sizeof( int               );
 int l    = (int)sizeof( long              );
 int f    = (int)sizeof( float             );
 int d    = (int)sizeof( double            );
#ifdef EPI_HAVE_LONG_DOUBLE
 int ld   = (int)sizeof( long double       );
#  define OS_LONG_DOUBLE_E_FMT  "Le"
#  define OS_LONG_DOUBLE_F_FMT  "Lf"
#  define OS_LONG_DOUBLE_G_FMT  "Lg"
#endif
 const char     *hugeFloatType = NULL;
 int            hugeFloatMantissaBits = -1;
 int            hugeFloatExponentBits = -1;
 int            hugeFloatMaxBase10Exponent = -1;
 int uc   = (int)sizeof( unsigned char     );
 int us   = (int)sizeof( unsigned short    );
 int ui   = (int)sizeof( unsigned int      );
 int ul   = (int)sizeof( unsigned long     );
#ifdef EPI_HAVE_LONG_LONG                       /* KNG 980930 Solaris 64-bit*/
 int ll   = (int)sizeof( long long         );
#endif
#ifdef EPI_HAVE___INT64
 int i64  = (int)sizeof( __int64           );
#endif
#ifdef EPI_HAVE_UNSIGNED_LONG_LONG              /* KNG 980930 Solaris 64-bit*/
 int ull  = (int)sizeof( unsigned long long);
#endif
#ifdef EPI_HAVE_UNSIGNED___INT64
 int ui64 = (int)sizeof( unsigned __int64  );
#endif
 int st   = (int)sizeof( size_t            );
 int ot   = (int)sizeof( off_t             );
 int tt   = (int)sizeof(time_t             );
 int ptrByteSz= (int)sizeof(void *);
 int epiOff_tByteSz = -1;                       /* determined below */
 int sts, ots, bits;
 int    warnOnly = 0, argIdx;
 unsigned char *bp;
 size_t stv=(size_t)(-1);
 off_t  otv=(off_t)(-1);
 time_t time_tNegOne = (time_t)(-1);
 int    time_tIsSigned;
#ifdef EPI_HAVE___INT64
 __int64 ltv=(__int64)(-1);
#endif
 void   *ptr;
 int    hibits = 0, huibits = 0, j;
 const char       *pfx;
 int    maxbase10exp = -1, maxdoublebase10exp = -1;
#ifdef EPI_HAVE_LONG_LONG
#  define SIGNED_SUFFIX(bits)   \
 ((bits) == 8*i ? "" : ((bits) == 8*l ? "L" : ((bits) == 8*ll ? "LL" : "")))
#else /* !EPI_HAVE_LONG_LONG */
#  define SIGNED_SUFFIX(bits)   \
 ((bits) == 8*i ? "" : ((bits) == 8*l ? "L" : ""))
#endif /* !EPI_HAVE_LONG_LONG */
#ifdef EPI_HAVE_UNSIGNED_LONG_LONG
#  define UNSIGNED_SUFFIX(bits)   \
 ((bits) == 8*ui ? "" : ((bits) == 8*ul ? "UL" :((bits) == 8*ull ? "ULL":"")))
#else /* !EPI_HAVE_UNSIGNED_LONG_LONG */
#  define UNSIGNED_SUFFIX(bits)   \
 ((bits) == 8*ui ? "" : ((bits) == 8*ul ? "UL" : ""))
#endif /* !EPI_HAVE_LONG_LONG */

 /* Process args: */
 for (argIdx = 1; argIdx < argc && *argv[argIdx] == '-'; argIdx++)
   {
     if (strcmp(argv[argIdx], "--warn-only") == 0)
       warnOnly = 1;
     else
       {
         fprintf(stderr,
                 "Unknown option `%s'\nUsage: %s [--warn-only] [filename]\n",
                 argv[argIdx], argv[0]);
         exit(1);
       }
   }
 if (argIdx < argc) fn = argv[argIdx++];

 fh=fopen(fn,"w");
 if(fh==(FILE *)NULL)
   {
     fprintf(stderr, "Cannot open %s for writing: %s\n",
             fn, strerror(errno));
     exit(1);
   }
 /* LICDATA stores a pid in an EPI_INT32: */
 if (sizeof(pid_t) > (size_t)4)
   {
     fprintf(stderr, "*** sizeof(pid_t) > 4: LICDATA problem ***\n");
     fflush(stderr);
     if (!warnOnly) exit(1);
   }

 if(stv<(size_t)0) sts=1; /* compile warning (always false) unavoidable */
 else      sts=0;
 if(otv<(off_t)0) ots=1;
 else      ots=0;

 fprintf(fh,"#ifndef SIZES_H\n");
 fprintf(fh,"#define SIZES_H 1\n\n");
 fprintf(fh,"/* WARNING: Generated by the sizes executable (machine specific) */\n");
 fprintf(fh,"/*          Assumes 8 bit chars */\n\n");
 fprintf(fh,"/* Sizes in bytes of the primary types :\n");
 fprintf(fh,"char                %3d\n",c  );
 fprintf(fh,"short               %3d\n",s  );
 fprintf(fh,"int                 %3d\n",i  );
 fprintf(fh,"long                %3d\n",l  );
 fprintf(fh,"float               %3d\n",f  );
 fprintf(fh,"double              %3d\n",d  );
#ifdef EPI_HAVE_LONG_DOUBLE
 fprintf(fh,"long double         %3d\n",ld );
#endif
 fprintf(fh,"unsigned char       %3d\n",uc );
 fprintf(fh,"unsigned short      %3d\n",us );
 fprintf(fh,"unsigned int        %3d\n",ui );
 fprintf(fh,"unsigned long       %3d\n",ul );
#ifdef EPI_HAVE_LONG_LONG
 fprintf(fh,"long long           %3d\n",ll );
#endif
#ifdef EPI_HAVE___INT64
 fprintf(fh,"__int64             %3d\n",i64);
#endif
#ifdef EPI_HAVE_UNSIGNED_LONG_LONG
 fprintf(fh,"unsigned long long  %3d\n",ull);
#endif
#ifdef EPI_HAVE_UNSIGNED___INT64
 fprintf(fh,"unsigned __int64    %3d\n",ui64);
#endif
 fprintf(fh,"size_t              %3d\n",st );
 fprintf(fh,"off_t               %3d\n",ot );
 fprintf(fh,"time_t              %3d\n",tt );
 fprintf(fh,"void *              %3d\n",ptrByteSz);
 fprintf(fh,"*/\n\n");

 fprintf(fh,"#ifdef byte\n");
 fprintf(fh,"#undef byte\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef epi_byte\n");
 fprintf(fh,"#undef epi_byte\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef word\n");
 fprintf(fh,"#undef word\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef epi_word\n");
 fprintf(fh,"#undef epi_word\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef dword\n");
 fprintf(fh,"#undef dword\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef epi_dword\n");
 fprintf(fh,"#undef epi_dword\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef qword\n");
 fprintf(fh,"#undef qword\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"#ifdef epi_qword\n");
 fprintf(fh,"#undef epi_qword\n");
 fprintf(fh,"#endif\n");
 fprintf(fh,"\n");

#define FMT(a,b) fprintf(fh,a,b,b)
 /* MinGW's rpcndr.h typedefs byte; guard that define to avoid conflict: */
 fprintf(fh,"#ifndef __MINGW32__\n");
 if(uc==1)      FMT(bytefmt,"unsigned char");
 else if(us==1) FMT(bytefmt,"unsigned short");
 else if(ui==1) FMT(bytefmt,"unsigned int");
 else if(ul==1) FMT(bytefmt,"unsigned long");
 fprintf(fh,"#else /* __MINGW32__ */\n");
 if(uc==1)      fprintf(fh,"#define epi_byte  unsigned char\n");
 else if(us==1) fprintf(fh,"#define epi_byte  unsigned short\n");
 else if(ui==1) fprintf(fh,"#define epi_byte  unsigned int\n");
 else if(ul==1) fprintf(fh,"#define epi_byte  unsigned long\n");
 fprintf(fh,"#endif /* !__MINGW32__ */\n");

                     /* favor int for word if possible - MAW 11-06-92 */
 if(ui==2)      FMT(wordfmt,"unsigned int");
 else if(uc==2) FMT(wordfmt,"unsigned char");
 else if(us==2) FMT(wordfmt,"unsigned short");
 else if(ul==2) FMT(wordfmt,"unsigned long");

                   /* favor long for dword if possible - MAW 11-06-92 */
 if(ul==4)      FMT(dwordfmt,"unsigned long");
 else if(uc==4) FMT(dwordfmt,"unsigned char");
 else if(us==4) FMT(dwordfmt,"unsigned short");
 else if(ui==4) FMT(dwordfmt,"unsigned int");

                   /* favor long for qword if possible - MAW 11-15-95 */
 if(ul==8)      FMT(qwordfmt,"unsigned long");
 else if(ui==8) FMT(qwordfmt,"unsigned int");
 else if(us==8) FMT(qwordfmt,"unsigned short");
 else if(uc==8) FMT(qwordfmt,"unsigned char");

 if (s == 16/8)      fprintf(fh, "typedef short EPI_INT16;\n");
 fprintf(fh, "#define EPI_INT16PN     ((EPI_INT16 *)NULL)\n");

 if (us == 16/8)     fprintf(fh, "typedef unsigned short EPI_UINT16;\n");
 fprintf(fh, "#define EPI_UINT16PN    ((EPI_UINT16 *)NULL)\n");

 if (i == 32/8)      fprintf(fh, "typedef int EPI_INT32;\n");
 else if (l == 32/8) fprintf(fh, "typedef long EPI_INT32;\n");
 fprintf(fh, "#define EPI_INT32PN     ((EPI_INT32 *)NULL)\n");
 fprintf(fh, "#undef  EPI_INT32_MAX\n");
 fprintf(fh, "#define EPI_INT32_MAX   0x7fffffff%s\n", SIGNED_SUFFIX(32));

 if (ui == 32/8)      fprintf(fh, "typedef unsigned int EPI_UINT32;\n");
 else if (ul == 32/8) fprintf(fh, "typedef unsigned long EPI_UINT32;\n");
 fprintf(fh, "#define EPI_UINT32PN    ((EPI_UINT32 *)NULL)\n");
 fprintf(fh, "#undef  EPI_UINT32_MAX\n");
 fprintf(fh, "#define EPI_UINT32_MAX  0xffffffff%s\n", UNSIGNED_SUFFIX(32));

 fprintf(fh, "#undef  EPI_INT64_MAX\n");
 fprintf(fh, "#undef  TX_INT64_MAX\n");
 got = 0;
 if (i == 64/8)      {got=1; fprintf(fh, "typedef int EPI_INT64;\n");}
 else if (l == 64/8) {got=1; fprintf(fh, "typedef long EPI_INT64;\n");}
#ifdef EPI_HAVE_LONG_LONG
 else if (ll == 64/8){got=1; fprintf(fh, "typedef long long EPI_INT64;\n");}
#endif
#ifdef EPI_HAVE___INT64
 else if (i64 == 64/8){got=1; fprintf(fh, "typedef __int64 EPI_INT64;\n");}
#endif
 if (got)
   {
     fprintf(fh, "#define EPI_INT64PN     ((EPI_INT64 *)NULL)\n");
     fprintf(fh, "#define EPI_INT64_MAX   0x7fffffffffffffff%s\n",
             SIGNED_SUFFIX(64));
     /* TX_INTnn is the "public" version (see ncg.c); transition to this: */
     fprintf(fh, "typedef EPI_INT64 TX_INT64;\n");
     fprintf(fh, "#define TX_INT64PN     ((TX_INT64 *)NULL)\n");
     fprintf(fh, "#define TX_INT64_MAX   0x7fffffffffffffff%s\n",
             SIGNED_SUFFIX(64));
   }

 fprintf(fh, "#undef  EPI_UINT64_MAX\n");
 fprintf(fh, "#undef  TX_UINT64_MAX\n");
 got = 0;
 if (ui == 64/8)      {got=1; fprintf(fh, "typedef unsigned int EPI_UINT64;\n");}
 else if (ul == 64/8) {got=1; fprintf(fh, "typedef unsigned long EPI_UINT64;\n");}
#ifdef EPI_HAVE_UNSIGNED_LONG_LONG
 else if (ull == 64/8){got=1; fprintf(fh, "typedef unsigned long long EPI_UINT64;\n");}
#endif
#ifdef EPI_HAVE_UNSIGNED___INT64
 else if (ui64 == 64/8){got=1; fprintf(fh, "typedef unsigned __int64 EPI_UINT64;\n");}
#endif
 if (got)
   {
     fprintf(fh, "#define EPI_UINT64PN    ((EPI_UINT64 *)NULL)\n");
     fprintf(fh, "#define EPI_UINT64_MAX  0xffffffffffffffff%s\n",
             UNSIGNED_SUFFIX(64));
     /* TX_INTnn is the "public" version (see ncg.c); transition to this: */
     fprintf(fh, "typedef EPI_UINT64 TX_UINT64;\n");
     fprintf(fh, "#define TX_UINT64PN    ((TX_UINT64 *)NULL)\n");
     fprintf(fh, "#define TX_UINT64_MAX  0xffffffffffffffff%s\n",
             UNSIGNED_SUFFIX(64));
   }

 fprintf(fh,bitfmt,"CHAR","CHAR", (int)(c*8));
 fprintf(fh,bitfmt,"SHORT","SHORT", (int)(s*8));
 fprintf(fh,"#undef  EPI_OS_SHORT_MAX\n#define EPI_OS_SHORT_MAX 0x%x\n",
         (int)(((unsigned short)~0U) >> 1));
 fprintf(fh,bitfmt,"INT","INT", (int)(i*8));
 fprintf(fh,"#undef  EPI_OS_INT_MAX\n#define EPI_OS_INT_MAX 0x%x\n", (~0U >> 1));
 fprintf(fh,bitfmt,"LONG","LONG", (int)(l*8));
 fprintf(fh,"#undef  EPI_OS_LONG_MAX\n#define EPI_OS_LONG_MAX 0x%lx\n",
         (~0UL >> 1));
 fprintf(fh,bitfmt,"FLOAT","FLOAT", (int)(f*8));
 fprintf(fh,bitfmt,"DOUBLE","DOUBLE", (int)(d*8));
 fprintf(fh, "#undef  EPI_OS_LONG_DOUBLE_E_FMT\n");
 fprintf(fh, "#undef  EPI_OS_LONG_DOUBLE_F_FMT\n");
 fprintf(fh, "#undef  EPI_OS_LONG_DOUBLE_G_FMT\n");
#ifdef EPI_HAVE_LONG_DOUBLE
 fprintf(fh,bitfmt,"LONG_DOUBLE","LONG_DOUBLE", (int)(ld*8));
 fprintf(fh, "#define EPI_OS_LONG_DOUBLE_E_FMT \"%s\"\n",OS_LONG_DOUBLE_E_FMT);
 fprintf(fh, "#define EPI_OS_LONG_DOUBLE_F_FMT \"%s\"\n",OS_LONG_DOUBLE_F_FMT);
 fprintf(fh, "#define EPI_OS_LONG_DOUBLE_G_FMT \"%s\"\n",OS_LONG_DOUBLE_G_FMT);
#endif
 fprintf(fh,bitfmt,"UCHAR","UCHAR", (int)(uc*8));
 fprintf(fh,bitfmt,"USHORT","USHORT", (int)(us*8));
 fprintf(fh,"#undef  EPI_OS_USHORT_MAX\n#define EPI_OS_USHORT_MAX 0x%x\n",
         (int)((unsigned short)~0U));
 fprintf(fh,bitfmt,"UINT","UINT", (int)(ui*8));
 fprintf(fh,"#undef  EPI_OS_UINT_MAX\n#define EPI_OS_UINT_MAX 0x%x\n", ~0U);
 fprintf(fh,bitfmt,"ULONG","ULONG", (int)(ul*8));
 fprintf(fh,"#undef  EPI_OS_ULONG_MAX\n#define EPI_OS_ULONG_MAX 0x%lx\n",
         ~0UL);
 fprintf(fh,bitfmt,"VOIDPTR","VOIDPTR", (int)(ptrByteSz*8));/*see below too*/
 fprintf(fh,"#undef  EPI_OS_VOIDPTR_MAX\n");
 if ((size_t)ptrByteSz == sizeof(int))
   {
     ptr = (void *)(-1);
     if (ptr > (void *)NULL && ptr > (void *)enotempty && ptr > (void *)&fh)
       fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)(-1))\n");
     else
       {
         ptr = (void *)((int)((unsigned)(~0) >> 1));
         if (ptr > (void *)NULL && ptr > (void*)enotempty && ptr > (void*)&fh)
           fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)0x%lx)\n",
                   (unsigned long)ptr); /* compile warning (ptr/int size) unavoidable; do not use `%p' due to inconsistent format across platforms e.g. Linux vs. Windows */
       }
     fprintf(fh, "/* EPI_VOIDPTR_[U]INT: [un]signed integer types the same size as void *: */\n");
     fprintf(fh, "typedef int EPI_VOIDPTR_INT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_INTPN ((EPI_VOIDPTR_INT *)NULL)\n");
     fprintf(fh, "typedef unsigned int EPI_VOIDPTR_UINT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_UINTPN ((EPI_VOIDPTR_UINT *)NULL)\n");
   }
 else if ((size_t)ptrByteSz == sizeof(long))
   {
     ptr = (void *)(-1L);
     if (ptr > (void *)NULL && ptr > (void *)enotempty && ptr > (void *)&fh)
       fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)(-1L))\n");
     else
       {
         ptr = (void *)((long)((unsigned long)(~0L) >> 1));
         if (ptr > (void *)NULL && ptr > (void*)enotempty && ptr > (void*)&fh)
           fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)0x%lx)\n",
                   (unsigned long)ptr);
       }
     fprintf(fh, "/* EPI_VOIDPTR_[U]INT: [un]signed integer types the same size as void *: */\n");
     fprintf(fh, "typedef long EPI_VOIDPTR_INT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_INTPN ((EPI_VOIDPTR_INT *)NULL)\n");
     fprintf(fh, "typedef unsigned long EPI_VOIDPTR_UINT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_UINTPN ((EPI_VOIDPTR_UINT *)NULL)\n");
   }
#if defined(EPI_HAVE_LONG_LONG) || defined(EPI_HAVE___INT64)
#  ifdef EPI_HAVE_LONG_LONG
 else if ((size_t)ptrByteSz == sizeof(long long))
#  elif defined(EPI_HAVE___INT64)
 else if ((size_t)ptrByteSz == sizeof(__int64))
#  else
   error;
#  endif
   {
     ptr = (void *)(-1LL);
     if (ptr > (void *)NULL && ptr > (void *)enotempty && ptr > (void *)&fh)
       fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)(-1LL))\n");
     else
       {
#  ifdef EPI_HAVE_LONG_LONG
#    define lnln long long
#    define lnlnstr "long long"
#    define lnlnfmt "%llx"
#  elif defined(EPI_HAVE___INT64)
#    define lnln __int64
#    define lnlnstr "__int64"
#    define lnlnfmt "%I64x"
#  endif
         ptr = (void *)((lnln)((unsigned lnln)(~0LL) >> 1));
         if (ptr > (void *)NULL && ptr > (void*)enotempty && ptr > (void*)&fh)
           fprintf(fh, "#define EPI_OS_VOIDPTR_MAX ((void *)0x" lnlnfmt ")\n",
                   (unsigned lnln)ptr);
       }
     fprintf(fh, "/* EPI_VOIDPTR_[U]INT: [un]signed integer types the same size as void *: */\n");
     fprintf(fh, "typedef " lnlnstr " EPI_VOIDPTR_INT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_INTPN ((EPI_VOIDPTR_INT *)NULL)\n");
     fprintf(fh, "typedef unsigned " lnlnstr " EPI_VOIDPTR_UINT;\n");
     fprintf(fh, "#define EPI_VOIDPTR_UINTPN ((EPI_VOIDPTR_UINT *)NULL)\n");
   }
#  undef lnln
#  undef lnlnstr
#  undef lnlnfmt
#endif /* EPI_HAVE_LONG_LONG || EPI_HAVE___INT64 */

 fprintf(fh,
         "/* EPI_VOIDPTR_{DEC|HEX}_FMT: OS printf() codes for decimal/hex\n"
         " * printing of pointers.  Note: htsnpf() with %%p code preferred:\n"
         " */\n");
 fprintf(fh,"#undef  EPI_VOIDPTR_DEC_FMT\n"
            "#undef  EPI_VOIDPTR_HEX_FMT\n"
            "#undef  EPI_VOIDPTR_HEX_UPPER_FMT\n"
         );
 if (ptrByteSz == i) pfx = "";
 else if (ptrByteSz == l) pfx = "l";
#ifdef EPI_HAVE_LONG_LONG
 else if (ptrByteSz == ll) pfx = "ll";
#endif
#ifdef EPI_HAVE___INT64
 else if ((size_t)ptrByteSz == sizeof(__int64)) pfx = "I64";
#endif
 else pfx = NULL;
 if (pfx)
   fprintf(fh, "#define EPI_VOIDPTR_DEC_FMT \"%s%c\"\n"
               "#define EPI_VOIDPTR_HEX_FMT \"%sx\"\n"
               "#define EPI_VOIDPTR_HEX_UPPER_FMT \"%sX\"\n",
           pfx, 'u', pfx, pfx);

 fprintf(fh, "\n");

#ifdef EPI_HAVE_LONG_LONG
 fprintf(fh,bitfmt,"LONGLONG","LONGLONG", (int)(ll*8));
 if (ll > l && !hibits)
   fprintf(fh, hugeifmt, "long long", hibits = ll*8, "ll");
#else
 fprintf(fh, undefBitfmt, "LONGLONG");
#endif

#ifdef EPI_HAVE___INT64
 fprintf(fh,bitfmt,"__INT64","__INT64", (int)(i64*8));
 if (i64 > l && !hibits)
   fprintf(fh, hugeifmt, "__int64", hibits = i64*8, "I64");
#else
 fprintf(fh, undefBitfmt, "__INT64");
#endif

 if (!hibits)
   fprintf(fh, hugeifmt, "long", hibits = l*8, "l");

 fprintf(fh, "#define EPI_HUGEINT_MAX 0x7");
 for (j = 4; j < hibits; j+= 4) fprintf(fh, "f");
 fprintf(fh,"%s\n", SIGNED_SUFFIX(hibits));

#ifdef EPI_HAVE_UNSIGNED_LONG_LONG
 fprintf(fh,bitfmt,"ULONGLONG","ULONGLONG", (int)(ull*8));
 if (ull > ul && !huibits)
   fprintf(fh, hugeuifmt, "unsigned long long", huibits = ull*8, "ll");
#else /* !EPI_HAVE_UNSIGNED_LONG_LONG */
 fprintf(fh, undefBitfmt, "ULONGLONG");
#endif /* !EPI_HAVE_UNSIGNED_LONG_LONG */

#ifdef EPI_HAVE_UNSIGNED___INT64
 fprintf(fh,bitfmt,"U__INT64","U__INT64", (int)(ui64*8));
 if (ui64 > ul && !huibits)
   fprintf(fh, hugeuifmt, "unsigned __int64", huibits = ui64*8, "I64");
#else
 fprintf(fh, undefBitfmt, "U_INT64");
#endif

 if (!huibits)
   fprintf(fh, hugeuifmt, "unsigned long", huibits = ul*8, "l");

 fprintf(fh, "#define EPI_HUGEUINT_MAX 0xf");
 for (j = 4; j < huibits; j+= 4) fprintf(fh, "f");
 fprintf(fh, "%s\n", UNSIGNED_SUFFIX(huibits));

 fprintf(fh, "\n");

 fprintf(fh,bitfmt,"SIZE_T","SIZE_T", (int)(st*8));
 fprintf(fh,bitfmt,"OFF_T","OFF_T", (int)(ot*8));
 fprintf(fh,bitfmt,"TIME_T","TIME_T", (int)(tt*8));

#ifdef EPI_HAVE_SIGNED_SSIZE_T
 fprintf(fh, bitfmt, "SSIZE_T", "SSIZE_T", (int)(sizeof(ssize_t)*8));
 fprintf(fh, "#undef  EPI_OS_SSIZE_T_MAX\n");
 fprintf(fh, "#define EPI_OS_SSIZE_T_MAX 0x7f");
 for (j = sizeof(ssize_t)-1; j > 0; j--) fprintf(fh, "ff");
 fprintf(fh, "%s\n", SIGNED_SUFFIX(sizeof(ssize_t)*8));
 /* Check that ssize_t appears large enough.  Note that if ssize_t and
  * size_t are equal size, ssize_t can only hold half the max value
  * that size_t can, since ssize_t is signed and size_t (usually) is
  * not.  But for our purposes (e.g. htsnpf()) that is large enough:
  */
 if (sizeof(ssize_t) >= (size_t)st)             /* ssize_t large enough */
   {
     fprintf(fh, "typedef ssize_t EPI_SSIZE_T;\n");
     fprintf(fh, "#undef  EPI_SSIZE_T_BITS\n#define EPI_SSIZE_T_BITS %d\n",
             (int)sizeof(ssize_t)*8);
     fprintf(fh, "#undef  EPI_SSIZE_T_MAX\n#define EPI_SSIZE_T_MAX 0x7f");
     for (j = sizeof(ssize_t)-1; j > 0; j--) fprintf(fh, "ff");
     fprintf(fh, "%s\n", SIGNED_SUFFIX(sizeof(ssize_t)*8));
   }
 else                                           /* make up EPI_SSIZE_T */
#else /* !EPI_HAVE_SIGNED_SSIZE_T */
 fprintf(fh, "#undef  EPI_OS_SSIZE_T_BITS\n#undef  EPI_OS_SSIZE_T_MAX\n");
#endif /* !EPI_HAVE_SIGNED_SSIZE_T */
   {
     fprintf(fh, "typedef EPI_INT%d EPI_SSIZE_T;\n", st*8);
     fprintf(fh, "#undef  EPI_SSIZE_T_BITS\n#define EPI_SSIZE_T_BITS %d\n",
             st*8);
     fprintf(fh, "#undef  EPI_SSIZE_T_MAX\n#define EPI_SSIZE_T_MAX 0x7f");
     for (j = st-1; j > 0; j--) fprintf(fh, "ff");
     fprintf(fh, "%s\n", SIGNED_SUFFIX(st*8));
   }
 fprintf(fh, "#define EPI_SSIZE_TPN   ((EPI_SSIZE_T *)NULL)\n");

 fprintf(fh,"\n");
 fprintf(fh,"#undef  EPI_OS_SIZE_T_MAX\n");
 fprintf(fh,"#define EPI_OS_SIZE_T_MAX 0x%cf",sts?'7':'f');
 for(j=st-1;j>0;j--) fprintf(fh,"ff");
 fprintf(fh,"\n");

 fprintf(fh, "#undef  EPI_OS_SIZE_T_IS_SIGNED\n");
 if (sts) fprintf(fh, "#define EPI_OS_SIZE_T_IS_SIGNED 1\n");

 fprintf(fh,"#undef  EPI_OS_SIZE_T_DEC_FMT\n"
            "#undef  EPI_OS_SIZE_T_HEX_FMT\n"
            "#undef  EPI_OS_SIZE_T_HEX_UPPER_FMT\n"
         );
 if (st == i) pfx = "";
 else if (st == l) pfx = "l";
#ifdef EPI_HAVE_LONG_LONG
 else if (st == ll) pfx = "ll";
#endif
#ifdef EPI_HAVE___INT64
 else if (st == sizeof(__int64)) pfx = "I64";
#endif
 else pfx = NULL;
 if (pfx)
   fprintf(fh, "#define EPI_OS_SIZE_T_DEC_FMT \"%s%c\"\n"
               "#define EPI_OS_SIZE_T_HEX_FMT \"%sx\"\n"
               "#define EPI_OS_SIZE_T_HEX_UPPER_FMT \"%sX\"\n",
           pfx, (sts ? 'd' : 'u'), pfx, pfx);

 fprintf(fh,"#undef  EPI_OS_OFF_T_MAX\n");
 fprintf(fh,"#define EPI_OS_OFF_T_MAX 0x%cf",ots?'7':'f');
 for(j=ot-1;j>0;j--) fprintf(fh,"ff");
 fprintf(fh,"%s\n", (ots ? SIGNED_SUFFIX(8*ot) : UNSIGNED_SUFFIX(8*ot)));

 fprintf(fh,"#undef  EPI_OS_OFF_T_DEC_FMT\n"
            "#undef  EPI_OS_OFF_T_HEX_FMT\n"
            "#undef  EPI_OS_OFF_T_HEX_UPPER_FMT\n"
         );
 if (ot == i) pfx = "";
 else if (ot == l) pfx = "l";
#ifdef EPI_HAVE_LONG_LONG
 else if (ot == ll) pfx = "ll";
#endif
#ifdef EPI_HAVE___INT64
 else if (st == sizeof(__int64)) pfx = "I64";
#endif
 else pfx = NULL;
 if (pfx)
   fprintf(fh, "#define EPI_OS_OFF_T_DEC_FMT \"%s%c\"\n"
               "#define EPI_OS_OFF_T_HEX_FMT \"%sx\"\n"
               "#define EPI_OS_OFF_T_HEX_UPPER_FMT \"%sX\"\n",
           pfx, (ots ? 'd' : 'u'), pfx, pfx);

 fprintf(fh,"#undef  EPI_OFF_T_MAX\n");
 /* See below for more TX_NT_LARGEFILE stuff  KNG 010514 */
#ifdef _WIN32
#  ifdef TX_NT_LARGEFILE
 if (1)
#  else /* !TX_NT_LARGEFILE */
 if (0)
#  endif /* !TX_NT_LARGEFILE */
   {
     fprintf(fh,"typedef __int64 EPI_OFF_T;\n");
     fprintf(fh,"#define EPI_OFF_T_MAX 0x7fffffffffffffff\n");
     /* WTF `L'/`LL' suffix for EPI_OFF_T_MAX? */
     epiOff_tByteSz = sizeof(__int64);
   }
 else
   {
#endif /* _WIN32 */
     fprintf(fh,"typedef off_t EPI_OFF_T;\n");
     fprintf(fh,"#define EPI_OFF_T_MAX   0x%cf",ots?'7':'f');
     for (j = ot - 1; j > 0; j--) fprintf(fh, "ff");
     fprintf(fh,"%s\n", (ots ? SIGNED_SUFFIX(8*ot) : UNSIGNED_SUFFIX(8*ot)));
     epiOff_tByteSz = ot;
#ifdef _WIN32
   }
#endif /* _WIN32 */
 fprintf(fh, "#undef  EPI_OFF_T_BITS\n#define EPI_OFF_T_BITS %d\n",
         epiOff_tByteSz*8);
 fprintf(fh,"#define EPI_OFF_TPN ((EPI_OFF_T *)NULL)\n");

 /* Texis often stores pointers in recids/EPI_OFF_Ts, eg. RAM B-tree.
  * Yap if those pointers would be truncated:
  */
 if (epiOff_tByteSz < ptrByteSz)
   {
     fprintf(stderr,
             "*** EPI_OFF_T_BITS %d < EPI_OS_VOIDPTR_BITS %d: Texis RAM B-trees may fail ***\n",
             epiOff_tByteSz*8, ptrByteSz*8);
     if (!warnOnly) exit(1);
   }

 fprintf(fh,"#undef  EPI_OFF_T_DEC_FMT\n"
            "#undef  EPI_OFF_T_HEX_FMT\n"
            "#undef  EPI_OFF_T_HEX_UPPER_FMT\n"
         );
#ifdef _WIN32
 fprintf(fh,"#ifdef TX_NT_LARGEFILE\n");
 fprintf(fh,"#  define EPI_OFF_T_DEC_FMT \"I64d\"\n");
 fprintf(fh,"#  define EPI_OFF_T_HEX_FMT \"I64x\"\n");
 fprintf(fh,"#  define EPI_OFF_T_HEX_UPPER_FMT \"I64X\"\n");
 fprintf(fh,"#else /* !TX_NT_LARGEFILE */\n");
#endif /* _WIN32 */
 fprintf(fh, "#define EPI_OFF_T_DEC_FMT EPI_OS_OFF_T_DEC_FMT\n"
             "#define EPI_OFF_T_HEX_FMT EPI_OS_OFF_T_HEX_FMT\n"
             "#define EPI_OFF_T_HEX_UPPER_FMT EPI_OS_OFF_T_HEX_UPPER_FMT\n"
         );
#ifdef _WIN32
 fprintf(fh,"#endif /* !TX_NT_LARGEFILE */\n");
#endif /* _WIN32 */

 time_tIsSigned = (time_tNegOne < (time_t)0);
 fprintf(fh,"#undef  EPI_OS_TIME_T_MAX\n");
 fprintf(fh,"#define EPI_OS_TIME_T_MAX  0x%cf", (time_tIsSigned ? '7' : 'f'));
 for (j = tt - 1; j > 0; j--) fprintf(fh, "ff");
 fprintf(fh, "%s\n",
         (time_tIsSigned ? SIGNED_SUFFIX(tt*8) : UNSIGNED_SUFFIX(tt*8)));

 fprintf(fh, "#undef  EPI_OS_TIME_T_IS_SIGNED\n");
 if (time_tIsSigned) fprintf(fh, "#define EPI_OS_TIME_T_IS_SIGNED 1\n");

 /* Compute and print float/double mantissa/exponent bits.
  * These are approximate:
  */
 {
   FILE *devnull;
#ifdef MSDOS
#  ifndef _PATH_DEVNULL
#    define _PATH_DEVNULL       "nul"
#  endif /* !_PATH_DEVNULL */
#else /* !MSDOS */
#  ifndef _PATH_DEVNULL
#    define _PATH_DEVNULL       "/dev/null"
#  endif /* !_PATH_DEVNULL */
#endif /* !MSDOS */
   devnull = fopen(_PATH_DEVNULL, "w");         /* defeat gcc -O2 below */
#ifdef USE_FPE_HANDLER
   signal(SIGFPE, fpe_handler);
#endif /* USE_FPE_HANDLER */
#define MANEXP(type, name, fmt, fmtCastType)                            \
{                                                                       \
  type  prevsum = -1.0, prevPrevSum = -2.0, sum = 0.0, x;               \
  int   n, fbits, mantissaBits;                                         \
  GotFpe = 0;                                                           \
  for (x = 1.0, fbits = 0; sum > prevsum; x /= (type)2.0, fbits++)      \
    {                                                                   \
      prevsum = sum;                                                    \
      sum += x;                                                         \
      if (GotFpe) break;                                                \
      if(devnull) fprintf(devnull, "%1.50" fmt, (fmtCastType)sum);                  \
      /* KNG 20140220 without this BSD reports all types as 54 bits: */ \
      if(devnull) fprintf(devnull, " fbits = %d\n", fbits);                         \
    }                                                                   \
  fbits--;                                                              \
  fprintf(fh, "\n#undef  EPI_OS_%s_MANTISSA_BITS\n", name);             \
  fprintf(fh, "#define EPI_OS_%s_MANTISSA_BITS %d\n", name, fbits);     \
  mantissaBits = fbits;                                                 \
  /* For large types like long double a linear doubling can take */     \
  /* a while, so do this in two stages: */                              \
  /* Stage 1: double 20x per iteration: */                              \
  prevsum = prevPrevSum = 0.0;                                          \
  sum = 1.0;                                                            \
  GotFpe = 0;                                                           \
  for (n = 0; sum > prevsum; n += 20)                                   \
    {                                                                   \
      prevPrevSum = prevsum;                                            \
      prevsum = sum;                                                    \
      sum *= (type)1048576.0;                   /* 2^20 */              \
      if (GotFpe) { n += 20; break; }                                   \
      if(devnull) fprintf(devnull, "sum = %1.50" fmt, (fmtCastType)sum);            \
      if(devnull) fprintf(devnull, " n = %d\n", n);                                 \
    }                                                                   \
  /* back off 2 iterations, to get before sum = Inf: */                 \
  n -= 40;                                                              \
  sum = prevPrevSum;                                                    \
  /* Stage 2: double once per iteration: */                             \
  GotFpe = 0;                                                           \
  prevsum = 0.0;                                                        \
  for ( ; sum > prevsum; n++)                                           \
    {                                                                   \
      prevsum = sum;                                                    \
      sum *= (type)2.0;                                                 \
      if (GotFpe) { n++; break; }                                       \
      if(devnull) fprintf(devnull, "%1.50" fmt, (fmtCastType)sum);                  \
      if(devnull) fprintf(devnull, " n = %d\n", n);                                 \
    }                                                                   \
  n--;                                                                  \
  for (fbits = 0; (1 << fbits) <= n; fbits++);                          \
  fbits--;                                                              \
  fprintf(fh, "#undef  EPI_OS_%s_EXPONENT_BITS\n", name);               \
  fprintf(fh, "#define EPI_OS_%s_EXPONENT_BITS %d\n", name, fbits);     \
  fprintf(fh, "#undef  EPI_OS_%s_MAX_BASE10_EXPONENT\n", name);         \
  maxbase10exp = (int)(((double)n)*log(2.0)/log(10.0));                 \
  fprintf(fh, "#define EPI_OS_%s_MAX_BASE10_EXPONENT %d\n", name,       \
          maxbase10exp);                                                \
  if (mantissaBits > hugeFloatMantissaBits ||                           \
      (mantissaBits == hugeFloatMantissaBits &&                         \
       fbits > hugeFloatExponentBits))                                  \
    {                                                                   \
      hugeFloatType = #type;                                            \
      hugeFloatMantissaBits = mantissaBits;                             \
      hugeFloatExponentBits = fbits;                                    \
      hugeFloatMaxBase10Exponent = maxbase10exp;                        \
    }                                                                   \
}

 MANEXP(float, "FLOAT", "f", float);
 MANEXP(double, "DOUBLE", "f", double);
 maxdoublebase10exp = maxbase10exp;
#ifdef EPI_HAVE_LONG_DOUBLE
 MANEXP(long double, "LONG_DOUBLE", OS_LONG_DOUBLE_F_FMT, long double);
#endif
#ifdef EPI_HAVE___FLOAT128
 /* wtf no known native __float128 printf() formats: */
 MANEXP(__float128, "__FLOAT128", OS_LONG_DOUBLE_F_FMT, long double);
#endif /* EPI_HAVE___FLOAT128 */
 if(devnull) fclose(devnull);
}

 /* EPI_MAX_OK_DECPT_FCVT_BASE10_EXPONENT:
  * the largest base-10 exponent a number can have
  * and still return an ok/valid decimal point value from fcvt():
  */
 fprintf(fh, "\n#undef  EPI_MAX_OK_DECPT_FCVT_BASE10_EXPONENT\n");
 /* this macro is just because `1e+MACRO' is unparseable WTF: */
 fprintf(fh, "#undef  EPI_MAX_OK_DECPT_FCVT_VAL\n");
#ifdef EPI_HAVE_FCVT
 {
   char         *p;
   int          decpt, sRet, e;
   double       val, pval;

   for (pval = 1, val = 1.1, e = 0;
        /* Stop at maxdoublebase10exp: Darwin can segfault past that: */
        e <= maxdoublebase10exp && val > pval;
        pval = val, val *= 10.0, e++)
     {
       p = fcvt(val, 3, &decpt, &sRet);
       /* decpt == e + 1, if no roundoff error (which we avoid with a
	* mantissa == 1.1, ie. > 1).
        * Under Linux 2.4.2, decpt <= 15 for e >= ~15 and a decimal appears:
        */
       if (decpt != e + 1) break;
     }
   e--;                                         /* last one was bad */
   fprintf(fh, "#define EPI_MAX_OK_DECPT_FCVT_BASE10_EXPONENT %d\n",e);
   fprintf(fh, "#define EPI_MAX_OK_DECPT_FCVT_VAL ((double)(1e+%d))\n",e);
 }
#endif /* EPI_HAVE_FCVT */

 /* KNG 20071102 these are based on assuming IEEE-754 floats/doubles: */
 fprintf(fh, "#undef  EPI_OS_FLOAT_MAX\n#undef  EPI_OS_FLOAT_MIN\n");
 if (f == 4)
   {
     fprintf(fh, "#define EPI_OS_FLOAT_MAX 3.40282346638528860e+38\n");
     fprintf(fh, "#define EPI_OS_FLOAT_MIN 1.40129846432481707e-45\n");
   }
 fprintf(fh, "#undef  EPI_OS_MAX_DOUBLE\n#undef  EPI_OS_MIN_DOUBLE\n");
 if (d == 8)
   {
     fprintf(fh, "#define EPI_OS_DOUBLE_MAX 1.79769313486231570e+308\n");
     fprintf(fh, "#define EPI_OS_DOUBLE_MIN 4.94065645841246544e-324\n");
     fprintf(fh, "typedef double EPI_FLOAT64;  /* 64-bit-total-size floating point type */\n");
     fprintf(fh, "#define EPI_FLOAT64PN ((EPI_FLOAT64 *)NULL)\n");
   }

 /* EPI_HUGEFLOAT, like EPI_HUGE[U]INT, may vary in size not only by
  * platform but also on the same platform, if a larger type is discovered
  * or supported.  Thus it should be for internal (non-disk/table) use only:
  */
 fprintf(fh,
         "\n"
         "#undef  EPI_HUGEFLOATPN\n"
         "#define EPI_HUGEFLOATPN ((EPI_HUGEFLOAT *)NULL)\n");
 fprintf(fh, "typedef %s EPI_HUGEFLOAT;\n", hugeFloatType);
 fprintf(fh, bitfmt, "HUGEFLOAT_MANTISSA", "HUGEFLOAT_MANTISSA",
         hugeFloatMantissaBits);
 fprintf(fh, bitfmt, "HUGEFLOAT_EXPONENT", "HUGEFLOAT_EXPONENT",
         hugeFloatExponentBits);
 fprintf(fh,
         "#undef  EPI_HUGEFLOAT_MAX_BASE10_EXPONENT\n"
         "#define EPI_HUGEFLOAT_MAX_BASE10_EXPONENT %d\n",
         hugeFloatMaxBase10Exponent);

 /* KNG 011109 TX_ALIGN_BYTES is in here for chkalign.c, and also so
  * that it is always an integer we can use in preprocessor land:
  */
 fprintf(fh, "\n#undef  TX_ALIGN_BYTES\n");
#if defined(_WIN32) && !defined(_WIN64)
 fprintf(fh, "/* for 32-bit Windows: */\n#define TX_ALIGN_BYTES  1\n");
 fprintf(fh, "typedef char TX_ALIGN_TYPE;\n");
#elif defined(__hpux) || defined(__DGUX__)      /* JMT 06-13-97 */
 fprintf(fh, "/* for HPUX/DGUX; see also ramdbf.h, 3dbindex.c: */\n");
 fprintf(fh, "#define TX_ALIGN_BYTES  8\n");
 fprintf(fh, "typedef EPI_INT64 TX_ALIGN_TYPE;\n");
#elif defined(__sgi)/* JMT 2003-01-14 */
 fprintf(fh, "/* for SGI; see also ramdbf.h: */\n");
 fprintf(fh, "#define TX_ALIGN_BYTES  %d\n", ot>sizeof(void*)?ot:sizeof(void*));
 fprintf(fh, "typedef %sTX_ALIGN_TYPE;\n",
         (ot > sizeof(void *) ?
          (ot == 4 ? "EPI_INT32 " : (ot == 8 ? "EPI_INT64 " : "off_t ")) :
          "void *"));
#else /* !(windows-32 || __hpux || __DGUX__ || __sgi) */
 fprintf(fh, "/* sizeof(void *): */\n");
 fprintf(fh, "#define TX_ALIGN_BYTES  %d\n", ptrByteSz);
 fprintf(fh, "typedef void *TX_ALIGN_TYPE;\n");
#endif /* !(windows-32 || __hpux || __DGUX__ || __sgi) */
 fprintf(fh, "#define TX_ALIGN_TYPEPN  ((TX_ALIGN_TYPE *)NULL)\n");

 fprintf(fh, "\n#undef  EPI_BIG_ENDIAN\n#undef  EPI_LITTLE_ENDIAN\n");
 if (sizeof(bits) == 4)
   {
     bits = 0x01234567;
     bp = (unsigned char *)&bits;
     if (bp[0] == 0x01 && bp[1] == 0x23 && bp[2] == 0x45 && bp[3] == 0x67)
       fprintf(fh, "#define EPI_BIG_ENDIAN 1\n");
     else if (bp[3] == 0x01 && bp[2] == 0x23 && bp[1] == 0x45 && bp[0] ==0x67)
       fprintf(fh, "#define EPI_LITTLE_ENDIAN 1\n");
   }
 else if (sizeof(bits) == 8)
   {
     bits = (int)0x0123456789abcdef;
     if (bp[0] == 0x01 && bp[1] == 0x23 && bp[2] == 0x45 && bp[3] == 0x67 &&
         bp[4] == 0x89 && bp[5] == 0xab && bp[6] == 0xcd && bp[7] == 0xef)
       fprintf(fh, "#define EPI_BIG_ENDIAN 1\n");
     else if (bp[7] == 0x01 && bp[6] == 0x23 && bp[5] == 0x45 && bp[4]==0x67&&
         bp[3] == 0x89 && bp[2] == 0xab && bp[1] == 0xcd && bp[0] == 0xef)
       fprintf(fh, "#define EPI_LITTLE_ENDIAN 1\n");
   }

 /* AIX returns EEXIST instead of ENOTEMPTY, and #define's ENOTEMPTY to be
  * EEXIST.  But it has a reserved strerror() for the real ENOTEMPTY.
  * Define EPI_ENOTEMPTY to that # if (ENOTEMPTY doesn't exist or is not what
  * we expect) and there is a strerror() that *is* what we expect:
  */
 fprintf(fh, "\n#undef  EPI_ENOTEMPTY\n");
#ifdef ENOTEMPTY
 if (strcmp(strerror(ENOTEMPTY), enotempty) != 0)
#endif /* ENOTEMPTY */
 for (j = 0; j < 1000; j++)
   if (strcmp(strerror(j), enotempty) == 0)
     {
       fprintf(fh, "#define EPI_ENOTEMPTY %d\n", j);
       break;
     }

 fprintf(fh, "\n#undef  EPI_SHARED_EXT\n#define EPI_SHARED_EXT \"" EPI_SHARED_EXT "\"\n");

 fprintf(fh, "\n#endif /* !SIZES_H */\n");

 fclose(fh);
 exit(0);
 return(0);
}
