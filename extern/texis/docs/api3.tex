%  JMT   Fixed declaration of closemmapi.  Was closeapicp
%
%\documentstyle[epiman,12pt]{book}
%\documentstyle[epitxt,12pt]{book}
%\begin{document}           % End of preamble and beginning of text.
%\tableofcontents
%\PART{The Metamorph API}
\chapter{Metamorph Application Program Interface Overview}
{\em ``Build the power of Metamorph into your application''}

Metamorph is the only REAL concept based text retrieval product on
the market today.  In its stand-alone form it acts as a research
assistant that provides its user with an easy query interface
while under the hood it is performing some of the most complex
text search techniques in the field.

{\em What is a Metamorph Search?}

Metamorph searches for some combination of ``lexical sets'' within
the bounds of two lexical delimiters.  The idea of using set logic
is very important to the way the software works.

When people communicate to each other they rarely use exactly the
same vocabulary when trying to communicate a common idea.
Typically, concepts are communicated by stringing combinations of
abstract meanings together to form a concise idea.  For example,
if you were trying communicate the idea of a ``nice person'' to
someone else you might use any of the following forms:

\begin{itemize}
\item nice guy
\item pleasing chap
\item agreeable character
\item excellent human being
\item exceptionally fine person
\end{itemize}

While there are subtle differences in each of these phrases, the
underlying concept is the same.  It is also worth noting that by
themselves the individual words in each phrase carry little
indication of the whole idea.  In a much larger sense, people
string these types of concepts to form heuristically larger and
more complex communications.  One ordering of heuristic
classifications might be as follows:

\begin{itemize}
\item morpheme   (a small token that can be built into a word)
\item word
\item phrase
\item clause
\item sentence
\item paragraph
\item chapter
\item book
\item collection
\end{itemize}

If you are searching for a concept within a body of text, you are
actually searching for an intersection in meaning of your idea of
what you are searching for with/and the body of information you
are searching.  Metamorph performs this search operation for you
automatically.

Within Metamorph if you perform the query:
{\em Are there power struggles in the Near East?}

Metamorph will find the individual ``important'' terms within your
query.  Then, it will look these terms up in a thesaurus that
contains over 250,000 associations and it will expand each term to
the set of things that mean approximately the same thing:
\begin{description}
\item[power]:  ability, jurisdiction, regency,
sovereignty, ascendency, justice, restraint, sway,
authority, kingship, scepter, electrify, carte
blanche, leadership, skill, clutches, majesty,
strength, command, mastership, suction, control,
mastery, superiority, domination, militarism,
supremacy, dominion, monarchy, vigor, efficiency,
nuclear, fission, weight, electricity, omnipotence,
acquisition, energy, persuasiveness, capability,
force, potency, faculty, hegemony, predominance,
function, imperialism, preponderance, might,
influence, pressure, reign,

\item[struggle]:  battle, contest, combat, flounder,
competition, strive, conflict, effort, exertion,
experience, fight, scuffle, strife, attempt, cash,
endeavor, flight, oppose, agonize, compete

\item[Near East]:  Israel, Jordan, Lebanon, Saudi Arabia,
Syria, Turkey, Kuwait, Iran, Iraq
\end{description}
After it has built these sets, it will search through the text you
have designated for a place in the text that has all three of the
concepts present within some defined boundary (i.e.; sentence,
line, paragraph, page, chapter, etc.).  So, if it was instructed
to search by sentence it would be able to retrieve the following:

{\em Iraq's Sadam Hussein is being pressured by the U.N. to suspend his
endeavors to annex Kuwait.}

Please Note that Metamorph recognizes that ``Near East'' is a phrase
that means the countries in the Near East and not the concepts of
``near'' and ``east'' individually.  Also, it is not only looking for
each of the words in the lists, but it is also looking for every
word-form of the words in each of the lists.

% ============================================================================
\section{Technical Description}

Within Metamorph a ``set'' can be any one of four different types of
text data:

\begin{itemize}
\item
The set of words or phrases that mean the same thing.
\item
The set of text patterns that match a regular-expression.
\item
The set of text patterns that are approximately the same.
\item
The set of quantities that are within some range.
\end{itemize}

There are three types of operations that can be used in
conjunction with any set:

\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxx\= xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx \kill
INCLUSION             \> The set must be present.                 \\
EXCLUSION             \> The set must not be present.             \\
PERMUTATION           \> X out of Y sets must be present.         \\
\end{tabbing}

The set logic operations are performed within two boundaries:

\begin{itemize}
\item
A starting delimiter (e.g.; the beginning of a sentence).
\item
An ending  delimiter (e.g,; the end of a sentence).
\end{itemize}

Each type of set plays an important role in the real-world use of
a text retrieval tool:
\begin{itemize}
\item
The word-list pattern matcher can locate any word
form of an entire list of English words and/or
phrases.
\item
The regular-expression pattern matcher allows the
user to search for things like dates, part numbers,
social security numbers, and product codes.
\item
The approximate pattern matcher can search for
things like misspellings, typos, and names or
addresses that are similar.
\item
The numeric/quantity pattern matcher can look for
numeric values that are present in the text in
almost any form and allows the user to search for
them generically by their value.
\end{itemize}

The Metamorph search engine will always optimize the search
operations performed so that it will minimize the amount of CPU
utilization and maximize the throughput search rate.  At the heart
of the Metamorph search engine lie seven of the most efficient
pattern matchers there are for locating items within text.  With
the exception of the Approximate Pattern Matcher, all of these
pattern matchers use a proprietary algorithmic technique that is
guaranteed to out-perform any other published pattern matching
algorithm (including those described by Boyer-Moore-Gosper and
Knuth-Pratt-Morris).

Providing the user with set-logic to manipulate combinations of
these set-types gives them the ability to search for just about
anything that they might want to find in their textual
information.  The query tool in general can be as simple or
sophisticated as the user wishes, with the simplest query being a
simple natural-language question.

% ============================================================================
\section{Some Search Examples and Explanations}

Example 1:

Let's say that we want to search for any occurrence of An Intel
80X86 processor on the same line with the concept of ``speed'' or
``benchmark'' as long as the string ``Motorola'' is not present.

The query is: \verb2+/80=[1-4]?86  -/motorola speed benchmark2

Explanation:

A leading \verb`'+'` means ``this must be present''.

A leading \verb`'-'` means ``this must not be present''.

The \verb`'/'` signals the use of a regular-expression.

\verb`'/80=[1-4]?86'` will locate an \verb`'80'` followed by an optional \verb`('1' or
'2' or '3' or '4')` followed by an \verb`'86'`.  This will locate:  \verb`8086,
80186, 80286, 80386 or 80486.`

\verb`'/motorola'` will locate \verb`'MOTOROLA'` or \verb`'Motorola'` or \verb`'motorola'` (or
any other combination of alphabetic cases).

\verb`'speed'` will locate any word that means ``speed''.

\verb`'benchmark'`  will locate any word that means ``benchmark''.

The beginning and ending delimiting expressions would be defined
as \verb`'\n'` (meaning a new-line character).

The Metamorph search engine will now optimize this search and will
perform the following actions:

\begin{description}
\item [A:]  Search for any pattern that matches \verb`'/80=[1-4]?86'`.
When it is located do item (B).
\item [B:]  Search backwards for the start delimiter \verb`'\n'` (or begin of
file/record whichever comes first).
\item [C:]  Search forwards for the ending delimiter \verb`'\n'` (or end of
file/record whichever comes first).
\item [D:]  Search for the pattern \verb`'/motorola'` between the start and end
delimiters.  If it is {\em not} located do item (E), otherwise go
to item (A).
\item [E:]  Search for the set of words that mean ``benchmark''.  If a
member is located do item (G), otherwise, do item (F).
\item [F:]  Search for the set of words that mean ``speed''.  If a
member is located do item (G), otherwise, go to item (A).
\item [G:]  Inform the user that a hit has been located.
\end{description}

Example 2:

Let's say we are searching an address and phone number list trying
to find an entry for a person whose name has been apparently
entered incorrectly.

The query: \verb`"%60 Jane Plaxton"  "%60 234 rhoads dr."  /OH  /49004`

Because our database is large, we want to enter as much as
possible about what we know about Ms. Plaxton so that we decrease
the number of erroneous hits.  The actual address in our database
looks as follows:

\begin{verbatim}
Jane Plxaton
243 Roads Dr.
Middle Town OH 49004
\end{verbatim}

This is a little exaggerated for reasons of clarity, but what has
happened is that the data-entry operator has transposed the 'x'
and the 'a' in 'Plaxton' as well as the '4' and '3' and has also
misspelled 'Rhodes'.

The query we performed has four sets:

\begin{tabbing}
xxxxxxxxxxxxxxxxxxxxxxxx \= xxxxxxxxxxxxxxxxxxxxx \kill
A 60\% approximation of:   \> "Jane Plaxton"       \\
A 60\% approximation of:   \> "234 rhoads dr."     \\
The state string      :   \> OH                   \\
The zip code string   :   \> 49004                \\
\end{tabbing}

The database records are separated by a blank line, therefore our
start and end delimiters will be \verb`'\n\n'` (two new-line characters).

The Approximate pattern matcher will be looking for the name and
street address information and will match anything that comes
within 60% of each of those strings.  (The approximate pattern
matcher will default to 80% if no percentage is specified.)  The
regular-expression pattern matcher will be looking for the state
and zip-code strings.  We are searching for three intersections of
the four sets (this is the default action).

Example 3:

We are reading the electronic version of the Wall Street Journal
and we are interested in locating any occurrence of profits and/or
losses that amount to more than a million dollars.

The query:   \verb`+#>1,000,000  +dollar @0 profit loss gain`

The \verb`'+'` symbol in front of the first two terms indicates that they
must be present in the hit.  The \verb`'@0`' tells Metamorph to find zero
intersections of the following sets.  Put another way, only one of
the remaining sets needs to be located.

The sets:
\begin{itemize}
\item Mandatory (because of the \verb`'+'` symbol):
    \begin{itemize}
    \item Any quantity in the text that is greater than one million.
    \item Any word (or string) that means ``dollar''.
    \end{itemize}
\item Permutation (because of the \verb`'@0'`):
    \begin{itemize}
    \item Anything that means ``profit''.
    \item Anything that means ``loss''.
    \item Anything that means ``gain''.
    \end{itemize}
\end{itemize}

We would probably define the delimiters to be either a sentence or
a paragraph.

The following would qualify as hits to this query:
\begin{itemize}
\item
Congress has spent 2.5 billion dollars on the
stealth bomber.
\item
Lockheed Corp. has taken a four million dollar
contract from Boeing.
\item
The Lottery income from John Q. Public last week
was One Million Two Hundred and Fifty Thousand
dollars and twenty five cents.
\end{itemize}

% ============================================================================
\section{Potential Applications}

The nature of our API makes it possible to use Metamorph as a
generic text searching tool no matter where the text resides.
Given the quantity of text that exists on most computers the
potential variants are boundless, but here are some ideas:

\begin{itemize}
\item A method of searching the text field information in databases
 (relational or otherwise).

\item Document management and control systems.

\item Document/record classification systems.

\item Real time text analysis.

\item E-Mail services.

\item Image classification/retrieval databases.

\item Message traffic management.

\item Educational/instructional aids.

\item Executive information systems.

\item Research analysis tools.
\end{itemize}

\chapter{The Programmers' Interface Overview}

There are thousands of stand-alone Metamorph programs in the field
today, and over time we have received many requests by application
developers who would like to be able to embed our searching
technology inside their particular application.  It has taken us a
long time to figure out how to provide a simple and clean method
to provide a solution to their problems.  We have tried to make it
as easy as possible while providing the maximum power and
flexibility.

All of the code that comprises Metamorph has been written in ANSI
compliant 'C' Language.  The source code to the API (only) is
provided to the programmer for reference and modification.
Metamorph has currently been compiled and tested on 22 different
UNIX platforms, MS-DOS, and IBM MVS. The API can be ported by
Thunderstone to almost any Machine/OS that has an ANSI compliant
'C' compiler.

The set of calls in the API are structured in a fashion similar to
\verb`fopen(), fclose(), ftell()`, and \verb`gets()`, standard library
functions.  And just like you can have multiple files open at the
same time, you can open as many simultaneous Metamorph queries as
needed.  (One reason you might do this is to have a different
search in effect for two different fields of the same record.)

The API itself allows the software engineer to conduct a Metamorph
search through any buffer or file that might contain text.  There
are two data structures that are directly involved with the API:

\begin{verbatim}
APICP     /* this structure contains all the control parameters */
MMAPI       /* this structure is passed around to the API calls */
\end{verbatim}

The APICP structure contains all the default parameters required
by the API.  It is separate from the MMAPI structure so that its
contents can be easily manipulated by the developer.  An APICP
contains the following information:
\begin{itemize}
\item A flag telling Metamorph to do suffix processing
\item A flag telling it do prefix processing
\item A flag that says whether or not to perform word derivations
\item The minimum size a word may be processed down to
\item The list of suffixes to use in suffix processing
\item The list of prefixes to use in prefix processing
\item A start delimiter expression
\item An end delimiter expression
\item A flag indicating to include the starting delimiter in the hit
\item A flag indicating to include the ending delimiter in the hit
\item A list of high frequency words/phrases to ignore
\item The default names of the Thesaurus files
\item Two optional, user-written, Thesaurus list editing functions
\item The list of suffixes to use in equivs lookup
\item A flag indicating to look for the within operator (w/)
\item A flag indicating to lookup see references
\item A flag indicating to keep equivalences
\item A flag indicating to keep noise words
\item A user data pointer
\end{itemize}

Usually the developer will have no need to modify the contents of
this structure more than one time to tailor it to their
application, but in some applications it will be very desirable to
be able to modify its contents dynamically.  Two calls are
provided that handle the manipulation of this structure:


\begin{verbatim}
APICP * openapicp(void)             /* returns an APICP pointer */

APICP * closeapicp(APICP *cp)  /* always returns a NULL pointer */
\end{verbatim}

The \verb`openapicp()` function creates a structure that contains a set
of default parameters and then returns a pointer to it.  The
\verb`closapicp()` function cleans up and releases the memory allocated
by the \verb`openapicp()` function.  Between these two calls the
application developer may modify any of the contents of the APICP
structure.

There are five function calls that are associated with the actual
API retrieval function; they are as follows:

\begin{verbatim}
MMAPI *openmmapi(char *query,APICP *cp)

int   setmmapi(MMAPI *mm,char *query)

char  *getmmapi(MMAPI *mm, char *buf, char *endofbuf, int operation)

int   infommapi(MMAPI *mm, int index, char **what, char **where,
                int *size)

MMAPI *closemmapi(MMAPI *mm)
\end{verbatim}

The \verb`openmmapi()` function takes the set of default parameters from
the APICP structure and builds an MMAPI structure that is ready to
be manipulated by the other four functions.  It returns a pointer
to this structure.

The \verb`setmmapi()` function is passed a standard Metamorph query (see
examples) and does all the processing required to get the API
ready to perform a search that will match the query.  If the
application program wishes to, it can define a function that will
be called by the \verb`setmmapi()` function to perform editing of the
word lists and query items before the initialization is completed
(this is not required).

The \verb`getmmapi()` function performs the actual search of the data.
All that is required is to pass the \verb`getmmapi()` function the
beginning and ending locations of the data to be searched.  There
are two operations that may be performed with the \verb`getmmapi()` call;
\verb`SEARCHNEWBUF` and \verb`CONTINUESEARCH`.  Because there may be multiple
hits within a single buffer, the \verb`search-new-buf` command tells the
API to locate the first hit, and then by using successive calls
with the command \verb`continue-search` you will locate all the remaining
hits in the buffer.

The \verb`infommapi()` function returns information about a hit to the
caller; it will give the following information:
\begin{itemize}
 \item Where the hit is located within the buffer.
 \item The overall length of the hit.
 \item For each set in the search that was matched:
     \begin{enumerate}
     \item The query set searched for and located.
     \item The location of the set item.
     \item The length of the set item.
     \end{enumerate}
 \item The location and length of the start and end delimiters.
\end{itemize}

The \verb`closemmapi()` function cleans up and releases the memory
allocated by the \verb`openmmapi()` call.

The last of the important calls in the API is the function that
reads data in from files.  While your application may not require
this function, if files are being read in as text streams the use
of this function is mandated.

\begin{verbatim}
int rdmmapi(char *buf,int n,FILE *fh,MMAPI *mm)
\end{verbatim}

This function works very much like \verb`fread()` with one important
exception; it guarantees that a hit will not be broken across a
buffer boundary.  The way it works is as follows:
\begin{itemize}
\item A normal \verb`fread(`) for the number of requested bytes is performed.

\item \verb`rdmmapi()` searches backwards from the end of the buffer for an
occurrence of the ending delimiter regular-expression.

\item The data that is beyond the last occurrence of an ending
delimiter is pushed back into the input stream.  (The method
that is used depends on whether an \verb`fseek()` can be performed or
not.)
\end{itemize}

% ============================================================================
\section{The Metamorph 3 API Package}

The Metamorph 3 API package consists of the following files:

\begin{verbatim}
api3.doc   - this documentation
lapi3.lib  - MS-DOS, for Microsoft 'C' large model
             library containing all api functions
libapi3.a  - Unix library containing all api functions
api3.h     - header to be included by any program using Metamorph 3 api
api3i.h    - header automatically included by api3.h
mmsg.h     - header automatically included by api3.h
api3.c     - source code to the top level api calls
apimmsg.c  - source code to the default message handler
mmex1.c    - example source implementing a text search interface
mmex2.c    - example source implementing a database search interface
mmex2.dat  - example database for mmex2.c
readme.doc - system specific and installation notes
\end{verbatim}

The Metamorph 3 API uses bytes and strings of bytes for most of
its character manipulations.  ``Byte'' is defined, in the API
header, as an unsigned 8 bit quantity (unsigned char) and is used
to allow greater latitude in string contents.

All byte pointers are normal \verb`'C'` strings (pointer to an array of
bytes, terminated by \verb`'\0'`).

All byte pointer lists are arrays of pointers to normal \verb`'C'`
strings.  Each list is terminated with an empty string
\verb`((byte *)"")`.

{\bf WARNING: }  All APICP strings, string list members, and pointer arrays
will be freed by \verb`closeapicp` if they are \verb`!=NULL`.  This
includes the terminator \verb`("")` in string lists.

The Metamorph API provides the following functions:

\begin{verbatim}
closeapicp() - control parameters interface
closemmapi() - cleanup
closemmsg()  - close the message file
fixmmsgfh()  - message control
getmmapi()   - search routine
infommapi()  - hit information
openapicp()  - control parameters interface
openmmapi()  - initialization
putmsg()     - message handler
rdmmapi()    - synchronized read
setmmapi()   - reinitialization
\end{verbatim}

The minimum set of function calls you will use is:

\begin{verbatim}
closeapicp()
closemmapi()
getmmapi()
openapicp()
openmmapi()
\end{verbatim}

The Metamorph 3 API needs 3K of stack space in addition to
whatever the calling program uses.

\chapter{Metamorph 3 API functions}

\NAME{openapicp, closeapicp - Metamorph API control parameters interface}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include "api3.h"

APICP * openapicp(void)

APICP * closeapicp(cp)
APICP * cp;

\end{verbatim}

\DESCRIPTION

\verb`Openapicp` returns a pointer to a structure that contains all of
the default parameters needed by the Metamorph API.  Each of the
members of the structure are initialized in a manner that will
allow for simple modification of its contents by the calling
program.  \verb`Closeapicp` frees all the memory allocated by \verb`openapicp`
and returns an \verb`APICP *)NULL`.

The following describes how to modify each of the variable types
within the \verb`APICP` structure:

\begin{verbatim}
(byte)    : Direct assignment
            eg:  cp->suffixproc=(byte)1;

(int)     : Direct assignment
            eg: cp->minwordlen=2;

(byte *)  : Free original pointer and assign new allocated pointer
            eg: free(cp->sdexp);
                cp->sdexp=(byte *)malloc(strlen("string")+1);
                strcpy(cp->sdexp,"string");

(byte **) : Free original pointers and assign new allocated pointers
            eg: #define MYLISTSZ 3
                static char *mylist[MYLISTSZ]={"new","list",""};
                int i;
                for(i=0;*cp->noise[i]!='\0';i++)
                     free(cp->noise[i]);
                free(cp->noise[i]);     /* free empty string at end */
                free(cp->noise);          /* free the array pointer */
                cp->noise=(byte **)calloc(MYLISTSZ,sizeof(byte *));
                for(i=0;i<MYLISTSZ;i++)
                     {
                      cp->noise[i]=(byte *)malloc(strlen(mylist[i])+1);
                      strcpy(cp->noise[i],mylist[i]);
                     }

int (*)() : Direct assignment
            eg:   cp->eqedit=myeditfunction;

\end{verbatim}


{\bf WARNING:}  The \verb`closeapicp()` will free all variable pointers.  Do
not assign static data pointers or attempt to free any
pointers placed in the \verb`APICP` structure.

% ============================================================================
\section{APICP Variable Definitions}

The following fields are defined in the \verb`APICP` structure:

\begin{itemize}
  \item \verb`suffixproc` \\
    Do suffix stripping processing
  \item \verb`prefixproc` \\
    Do prefix stripping processing
  \item \verb`rebuild` \\
    Perform the morpheme rebuild check
  \item \verb`incsd` \\
    Include the start delimiter in the hit
  \item \verb`inced` \\
    Include the end delimiter in the hit
  \item \verb`withinproc` \\
    Look for within operator (\verb`w/..`)
  \item \verb`suffixrev` \\
    Internal Thunderstone use: Strings in suffix list are reversed
  \item \verb`minwordlen` \\
    Minimum remaining length of a pre/suffix stripped word
  \item \verb`intersects` \\
    Number of intersections to be located in the hit
  \item \verb`sdexp` \\
    The start delimiter expression
  \item \verb`edexp` \\
    The end delimiter expression
  \item \verb`query` \\
    Query from user
  \item \verb`set` \\
    Array of sets of things being searched for, in equiv format;
    sets are in original query order
  \item \verb`suffix` \\
    The list of suffixes
  \item \verb`suffixeq` \\
    The list of suffixes for equivalence lookup
  \item \verb`prefix` \\
    The list of prefixes
  \item \verb`noise` \\
    The list of words that constitute ``noise''
  \item \verb`eqprefix` \\
    The Path-filename of the main equiv file
  \item \verb`ueqprefix` \\
    The Path-filename of the user equiv file
  \item \verb`see` \\
    Lookup ``see also'' references
  \item \verb`keepeqvs` \\
    Keep equivalences
  \item \verb`keepnoise` \\
    Keep noise words
  \item \verb`eqedit` \\
    A user programmable equiv edit function
  \item \verb`eqedit2` \\
    A user programmable equiv edit function
% WTF document these:
%  \item \verb`database` \\
%  \item \verb`lowtime` \\
%  \item \verb`hightime` \\
%  \item \verb`filespec` \\
%  \item \verb`enablemm` \\
%  \item \verb`buflen` \\
%  \item \verb`worddef` \\
%  \item \verb`blockdelim` \\
%  \item \verb`blocksz` \\
%  \item \verb`blockmax` \\
%  \item \verb`maxsimult` \\
%  \item \verb`adminmsgs` \\
%  \item \verb`allow` \\
%  \item \verb`ignore` \\
%  \item \verb`maxselect` \\
%  \item \verb`profile` \\
%  \item \verb`usr` \\
    A user settable data pointer
  \item \verb`denymode` \\
    \verb`API3DENY`... mode: how to deny query-protection-forbidden actions
  \item \verb`al...` \\
    Flags for allowing/denying query-protection actions
  \item \verb`qmin`..., \verb`qmax`... \\
    Query-protection limits
  \item \verb`defsuffrm` \\
    Whether to remove a trailing vowel, or one of a trailing double
    consonant pair, after normal suffix processing, and if the word is
    still \verb`minwordlen` or greater.  This only has effect if
    suffix processing is enabled (\verb`suffixproc` on and the
    original word is at least \verb`minwordlen` long)
  \item \verb`reqsdelim` \\
    Flag indicating start delimiter must be present
  \item \verb`reqedelim` \\
    Flag indicating end delimiter must be present
  \item \verb`olddelim` \\
    Flag indicating old delimiter behavior should be used
  \item \verb`withincount` \\
    Value of integer \verb`N` if within operator was ``\verb`w/N`''
  \item \verb`phrasewordproc` \\
    Phrase word processing mode (\verb`API3PHRASEWORD`... value)
  \item \verb`textsearchmode` \\
    The \verb`TXCFF` mode for text searches
  \item \verb`stringcomparemode` \\
    The \verb`TXCFF` mode for string comparisons
  \item \verb`setqoffs` \\
    List of offsets into original user query, corresponding to \verb`set`s
  \item \verb`setqlens` \\
    List of lengths in original user query, corresponding to \verb`set`s
  \item \verb`originalPrefixes` \\
    List of set-logic, tilde, open-parenthesis, pattern-matcher
    character prefixes in original query, corresponding to
    \verb`set`s; NULL-terminated
  \item \verb`sourceExprLsts` \\
    Each \verb`sourceExprLists` item corresponds to a \verb`set` item,
    and is a list of source expressions/terms (before equivalence
    etc. processing) from original query for that set; NULL-terminated
\end{itemize}

{\bf NOTE: }  See Metamorph chapter \ref{chp:mmling} for detailed descriptions of
what many of these variables do.

% ============================================================================
\section{Application Notes}

Generally speaking, the user program will have little need to
modify the contents of the \verb`APICP` structure returned by
\verb`openapicp()`.  If the user wishes to permanently modify one or more
of the default parameters it is far easier to directly edit and
recompile the \verb`api3.c` file.

The user \verb`eqedit` and \verb`eqedit2` functions are intended for those
applications that wish to process the results of the command
line/thesaurus lookup process before the remainder of the
\verb`open/setmmapi()` processing occurs.  This has a similar role to the
\verb```EDIT''` knob inside the Metamorph user interface.  For more
information see the \verb`openmmapi()` and \verb`setmmapi()` documentation.

\NAME
{openmmapi, closemmapi - Metamorph API initialization and cleanup}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include "api3.h"

MMAPI * openmmapi(query,cp)
char  * query;
APICP * cp;

MMAPI * closemmapi(mm)
MMAPI * mm;

\end{verbatim}

\DESCRIPTION

\verb`Openmmapi` performs the initialization required to perform a
Metamorph query. It returns a pointer to a structure that will be
required by the \verb`getmmapi, setmmapi,` and \verb`closemmapi` functions.

\verb`Openmmapi` requires two parameters.  The first parameter is the
user's query.  The query is a \verb`'\0'` terminated string which has
exactly the same syntax as a query would have within the Metamorph
User Interface with the exception that there is no macro facility.
Internally \verb`openmmapi` calls \verb`setmmapi` if the query is not
\verb`(char *)NULL`.  If the query is \verb`(char *)NULL` it is up to the
programmer to call \verb`setmmapi` before calling \verb`getmmapi`.  The second
parameter is the \verb`APICP` pointer returned by a successful call
to \verb`openapicp()`.

\SEE
\begin{verbatim}
setmmapi(), openapicp()
\end{verbatim}

\NAME
{setmmapi - Metamorph API reinitialization}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include "api3.h"

MMAPI * setmmapi(mm,query)
MMAPI * mm;
char  * query;

\end{verbatim}

\DESCRIPTION

\verb`setmmapi()` takes a pointer to an open \verb`MMAPI` and a query string.
The query is a \verb`'\0'` terminated string which has exactly the same
syntax as a query would have within the Metamorph User Interface
with the exception that there is no macro facility.

The query will be parsed using the \verb`APICP` variables from the
\verb`openmmapi()` call, and following the rules described under ``Query
processing and Equivalence lookup''.

\verb`setmmapi()`, or \verb`openmmapi()` with a \verb`non-(char *)NULL` query, must be
called before making calls to \verb`getmmapi()`.

\DIAGNOSTICS
\verb`setmmapi()` returns the mm pointer passed if successful or \verb`MMAPIPN` if
there was an error.

\SEE
\verb`openmmapi()`

\NAME
{getmmapi - Metamorph API search routine}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include "api3.h"

char  * getmmapi(mm,buf_start,buf_end,operation)
MMAPI * mm;
char  * buf_start;
char  * buf_end;
int     operation;

\end{verbatim}

\DESCRIPTION

The \verb`getmmapi()` is passed the \verb`MMAPI *` returned by \verb`openmmapi()`
function and performs the actual search of the data pointed to by
the \verb`buf_start` and \verb`buf_end` pointers.  The operation parameter can
\verb`buf_end`.  Successive calls to getmmapi() with the operation
be one of two values:  \verb`SEARCHNEWBUF` or \verb`CONTINUESEARCH`. \verb`getmmapi()`
will return a \verb`(char *)NULL` if it does not locate a hit within the
buffer.  If a hit is located it will return a pointer to the
beginning of the hit.

If \verb`getmmapi()` is called with the operation parameter set to
\verb`SEARCHNEWBUF`, it will begin its search at \verb`buf_start` and search
through the buffer until it locates a hit or until it reaches
\verb`buf_end`.  Successive calls to \verb`getmmapi()` with the operation
parameter set to \verb`CONTINUESEARCH` will locate all remaining hits
within the bounds set by \verb`buf_start` and \verb`buf_end`.

Typically the sequence of events would look as follows:
\begin{verbatim}
{
 char *hit;
 char *my_buffer;
 int   my_buf_size;

 MMAPI *mm;

 ...

 for(hit=getmmapi(mm,my_buffer,my_buffer+my_buf_size,SEARCHNEWBUF);
     hit!=(char *)NULL;
     hit=getmmapi(mm,my_buffer,my_buffer+my_buf_size,CONTINUESEARCH)
    )
    {
     /* process the hit here */
    }
 ...

}

\end{verbatim}

\SEE
\begin{verbatim}
infommapi()
\end{verbatim}

\NAME
{infommapi - Metamorph API hit information}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include "api3.h"

int     infommapi(mm, index, what, where, size)
MMAPI  *mm;
int     index;
char  **what;
char  **where;
int    *size;

\end{verbatim}

\DESCRIPTION

After a hit has been located by the \verb`getmmapi()` function, the
calling program may get information about objects contained within
the hit by passing the \verb`MMAPI *` to the \verb`infommapi()` function.  This
call can provide the following information:
\begin{itemize}
\item Location and length of the entire hit.
\item Location and length of the start delimiter.
\item Location and length of the end delimiter.
\item For each set in the search that was matched:
  \begin{itemize}
  \item The query set searched for and located.
  \item The location of the set item.
  \item The length of the set item.
  \end{itemize}
\end{itemize}

The idea behind \verb`infommapi()` is to provide the caller with a
structured method for obtaining information about a hit that was
located with the \verb`getmmapi()` call.  The index parameter and the
return code are used to ``walk'' through the items that were
located.  Information about each item is placed into the variables
pointed to by the what, where and size parameters.  A return value
of \verb`-1` indicates a usage error, \verb`0` indicates that the index is out
of range, and \verb`1` indicates that the index was in range and the data
is valid.

Index values and what they return:
\begin{verbatim}
infommapi(mm, 0, &what, &where, &size)
what : Will be set to the query that was passed to the openmmapi()
       call.
where: Will point to the location of the hit within the buffer being
       searched.
size : Will be the overall length in bytes of the located hit.

infommapi(mm, 1, &what, &where, &size)
what : Will be set to the start delimiter expression in use.
where: Will point to the location of start delimiter.
size : Will be the overall length in bytes of the located delimiter.
       size will be 0 and where will be (char *)NULL if the hit is at
       the beginning of the buffer or immediately after the previous
       hit.

infommapi(mm, 2, &what, &where, &size)
what : Will be set to the end delimiter expression in use.
where: Will point to the location of end delimiter.
size : Will be the overall length in bytes of the located delimiter.
       size will be 0 and where will be (char *)NULL if the hit is at
       the end of the search buffer and no end delimiter was found in
       the buffer.

infommapi(mm, [3...n], &what, &where, &size)
what : Will point to the first "set" being searched for;

set type    what points to
--------    --------------------------
REX         A regular expression
NPM         The npm query expression
PPM         The root word of the list of words
XPM         The "approximate" string

where: Will point to the buffer location of the set-element.
size : Will be the overall length in bytes of the located set-element.

\end{verbatim}

\EXAMPLE
\begin{verbatim}
{
 MMAPI  *mm;
 char   *what, *where;
 int    size, index;

 ...

  for (index = 0;
       infommapi(mm, index, &what, &where, &size) == 1;
       index++)
      {
       switch (index)
           {
            case 0 :
               printf("The Query: %s\n", what);
               printf("The hit  :");
               for( ; size > 0; size--, where++) putchar(*where);
               putchar('\n');
               break;
            case 1 :
               printf("The start delimiter expression: %s\n", what);
               printf("The start delimiter located   :");
               for( ; size > 0; size--, where++) putchar(*where);
               putchar('\n');
               break;
            case 2 :
               printf("The end delimiter expression: %s\n", what);
               printf("The end delimiter located   :");
               for( ; size > 0; size--, where++) putchar(*where);
               putchar('\n');
               break;
            default:
               printf("set %d expression: %s\n", index - 2, what);
               printf("The set located  :");
               for( ; size > 0; size--, where++) putchar(*where);
               putchar('\n');
               break;
           }
      }
 ...

}

\end{verbatim}

\SEE
\begin{verbatim}
getmmapi()
\end{verbatim}

\NAME
{rdmmapi - synchronized read}

\SYNOPSIS
\begin{verbatim}
int    rdmmapi(buf,bufsize,fp,mp)
char  *buf;
int    bufsize;
FILE  *fp;
MMAPI *mp;

bool freadex_strip8;

\end{verbatim}

\DESCRIPTION
\begin{verbatim}
buf            where to put the data
bufsize        the maximum number of bytes that will fit in buf
fp             the file to read from which must be opened binary ("rb")
mp             the Metamorph 3 API to synchronize for

freadex_strip8 controls whether the high bit will be stripped from
               incoming data
\end{verbatim}

This function works very much like \verb`fread()` with one important
exception; it guarantees that a hit will not be broken across a
buffer boundary.  The way it works is as follows:
\begin{enumerate}
\item A normal \verb`fread()` for the number of requested bytes is performed.

\item \verb`rdmmapi()` searches backwards from the end of the buffer for
an occurrence of the ending delimiter regular expression.

\item The data that is beyond the last occurrence of an ending delimiter
is pushed back into the input stream. (The method that is used
depends on whether an \verb`fseek()` can be performed or not.)
\end{enumerate}

If the \verb`freadex_strip8` global variable is non-zero the 8th bit will
be stripped off all of the incoming data.  This is useful for
reading WordStar(C) and other files that set the high bit.
Setting \verb`freadex_strip8` incurs a speed penalty because every byte
read gets stripped.  Don't use this flag unless it is absolutely
necessary.

\verb`rdmmapi()` should be used any time you are doing delimited
searches.  An unsynchronized read can cause hits to be missed.

\DIAGNOSTICS

\verb`rdmmapi()` returns the number of bytes actually read into \verb`buf` or
\verb`(-1)` if there was an error.

\NAME
{putmsg    - handle a formatted message
mmsgfh    - FILE pointer for output
mmsgfname - filename for output}

\SYNOPSIS
\begin{verbatim}
#include <stdio.h>
#include ``api3.h''
#include ``mmsg.h''
#include ``cgi.h''

int  putmsg(msgn,fn,fmt,...)
int  msgn;
char *fn;
char *fmt;

FILE *mmsgfh;
char *mmsgfname;

\end{verbatim}

\DESCRIPTION
\begin{verbatim}
msgn  is the number of the message or (-1).
fn    is the name of the function issuing the message or (char *)NULL.
fmt   is the htpf() format (similar to printf() but extended).
...   is the argument list for fmt if necessary.
\end{verbatim}

These functions handle all output from the Metamorph API.  The API
reports its status periodically at points of interest.  Each
message has a number associated with it that indicates what type
of message it is.  Left alone the Metamorph API will generate
message file output just like the Metamorph 3 product.

Messages consist of four basic parts:
\begin{enumerate}
\item the message number followed by a space
\item the text of the message
\item the name of the function issuing the message
\item a newline.
\end{enumerate}

Message numbers are broken into various levels or types.  The levels
are grouped in hundreds.  The levels are:
\begin{verbatim}
000-099  messages indicate total failure of the process
100-199  messages indicate potential failure or hazard to the process
200-299  messages are informative messages on the operation of a process
300-399  messages are hit information coming from a Metamorph 3 engine
400-499  messages are non-error messages coming from a mindex engine
500-599  messages about query/hit logic
600-699  query information/debugging info
700-999  undefined as yet (reserved)

\end{verbatim}

{\bf Output formatting:}

\verb`putmsg()` will output msgn formatted with \verb`%03d` if \verb`msgn!=(-1)`,
followed by the results of fmt and its arguments if
\verb`fmt!=(char *)NULL`, followed by fn formatted with ``in the
function:  \verb`%s`'' if \verb`fn!=(char *)NULL`, followed by a newline.  The
output buffer is flushed to disk after every message so that any
process reading the message file will always be able to get the
latest messages.

{\bf Summary of formatting control:}
\begin{verbatim}
to suppress msgn : pass -1
to suppress fn   : pass (char *)NULL
to suppress fmt  : pass (char *)NULL

\end{verbatim}

{\bf Output destination:}

\verb`mmsgfh` and \verb`mmsgfname` control where \verb`putmsg(`) will send its output.
Each time \verb`putmsg()` or \verb`datamsg()` is called they will attempt to
make \verb`mmsgfh` point to a legal file, named by \verb`mmsgfname`, and send
their output there.  Setting \verb`mmsgfh` is accomplished by the
function \verb`fixmmsgfh()` (See \verb```putmsg()` extensions'').  How it works is
described below.

If \verb`mmsgfh` becomes \verb`(FILE *)NULL` or the name pointed to by \verb`mmsgfname`
changes \verb`mmsgfh` will be closed, if it was not \verb`(FILE *)NULL`, and
reopened for binary append with the new \verb`mmsgfname`.  If the open
fails \verb`mmsgfname` will be set to point to \verb`""`,the empty string,
\verb`mmsgfh` will be set to \verb`stderr`, and a warning message will be be
issued via \verb`putmsg()`.  Only the first 127 characters in \verb`mmsgfname`
will be remembered between calls, so changes beyond that point
will not be noticed.

If you want to set \verb`mmsgfh` yourself and not have it changed set
\verb`mmsgfname` to \verb`(char *)NULL`.  This will preempt the checks
described above. \verb`mmsgfh` will, however, be checked for \verb`(FILE *)NULL`
and will be reset to \verb`stderr` if it is.

The initial setting for \verb`mmsgfh` is (\verb`FILE *)NULL` and the initial
setting for \verb`mmsgfname` is \verb`(char *)NULL`.  This will, by default,
cause all output to go to \verb`stderr`.

\EXAMPLE
\begin{verbatim}
call:
   putmsg(MERR,"parse expression","invalid escapement");
output:
   000 invalid escapement in the function parse expression\n

call:
   putmsg(-1,"parse expression","invalid escapement");
output:
   invalid escapement in the function parse expression\n

call:
   char *filename="myfile";
   putmsg(MERR+FOE,(char *)NULL,"can't open file %s",filename);
output:
   002 can't open file myfile\n

\end{verbatim}


\DIAGNOSTICS

\verb`putmsg()` returns \verb`0` for success or \verb`-1` if there was an error writing
the output file.  If there was an error the standard library
variable errno may be checked for the reason.  The output file
will {\em not} be closed if there is an error.

\NOTES

\verb`putmsg()` may be overridden by writing your own function with the
same name, arguments and return value so that messages can be
handled in an application specific manner.

When \verb`putmsg()` outputs a newline it will be the correct type for
the host operating system (CRLF on MS-DOS, LF on Unix).


{\bf MS-DOS applications:}

MS-DOS does not allow real multi-tasking so the contents of the
message file will not become available to another program until
the message file is closed (this is an MS-DOS limitation).  To
read the message file while a search is in progress you must
access \verb`mmsgfh` directly.  If you move the \verb`mmsgfh` file position by
seeking, remember to reposition it to the end with
\verb`fseek(mmsgfh,0L,SEEK_SET)` before allowing the Metamorph 3 API to
continue.

\SEE
\begin{verbatim}
apimmsg.c, apimmsg.h for specific message numbers and their macros
putmsg() extensions
putmsg() replacement
\end{verbatim}

\NAME
{putmsg() extensions: fixmmsgfh, closemmsgfh}

\SYNOPSIS
\begin{verbatim}
void closemmsg(void)

void fixmmsgfh(void)

\end{verbatim}

\DESCRIPTION

These are some useful extensions to the \verb`putmsg()` family of
functions that provide more flexibility to programmers.  They are
not used directly by the Metamorph 3 API.

\verb`closemmsg()` closes the message file and should be called before
exiting any application that uses \verb`putmsg()` or the Metamorph 3 API.
It may also be called in the middle of an application to flush the
message file buffers to disk or force the message file to be
reopened on the next call to \verb`putmsg()`.  If mmsgfh is \verb`stderr`, it
will not be closed, but the next \verb`putmsg()` call will still force a
reopen.  It is safe to call \verb`closemmsg()` at any time because it
will not attempt to close a file that is already closed or has
never been opened.

\verb`fixmmsgfh()` is called by \verb`putmsg()` before any output is attempted.
It guarantees that \verb`mmsgfh` points somewhere legal based on
\verb`mmsgfname`.  See ``Output destination'' in the \verb`putmsg()` description.
\verb`fixmmsgfh()` will probably not be needed by API users because
\verb`putmsg()` supplies ample output functionality.

If you use any of these functions and replace \verb`putmsg()` you will
have to write your own replacements for the extensions.  All of
the \verb`putmsg()` functions are in the same object module within the
library.  Therefore, calling any one of the functions will cause
all of them to be brought in by the linker, which will then cause
a clash if you have your own version of \verb`putmsg()`.

\SEE
\begin{verbatim}
putmsg()
putmsg() replacement
\end{verbatim}

\NAME
{putmsg() replacement}

\DESCRIPTION

Normally all Metamorph 3 API output goes to \verb`stderr` or a disk file.
But, depending on your application, this may not be desirable.
You may wish to send all messages to a special alternate window
under a graphical environment or process the messages as they
occur and take immediate action based on the type of message.  You
may also want to filter the messages so that only errors and
warnings get displayed.  Whatever your reason, \verb`putmsg()` may be
replaced.

Since \verb`putmsg()` takes a variable number of arguments it must be
written using \verb`vararg`s or the ANSI \verb`stdarg`, if you prefer (see your
'C' manual).  Only the v\verb`arargs` method will be documented here.
The core is the same either way; the only variation is how you go
about getting the function arguments.

There are three arguments that are always present.  The first
argument is a message number of type \verb`(int)`.  The second argument
is a function name of type \verb`(char *)`.  The third argument is a
\verb`htpf()` format string of type \verb`(char *)`.  \verb`htpf()`
is a Thunderstone function similar to \verb`printf()`, but with extended
flags and codes: the \verb`fmt` argument should always be printed with
an \verb`htpf()`-family function and not \verb`printf()`-family because
some messages may utilize these extended flags and codes.
Any remaining arguments are as required by the \verb`htpf()` format string.

\verb`putmsg()` returns whether there was an error outputting the message
or not.  A return of \verb`0` means there was not an error.  A return of
\verb`non-0` means there was an error.

All of the macros needed for \verb`putmsg()` are in the header \verb`"mmsg.h"`.
\verb`"api3.h"` automatically \#include's \verb`"mmsg.h"`.  If you put \verb`putmsg()`
in its own source file just use \verb`"mmsg.h"`.  If you put \verb`putmsg()` in
the same file as Metamorph API calls or call the API from \verb`putmsg()`
use \verb`"api3.h"`.

\EXAMPLE
\begin{verbatim}
/*
** This implementation will *ONLY* output errors(MERR) and
** warnings(MWARN).
** It will output "ERROR:" or "WARNING:" instead of a message number.
** It will always send its output to stderr.
** Function names will not be printed.
*/

#include <stdio.h>
#include <varargs.h>        /* for variable argument list handling */
#include "mmsg.h"                                   /* or "api3.h" */
#include "cgi.h"                        /* for htvfpf()  prototype */

int
putmsg(va_alist)                    /* args: msgn,funcname,fmt,... */
va_dcl       /* no semicolon allowed! - just the way varargs works */
{
va_list args;       /* for variable argument list handling         */
int        n;       /* the message number (may be -1)              */
char     *fn;       /* the function name (may be NULL)             */
char    *fmt;       /* the htpf type format string (may be NULL) */
int level;                               /* message hundreds level */

                                        /* get the fixed arguments */
   va_start(args);      /* initialize variable argument list usage */
   n  =va_arg(args,int   );                      /* message number */
   fn =va_arg(args,char *);                      /* function name  */
   fmt=va_arg(args,char *);                      /* htpf format    */

   if(n>=0){                          /* is there a message number */
      level=n-(n%100);           /* clear the tens and ones places */
                                 /* to get the hundreds level      */
      if(level==MERR || level==MWARN){ /* only do error or warning */
         if(level==MERR) fputs("ERROR: "  ,stderr);
         else            fputs("WARNING: ",stderr);
         if(fmt!=(char *)NULL){           /* is there message text */
            htvfpf(stderr,fmt,args);  /* print the message content */
                                      /* using the varargs version */
                                      /* of htpf(): htvfpf()       */
         }
         fputc('\n',stderr);                 /* print the new line */
      }
   }
   va_end(args);         /* terminate variable argument list usage */
   return(0);                                         /* return OK */
}

\end{verbatim}

\NOTES

The \verb`putmsg()` extensions need not be replaced if you are not going
to use them because the API does not use them.  If you do use any
extensions you must also replace the ones that you use to avoid
linker clashes.

\SEE
\begin{verbatim}
putmsg()
apimmsg.c, mmsg.h
\end{verbatim}

% ============================================================================
\section {Query processing and Equivalence lookup}

Query processing and equivalence lookup occur in \verb`setmmapi()` and
\verb`openmmapi()` if \verb`query!=(byte *)NULL`.

Control query parsing and equivalence lookup with the following
APICP variables:

\begin{verbatim}
byte  *query
  : The user query interpret and get equivalences for.

byte  *eqprefix
  : The main equivalence file name.

byte  *ueqprefix
  : The user equivalence file name.

byte   see
  : Flag that says whether to lookup see references or not.

byte   keepeqvs
  : Flag that says whether to keep equivalences or not.

byte   keepnoise
 : Flag that says whether to keep noise words or not.

byte   withinproc
 : Flag that says whether to process the within operator (w/) or not.

byte   suffixproc
 : Flag that says whether to do suffix processing or not.

int    minwordlen
 : The smallest a word is allowed to get through suffix stripping.

byte **suffixeq
 : The list of suffixes.

byte **noise
 : The list of noise words.

int  (*eqedit)(APICP *)
 : Equivalence editor function.

int  (*eqedit2)(APICP *,EQVLST ***)
 : Equivalence editor function.

void  *usr
 : An arbitrary user data pointer.

\end{verbatim}

{\bf NOTE:}  Also see Metamorph chapter \ref{chp:mmling} for
further descriptions of these variables.
\begin{verbatim}
byte *query:
\end{verbatim}
query is a pointer to a Metamorph query.  This string typically
comes directly from user input, but may be constructed or
preprocessed by your program.  All rules of a Metamorph query
apply.
\begin{itemize}
\item REX patterns are prefixed by \verb`'/'`.
\item XPM patterns are prefixed by \verb`'%'`.
\item NPM patterns are prefixed by \verb`'#'`.
\item Required sets are prefixed by \verb`'+'`.
\item Exclusive sets are prefixed by \verb``'-'`.
\item Normal sets are prefixed by \verb`'='` or nothing.
\item Intersection quantities are prefixed by \verb`'@'`.
\item Equivalence lookup may be prevented/forced on an individual
word or phrase by prefixing it with \verb`'~'`.
\item Commas will be treated as whitespace except when part of a pattern
(REX, XPM, or NPM).
\item Phrases or patterns with spaces in them that should be treated
as a unit are surrounded by double quotes (\verb`'"'`).
\item Noise stripping is controlled by the keepnoise flag (see below).
\item Equivalence lookup may be completely turned off by setting eqprefix
to \verb`(byte *)NULL` (see below). Turning off equiv lookup does not
affect query parsing as described above.
\item New delimiters may be specified using the within operator (w/).
\end{itemize}

\begin{verbatim}
byte *eqprefix:
\end{verbatim}
This string contains the name of the main equivalence file.  This
typically includes the full path but may have a relative path or
no path at all.  The equivs may be relocated or even renamed.

Default \verb`eqprefix` \verb`"builtin"` which refers to a compiled in equiv
file.

This default may be permanently adjusted by changing the macro
\verb`API3EQPREFIX` in the \verb`api3.h` header file and recompiling \verb`api3.c` and
replacing the resultant object file in the library.

Equivalence lookup may be completely turned off by setting
\verb`eqprefix` to \verb`(byte *)NULL`.  Sometimes it is not appropriate to get
the associations from the equiv file or you may want to run your
application without the disk space overhead of the equiv file
which is very large (around 2 megabytes).  Turning off equiv
lookup does not affect query parsing as described previously.

\begin{verbatim}
byte *ueqprefix:
\end{verbatim}
This string contains the name of the user equivalence file.  This
typically includes the full path but may have a relative path or
no path at all.  The equivs may be relocated or even renamed.

Default \verb`ueqprefix` for Unix :\verb`"/usr/local/morph3/eqvsusr"`
Default \verb`ueqprefix` for MS-DOS:\verb`"c:\morph3\eqvsusr"`

This default may be permanently adjusted by changing the macro
\verb`API3UEQPREFIX` in the \verb`api3.h` header file and recompiling \verb`api3.c` and
replacing the resultant object file in the library.

Equivalences in the user equiv file edit and/or override those in
the main equiv file.

\begin{verbatim}
byte withinproc:
\end{verbatim}
Process the within operator \verb`(w/)`.  The within operator allows
changing the start and end delimiters from the query line.  The
argument of the within operator may be one of the built in names,
a number indicating character proximity, or a REX expression.  The
built in names are:

\begin{verbatim}
Name    Meaning     Expression
sent    Sentence    \verb`[^\digit\upper][.?!][\space'"]`
para    Paragraph   \verb`\x0a=\space+  `
line    Line        \verb`$`
page    Page        \verb`x0c`
\#      Proximity   \verb`.{,#}`(where \# is the number of characters)
\end{verbatim}

Any other string following the \verb`"w/"` is considered a REX
expression.  When using a REX expression with the within operator
both start and delimiters are set to the expression to set the end
delimiter to a different expression specify another within
operator and expression. e.g. \verb` "power w/tag:  w/$"` will set the
start delimiter to \verb`"tag:" ` and the end delimiter to \verb`"$"`.

By default both delimiters will be excluded from the hit when
using a REX with the within operator.  To specify inclusion use a
\verb`"W/"` instead of \verb`"w/"`.  You may specify different
inclusion/exclusion for the end delimiter without repeating the
expression if you wish to use the same expression for both.
Simply use the \verb`"W/"` or \verb`"w/"` by itself for the end delimiter. e.g.
\verb`"power w/$$ W/"` will set both delimiters to \verb`"$$"` but will exclude
the start delimiter and include the end delimiter.

The default value for \verb`withinproc` is \verb`1`. This default may be
adjusted by changing the macro \verb`API3WITHINPROC` in the \verb`api3.h` header
file and recompiling \verb`api3.c`.

See also the section ``Reprogramming the Within Operator''.

\begin{verbatim}
byte see:
\end{verbatim}
Lookup ``see'' references in the equiv file.  The equiv file has
``see'' references much as a dictionary or thesaurus has.  With this
flag off ``see'' references are left in the word list as is.  With
it on, those references will be looked up and their equiv lists
added to the list for the original word.  This can greatly
increase the number of equivs and abstraction for a given word.
This is not needed in most cases.

The default value for see is \verb`0`. This default may be adjusted by
changing the macro \verb`API3SEE` in the \verb`api3.h` header file and
recompiling \verb`api3.c`.

\begin{verbatim}
byte keepnoise:
\end{verbatim}
Keep noise words.  With this flag off any word in query, that is
not part of a larger phrase, that is also found in the noise array
will be removed from the list.

The default value for \verb`keepnoise` is \verb`1`. This default may be adjusted
by changing the macro \verb`API3KEEPNOISE` in the \verb`api3.h` header file and
recompiling \verb`api3.c`.

\begin{verbatim}
byte keepeqvs:
\end{verbatim}
Invert normal meaning of \verb`~` . With this flag on words will not
normally have equivs.  To get the equivs for a word use the \verb`~`
prefix.

The default value for \verb`keepeqvs` is \verb`1`. This default may be adjusted
by changing the macro \verb`API3KEEPEQVS` in the \verb`api3.h` header file and
recompiling \verb`api3.c`.

Setting \verb`keepeqvs` to\verb` 0` does not eliminate looking for the equiv
file.  See the \verb`eqprefix` variable for how to eliminate the equiv
file completely.

\begin{verbatim}
byte suffixproc:
\end{verbatim}
This is a flag that, if not set to \verb`0`, will cause the equiv lookup
process to strip suffixes from query words and words from the
equiv file to find the closest match if there is not an exact
match.  Words will not be stripped smaller than the \verb`minwordlen`
value (see below).  This flag has a similar effect on the search
process (see Metamorph section \ref{set:presuf}).

The default value for \verb`suffixproc` is \verb`1`. This default may be
adjusted by changing the macro \verb`API3SUFFIXPROC` in the \verb`api3.h` header
file and recompiling \verb`api3.c`.

\begin{verbatim}
byte **suffixeq:
\end{verbatim}
This is the list of word endings used by the suffix processor if
\verb`suffixproc` is on (see the description of lists).  The suffix
processor also has some permanent built in rules for stripping.
This is the default list:

\begin{verbatim}
'   s  ies
\end{verbatim}

The default may be changed by editing the \verb`suffixeq[]` array in the
function \verb`openapicp()` in the file \verb`api3.c` and recompiling.

\begin{verbatim}
int minwordlen:
\end{verbatim}
This only applies if \verb`suffixproc` is on.  It is the smallest that a
word is allowed to get before suffix stripping will stop and give
up.

The default value for \verb`minwordlen` is \verb`5`. This default may be
adjusted by changing the macro \verb`API3MINWORDLEN` in the \verb`api3.h` header
file and recompiling api3.c.  This flag has a similar effect on
the search process (see Metamorph section \ref{set:minwrdlen}).

\begin{verbatim}
byte **noise:
\end{verbatim}
This is the default noise list:

\begin{tabular}{llllll}
{\tt a }        & {\tt between }    & {\tt got }    & {\tt me }        & {\tt she }       & {\tt upon } \\
{\tt about }    & {\tt but }        & {\tt gotten } & {\tt mine }      & {\tt should }    & {\tt us } \\
{\tt after }    & {\tt by }         & {\tt had }    & {\tt more }      & {\tt so }        & {\tt very } \\
{\tt again }    & {\tt came }       & {\tt has }    & {\tt most }      & {\tt some }      & {\tt was } \\
{\tt ago }      & {\tt can }        & {\tt have }   & {\tt much }      & {\tt somebody }  & {\tt we } \\
{\tt all }      & {\tt cannot }     & {\tt having } & {\tt my }        & {\tt someone }   & {\tt went } \\
{\tt almost }   & {\tt come }       & {\tt he }     & {\tt myself }    & {\tt something } & {\tt were } \\
{\tt also }     & {\tt could }      & {\tt her }    & {\tt never }     & {\tt stand }     & {\tt what } \\
{\tt always }   & {\tt did }        & {\tt here }   & {\tt no }        & {\tt such }      & {\tt whatever } \\
{\tt am }       & {\tt do }         & {\tt him }    & {\tt none }      & {\tt sure }      & {\tt what's } \\
{\tt an }       & {\tt does }       & {\tt his }    & {\tt not }       & {\tt take }      & {\tt when } \\
{\tt and }      & {\tt doing }      & {\tt how }    & {\tt now }       & {\tt than }      & {\tt where } \\
{\tt another }  & {\tt done }       & {\tt i }      & {\tt of }        & {\tt that }      & {\tt whether } \\
{\tt any }      & {\tt down }       & {\tt if }     & {\tt off }       & {\tt the }       & {\tt which } \\
{\tt anybody }  & {\tt each }       & {\tt in }     & {\tt on }        & {\tt their }     & {\tt while } \\
{\tt anyhow }   & {\tt else }       & {\tt into }   & {\tt one }       & {\tt them }      & {\tt who } \\
{\tt anyone }   & {\tt even }       & {\tt is }     & {\tt onto }      & {\tt then }      & {\tt whoever } \\
{\tt anything } & {\tt ever }       & {\tt isn't }  & {\tt or }        & {\tt there }     & {\tt whom } \\
{\tt anyway }   & {\tt every }      & {\tt it }     & {\tt our }       & {\tt these }     & {\tt whose } \\
{\tt are }      & {\tt everyone }   & {\tt just }   & {\tt ourselves } & {\tt they }      & {\tt why } \\
{\tt as }       & {\tt everything } & {\tt last }   & {\tt out }       & {\tt this }      & {\tt will } \\
{\tt at }       & {\tt for }        & {\tt least }  & {\tt over }      & {\tt those }     & {\tt with } \\
{\tt away }     & {\tt from }       & {\tt left }   & {\tt per }       & {\tt through }   & {\tt within } \\
{\tt back }     & {\tt front }      & {\tt less }   & {\tt put }       & {\tt till }      & {\tt without } \\
{\tt be }       & {\tt get }        & {\tt let }    & {\tt putting }   & {\tt to }        & {\tt won't } \\
{\tt became }   & {\tt getting }    & {\tt like }   & {\tt same }      & {\tt too }       & {\tt would } \\
{\tt because }  & {\tt go }         & {\tt make }   & {\tt saw }       & {\tt two }       & {\tt wouldn't } \\
{\tt been }     & {\tt goes }       & {\tt many }   & {\tt see }       & {\tt unless }    & {\tt yet } \\
{\tt before }   & {\tt going }      & {\tt may }    & {\tt seen }      & {\tt until }     & {\tt you } \\
{\tt being }    & {\tt gone }       & {\tt maybe }  & {\tt shall }     & {\tt up }        & {\tt your } \\
\end{tabular}

The default may be changed by editing the \verb`noise[]` array in the
function \verb`openapicp()` in the file \verb`api3.c` and recompiling.

\begin{verbatim}
void *usr:
\end{verbatim}

This is a pointer that the application programmer my use as a
method of passing arbitrary application specific information to
the callback functions \verb`(*eqedit)()` and \verb`(*eqedit2)()`.  This pointer
is entirely under the control of the programmer.  The Metamorph
API does not reference it in any way except to set it to
\verb`(void *)NULL` in \verb`openapicp()`.

% ============================================================================
\section{Equivalence editing callbacks}

During query processing, \verb`setmmapi()` will call two user callback
functions to perform editing on the query terms. The processing
sequence is as follows:
\begin{enumerate}
\item  parse the query and lookup terms in equiv file.
\item  build eqvlist for eqedit2.
\item * call (*eqedit2)().
\item  check for empty or NULL list.
\item  check for and remove duplication in set lists.
\item  set intersections if not already set (<0).
\item  build formatted sets for (*eqedit)() from eqvlist.
\item  free eqvlist.
\item * call (*eqedit)().
\item  perform rest of internal setup.
\item  return to caller.
\end{enumerate}

\verb`(*eqedit2)()` is the recommended method for implementing on the fly
equiv editing because it is easier to use.  \verb`(*eqedit)()` is
available for backwards compatibility.

\begin{verbatim}
int (*eqedit2)(APICP *,EQVLST ***):
\end{verbatim}

This function is always called after a successful equiv lookup and
before the search begins.  It is called with the current \verb`APICP`
pointer and a pointer to the list of equivs generated by the query
(see the description of lists).  The list pointer may be
reassigned as needed.

The return value from \verb`(*eqedit2)()` determines whether to go ahead
with the search or not.  A return value of \verb`0` means OK, go ahead
with the search.  A return value of anything else means \verb`ERROR`,
don't do search.  An \verb`ERROR` return from \verb`(*eqedit2)()` will then
cause \verb`setmmapi()` or \verb`openmmapi()`, depending on where it was called
from, to return an error.  A \verb`NULL` list from \verb`(*eqedit2)()` is also
considered an error.

There is one \verb`EQVLST` for each term in the query.  The array of
\verb`EQVLSTs` is terminated by an \verb`EQVLST` with the words member set to
\verb`(char *)NULL` (all other members of the terminator are ignored).
The \verb`EQVLST` structure contains the following members:

\begin{verbatim}
char   logic: the logic for this set
char **words: the list of terms including the root term
char **clas : the list of classes for `words'
int    sz   : the allocated size of the `words' and `clas' arrays
int    used : the number used (populated) of the `words' and `clas'
              arrays, including the terminating empty string ("")
int    qoff : the offset into user's query for this set (-1 if unknown)
int    qlen : the length in user's query for this set (-1 if unknown)
char   *originalPrefix:  set logic/tilde/open-paren/pattern-matcher
char   **sourceExprs: NULL-terminated list of source expressions for set
\end{verbatim}

The \verb`words` and \verb`clas` arrays are allocated lists like
everything else in the \verb`APICP`, and are terminated by empty
strings.  The \verb`sz` and \verb`used` fields are provided so that
editors may manage the lists more efficiently.

The \verb`words` and \verb`clas` lists are parallel.  They are exactly
the same length and for every item, \verb`words[i]`, its classification
is \verb`clas[i]`.

The \verb`originalPrefix` field (added in Texis version 6) contains
the set logic (``\verb`+`'', ``\verb`-`'', ``\verb`=`''), tilde
(``\verb`~`''), open-parenthesis, and/or pattern-matcher characters
(``\verb`/`'' for REX, ``\verb`%`'' for XPM, ``\verb`#`'' for NPM)
present in the original query for this set, if any.  It can be used in
reconstructing the original query, e.g. if the terms are to be
modified but set logic etc. should be preserved as given.

The \verb`sourceExprs` field (added in Texis version 6) contains a
list of the source expressions or terms for the set, i.e. as given in
the original query.  For SPM queries, this will be a single word or
phrase.  For PPM queries given as parenthetical lists, this will be a
list of the individual terms or phrases.  For REX/NPM/XPM queries,
this will be the expression (sans ``\verb`/`''/``\verb`#`''/''\verb`%`'').
For single terms that are expanded by equivalence lookup, this will be
the original single term, {\em not} the expanded list (as \verb`words`
will be) -- because \verb`sourceExprs` is from the source (original
query), not post-equivalence-processing.  Note also that
\verb`sourceExprs` is \verb`NULL` (not empty-string) terminated.
The \verb`sourceExprs` array can be used in reconstructing or
modifying queries.

The default function is the function \verb`nulleqedit2` in
\verb`api3.c` which does nothing and returns \verb`0` for OK.

\begin{verbatim}
int (*eqedit)(APICP *):
\end{verbatim}
This function is always called after a successful equiv lookup and
before the search begins.  It is called with the current \verb`APICP`
pointer with the ``set'' list in the APICP structure set to the list
of equivs generated by the query (see the description of lists).

The return value from \verb`(*eqedit)()` determines whether to go ahead
with the search or not.  A return value of \verb`0` means OK, go ahead
with the search.  A return value of anything else means \verb`ERROR`,
don't do search.  An \verb`ERROR` return from \verb`(*eqedit)()` will then cause
\verb`setmmapi()` or \verb`openmmapi()`, depending on where it was called from,
to return an error.

The format of the sets is:
\begin{verbatim}
{-|+|=}word[;class][,equiv][...]
\end{verbatim}

Or:
\begin{verbatim}
{-|+|=}{/|%99|#}word
\end{verbatim}

Where:
\begin{verbatim}
[]    surround optional sections.
{}    surround required items to be chosen from.
|     separates mutually exclusive items between {}.
9     represents a required decimal digit (0-9).
word  is the word, phrase, or pattern from the query.
equiv is an equivalent for word.
class is a string representing the classification for the
      following words.
...   means any amount of the previous item.
\end{verbatim}

Classifications in the default thesaurus (case is significant):
\begin{verbatim}
P = Pronoun         c = Conjunction
i = Interjection    m = Modifier
n = Noun            p = Preposition
v = Verb            u = Unknown/Don't care
\end{verbatim}
Words and phrases will be in the first format.
Patterns will be in the second format.

\begin{verbatim}
=struggle;n,battle,combat,competition,conflict,compete;v,contest,strive
     battle, combat, competition, and conflict are nouns
     compete, contest, and strive are verbs
     struggle can be a noun or verb

=status quo;n,average,normality
     status quo, average, and normality are nouns

+Bush;P
     Bush is a pronoun

-/19\digit{2}
     a REX pattern to find "19" followed by 2 digits

=%80qadafi
     an XPM pattern to find qadafi within 80%

=#>500
     an NPM pattern to find numbers greater than 500
\end{verbatim}

Remember that each of the ``set'' strings is allocated.  So if you
replace a set you must free the old one, to prevent memory loss,
and use an allocated pointer for the replacement because it will
get freed in \verb`closeapicp()`, unless it is \verb`(byte *)NULL`.

The ``set'' format must be totally correct for the search process to
work.

The default is the function \verb`nulleqedit` in \verb`api3.c` which does
nothing and returns \verb`0` for OK.

% ============================================================================
\section{User equivalence file maintenance}

A user equivalence file contains equivalences in a manner similar
to the main equiv file.  The user equiv contains equivs that edit
and/or replace equivs in the main equiv.  It may also contain new
equivs.

Make a user equiv file by creating an ASCII file containing your
desired equiv edits.  Then index that source file with backref
program.

The user equiv source file has the following format:
\begin{itemize}
\item The root word or phrase is the first thing on the line.

\item Hyphenated words should be entered with a space instead of a
hyphen.

\item Subsequent words/phrases (equivs) follow on the same line
prefixed with edit commands (see below).

\item Add optional classification information by appending a semicolon
(;) and the class to the word to apply it to.  Any specified
classification is carried onto subsequent words until a new
classification is entered.

\item Lines should be kept to a reasonable length; around 80
characters for standard screen display is prudent.  In no case
should a line exceed 1K.  Where more equivs exist for a root
word than can be fit onto one line, enter multiple entries where
the root word is repeated as the first item.

\item There should not be any blank lines.  Lines should not have any
leading or trailing spaces.  Words or phrases also should not
have any leading or trailing spaces.

\item A user equiv file may "chain" to another user equiv file by
placing the key string ";chain;" followed by the name of the
equiv source file to chain to on the first line of the source
file. e.g.  \verb`";chain;c:\morph3\eqvsusr"` Equivs are looked up
in the chained file before the current file so that a user may,
for example, override system wide settings.  Chains are resolved
when the source file gets backreferenced.
\end{itemize}

% ============================================================================
\section{Edit commands:}

Comma \verb`(,)` means add this word/phrase to the list of equivs for
this root.

Tilde \verb`(~)` means delete this word from the list of equivs for this
root.

Equals \verb`(=)` only applies for the first equiv specified for a root.
It means replace this entry with the following entry.  The first
word after the equals is taken as the new root and the rest of the
words are its equivs.  If the equals is followed by a
non-alphanumeric character the entire rest of the line is taken
literally as a replacement for the original entry.  This is a
macro like facility that allows you to make a word mean a regular
expression or other Metamorph special pattern match.

Once you have a user equiv source file index it with the backref
command.  This syntax is:
\begin{verbatim}
backref source_file indexed_file
\end{verbatim}

Where \verb`source_file` is the ASCII file you created.  And \verb`indexed_file`
is the backreferenced and indexed file that you specify in the
\verb`ueqprefix` variable.  To just index the source file without
backreferencing it use the \verb`-l1` option:

\begin{verbatim}
backref -l1 source_file indexed_file
\end{verbatim}
By convention the source file should have the same path and
filename as the indexed file with an extension of \verb`".lst"`.  This is
what the Metamorph user interface expects.  For example:  the
source file for \verb`"c:\morph3\eqvsusr"` would be
\verb`"c:\morph3\eqvsusr.lst"`

Sample user equiv file:
\begin{verbatim}
chicken,bird,seed,egg,aviary,rooster
seed;n,food,feed,sprout
ranch,farm,pen,hen house,chicken house,pig sty
Farmer's Almanac,research,weather forecast,book
rose,flower,thorn,red flower
water,moisture,dew,dewdrop,Atlantic Ocean
bee pollen,mating,flower,pollination,Vitamin B
grow,mature,blossom,ripen
abort,cancel,cease,destroy,end,fail,kill
abort,miscarry,nullify,terminate,zap
wish;n,pie in the sky,dream;v,yearn,long,pine
constellation~nebula~zodiac,big dipper
abandon=abandon,leave
galaxy=andromeda
slice=slice
lots=#>100
bush=/\RBush
\end{verbatim}

% ============================================================================
\section {Reprogramming the Within Operator}

{\bf NOTE:} The mechanism described here may be replaced with something
different in a future version of the Metamorph API.

The symbolic expressions that the within operator knows about may
be reprogrammed by the application developer.  The within
processor maintains two lists of symbolic expressions:  a
``standard'' list and a ``user'' list.  By default the standard list
contains the symbols described elsewhere in this document
(line/page/etc).  The user list is empty by default.

The within processor processes the string after the \verb`"w/"` in the
following order:

\begin{itemize}
\item If the first character is a digit its a proximity count.
\item If it matches something in the user list, use its expression.
\item If it matches something in the standard list, use its expression.
\item Otherwise it's taken literally as a rex expression.
\end{itemize}

Each list is made up of an array of \verb`MDPDLM` structures
\begin{verbatim}
MDPDLM {
   char *name;
   char *expr;
   int   incsd;
   int   inced;
};
\end{verbatim}

Where:

\verb`name` is the name used in the query with the \verb`"w/"` operator.
\verb`expr` is the rex expression associated with name.
\verb`incsd` is a flag indicating whether to include the start delimiter.
\verb`inced` is a flag indicating whether to include the end delimiter.

The array is terminated with a \verb`MDPDLM` with the name member set to
\verb`(char *)NULL`.

The lists are manipulated with the \verb`mdpstd()` and \verb`mdpusr()` functions
to control the standard and user lists respectively.

\begin{verbatim}
MDPDLM *mdpstd(MDPDLM *);
MDPDLM *mdpusr(MDPDLM *);
\end{verbatim}

These functions set their respective lists to those provided by
the argument.  They return the previous lists.  Any list may be
\verb`MDPDLMPN` to suppress its processing.  The list pointers are kept
in a static global variable within the api library, so all
subsequent within operators will be effected by any changes.  The
table is not copied, so the pointers passed must remain valid for
the duration of all api usage.

Comparisons to name need only match for the length of name, thus
allowing abbreviations. e.g.  The following will both match for a
name of ``mess'':  w/message, w/messy.

\EXAMPLE
\begin{verbatim}
static MDPDLM mydelims[]={
   { "mess","^From:"         ,1,0 },           /* add a new name */
   { "page","-- \\digit+ --:",0,1 },/* override an existing name */
   { CHARPN }
};
   ...
   /*
      you could call
         mdpstd(MDPDLMPN);
      to suppress the standard names so that only the usr names
      would be recognized.
   */
   mdpusr(mydelims);
   ...
   setmmapi(mm,query);
   ...
\end{verbatim}

\chapter{Low level Pattern Matchers}

{\bf\em Programmers note: Do not use these functions unless you
are sure you know why you need them. Thunderstone will {\em not} provide technical
support involving the \verb`((ab=normal ?)|mis)use` of these functions. }

\NAME
{Low level Pattern Matching functions}

\SYNOPSIS
{\bf REX - Deterministic Regular Expression Matcher}

\begin{verbatim}
FFS   *openrex(byte *s);
FFS   *closerex(FFS *fs);
FFS   *mknegexp(FFS *fs);
byte  *getrex(FFS *fs,byte *buf,byte *end,int operation);
int    rexsize(FFS *ex);
\end{verbatim}

{\bf XPM - Approximate Pattern Matcher}
\begin{verbatim}
XPMS *openxpm(byte  *s,int threshold); /* 0 < threshhold < 101 */
XPMS *closexpm(XPMS *xs);
byte *getxpm(XPMS *xs,byte *buf,byte *end,int operation);
\end{verbatim}

{\bf PPM - Parallel String Pattern Matcher}
\begin{verbatim}
PPMS *closeppm(PPMS *ps);
PPMS *openppm(byte **sl);
byte *getppm(PPMS *ps,byte *buf,byte *end,int operation);
\end{verbatim}

{\bf SPM - Single String Pattern Matcher}
\begin{verbatim}
SPMS *openspm(char *s);
SPMS *closespm(SPMS *fs);
byte *getspm(SPMS *fs,byte *buf,byte *end,int operation);
int   spmhitsz(SPMS *fs);
\end{verbatim}

{\bf NPM - Numeric Pattern Matcher }
\begin{verbatim}
NPMS *opennpm(char *s);
NPMS *closenpm(NPMS *);
byte *getnpm(NPMS *,byte *,byte *,int);

\end{verbatim}

\DESCRIPTION

These pattern matchers represent the core search algorithms that are
present in the {\bf Metamorph} program and API.  Usage and syntax details
are not presented here as they are described in great detail in the
{\bf Metamorph User Manual}.  The programmer is encouraged to understand
their purpose and usage before implementing their own software using these
functions.

All of the pattern matchers behave in a similar fashion from a programming
perspective.  The \verb`open___()` call initializes the matcher and
returns a ``handle'' to it, and the \verb`close___()` call \verb`free()s`
the memory associated with that object's ``handle''.  If the \verb`open___()`
call fails for any reason it will return a cast pointer to \verb`NULL`.

The arguments passed to the \verb`open___()` call are as follows:
\begin{tabbing}
xxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
Call             \>Parameters Type(s)    \> Example                         \\
\verb`openrex()` \>Rex expression        \> \verb`"\\x0d\\x0a+"`            \\
\verb`openxpm()` \>any string, threshold \> \verb`"abc widgets",80`         \\
\verb`openppm()` \>a list of strings     \> \verb`{"abc","def","ghi",""};`  \\
\verb`opennpm()` \>a numeric expression  \> \verb`">1000<=million"`         \\
\verb`openspm()` \>a string expression   \> \verb`"abc*def"`                \\
\end{tabbing}

In all cases, the \verb`open___()` call is computationally intensive, as
each algorithm makes extensive use of dynamic programming techniques.  It
is generally considered that the pattern matcher will be processing a
great deal of information between it's creation and destruction so that
the creation overhead is justified by the dramatic increase in search
rates.

If the pattern matchers are to be used in conjunction with one another
then the programmer should optimize usage by dispatching the pattern
matchers in order of relative speed. The following table enumerates
the relative search rates:

\begin{tabbing}
xxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\kill
Pattern Types \>Governing factors                                  \\
SPM Fastest   \>longer strings are faster                          \\
REX .         \>longer expressions are usually faster              \\
PPM .         \>shorter lists with the longest minimum strlen()    \\
XPM .         \>shorter strings are faster                         \\
NPM Slowest   \>nothing makes a difference                         \\
\end{tabbing}

The \verb`get___()` call is responsible for the location of {\em hits}
within a buffer of information. All of the pattern matchers share
a common parameter set for this operation:

{\bf (object pointer, byte *buf , byte *end, int operation)}

\begin{description}

\item[object pointer] The structure pointer that was returned by the
\verb`open___()` call.

\item[byte *buf] A pointer to the first character of the buffer to
be searched \footnote{byte is defined as an unsigned char}.

\item[byte *end] A pointer to one character past the last character
in the buffer to be searched. ( Usually obtained by the expression
\verb`buf+bufsize`).

\item[int operation] This will be one of the four possible operation
codes: \verb`SEARCHNEWBUF`,\verb`CONTINUESEARCH`,  \verb`BSEARCHNEWBUF`,
or \verb`BCONTINUESEARCH`.

\end{description}

The \verb`SEARCHNEWBUF` to locate the first occurrence of a hit within the
delineated buffer, and the \verb`CONTINUESEARCH` operation code indicates
that the pattern matcher should locate the next (or succesive) occurrence.
A pointer to the matched pattern will be returned or, a
\verb`(byte *)NULL` if no match was located within the buffer
for the given call.

The operation codes \verb`BSEARCHNEWBUF` and \verb`BCONTINUESEARCH` are
only understood by the REX pattern matcher, and are used to search
backwards from the \verb`end` pointer towards the \verb`buf` pointer.  A
non \verb`NULL` return value will point to the beginning of the matched
pattern.

Some information about the matched hits for each of the pattern matchers
may be obtained by looking into that pattern matcher's structure. The
following structure members are the only valid ones for an API programmer
to use:

\begin{verbatim}
NPMS /* Numeric Pattern Matcher */
{
 int hitsz;  /* the length of the matched quantity */
 double hy;  /* the maximum numeric value of the matched string */
 double hx;  /* the minimum numeric value of the matched string */
};
\end{verbatim}

\begin{verbatim}
PPMS
{
 byte **slist;  /* the strings being sought */
 int sn;        /* the index of the located string within slist */
};
\end{verbatim}

\begin{verbatim}
XPMS
{
 word thresh;           /* threshold above which a hit can occur */
 word maxthresh;        /* the max possible value a match may have */
 word thishit;          /* the value of this match */
 word maxhit;           /* max value located so far */
 byte maxstr[DYNABYTE]; /* the string with highest match value */
};
\end{verbatim}

\begin{verbatim}
SPMS
{
 /* no usable members */
};
\end{verbatim}

\begin{verbatim}
FFS  /* aka REX */
{
 /* no usable members */
};
\end{verbatim}

Hit length information for REX and SPM is available through calls to
\verb`rexsize()` and \verb`spmhitsz()` respectively.  Each of these
functions return the length of the last hit located by a call to
\verb`get___()`.  The reason there are not similar calls available for the
othe pattern matchers is because their length is obtainable via the
structure.

\EXAMPLE
\begin{verbatim}
#include "api3.h"

       /* this code breaks some rules in the interest of brevity */

main(argc,argv)
int    argc;
char **argv;
{
 void *pm=(void *)NULL;
 int   i;
 void (*close)();                    /* pointer to the close function */
 void (*get)();                        /* pointer to the get function */
 char ln[80];

 switch(*argv[1])      /* determine search type via leading character */
    {
     case '/' : pm=(void *)openrex(argv[1]+1);
                get=getrex;
                close=closerex;
                break;
     case '#' : pm=(void *)opennpm(argv[1]+1);
                get=getnpm;
                close=closenpm;
                break;
     case '%' : pm=(void *)openxpm(argv[1]+1,80);
                get=getxpm;
                close=closexpm;
                break;
    }
 if(pm==(void *)NULL)                    /* check to see if it opened */
    exit(1);

 while(gets(ln)!=NULL)
    {                                /* see if there hit on this line */
     if((*get)(pm,(byte *)ln,(byte *)(ln+strlen(ln)),SEARCHNEWBUF)
                    !=(byte *)NULL)
         puts(ln);
    }
 (*close)(pm);
 exit(0);
}
\end{verbatim}

\chapter {Windows Addendum}

Those using non-Microsoft compilers should also read \verb`MSFOPEN.H`.

The Metamorph Windows API is provided in the form of two DLLs and
their associated export libraries:

\begin{verbatim}
MORPH.DLL      MORPH.LIB
MORPHMEM.DLL   MORPHMEM.LIB
\end{verbatim}

Both DLLs must be available for Metamorph applications at run
time.  \verb`MORPHMEM.DLL` contains all memory handling functions.

The entire Metamorph API was compiled large model with the PASCAL
calling convention.  All function calls are therefore PASCAL
unless declared otherwise.  \verb`Putmsg()` uses the C calling convention
since it has a variable number of arguments.  All data passed to
and from API functions must be \verb`FAR`.

\verb`Putmsg()` is handled a little differently under Windows since the
version in the DLL can not be effectively replaced.  The default
behavior of \verb` putmsg()` is to write to file handle 2. To change the
output file call \verb`setmmsgfname()` with the name of the file to write
to.  To change the output file to an already opened file call
\verb`setmmsgfh()` with the opened file handle.  To change the message
handling function completely call \verb`setmmsg()` with a pointer to your
message handling function.  See the descriptions of these
functions for more details.

Message handling should be setup before calling any Metamorph API
functions that could fail so that messages will go to a known
place.

See \verb`MMEXW.C` for working examples.  \verb`MMEXW.MAK` is a Quick C 1.00
project file for \verb`MMEXW`.

\NAME
{setmmsgfname - set the name of the message file}

\SYNOPSIS
\begin{verbatim}
#include "windows.h"
#include "stdio.h"
#include "api3.h"
#include "mmsg.h"

char FAR * FAR setmmsgfname(newfname)
char FAR *newfname;

\end{verbatim}

\DESCRIPTION

\verb`Setmmsgfname()` will change the file that \verb`putmsg` writes messages
to.  It returns its argument.  The default is to write messages to
file handle 2 \verb`(stderr)`.

\EXAMPLE
\begin{verbatim}
APICP *acp;

...

setmmsgfname("msg.001");    /* set message file name to msg.001 */

...

acp=openapicp();              /* open mm api control parameters */

\end{verbatim}

\NAME
{setmmsgfh - set the message file handle}

\SYNOPSIS
\begin{verbatim}

#include "windows.h"
#include "stdio.h"
#include "api3.h"
#include "mmsg.h"

int FAR setmmsgfh(newfhandle)
int newfhandle;

\end{verbatim}

\DESCRIPTION

\verb`Setmmsgfh()` will change the file handle that \verb`putmsg` writes
messages to.  It returns its argument.  The default is to write
messages to file handle 2 \verb`(stderr)`.

\EXAMPLE
\begin{verbatim}
int fh;
OFSTRUCT mmsginfo;
APICP *acp;

...

                              /* open file msg.001 in "wb" mode */
fh=OpenFile("msg.001",&mmsginfo,
            (OF_CANCEL|OF_CREATE|OF_WRITE|OF_SHARE_DENY_NONE));

if(fh!=(-1)) setmmsgfh(fh);    /* set message file handle if ok */

...

acp=openapicp();              /* open mm api control parameters */

\end{verbatim}


\NAME
{setmmsg - set custom message handler function}

\SYNOPSIS
\begin{verbatim}
#include "windows.h"
#include "stdio.h"
#include "stdarg.h"
#include "api3.h"
#include "mmsg.h"

void FAR setmmsg(newfunction)
int (FAR *newfunction)(int msgn, char FAR *fn, char FAR *fmt,
                       va_list args);

\end{verbatim}

\DESCRIPTION

\verb`Setmmsg()` will set the function to call to handle messages from
\verb`putmsg()`.  The handler function will receive four arguments:

\begin{verbatim}
1: int msgn;     the message number       (same as putmsg())
2: char *fn;     the function name        (same as putmsg())
3: char *fmt;    the htpf format string   (same as putmsg())
4: va_list args; the stdarg argument list as derived in putmsg()
by the va_start() call.
\end{verbatim}

The \verb`args` variable may be used like any \verb`va_list` that has been
\verb`va_start()'d`. e.g. in a call to \verb`WVSPRINTF()`.  Do {\em not} call \verb`va_end()`
on \verb`args`.

The handler function pointer must be the result of the Windows
\verb`MakeProcInstance()` call so that it can be called correctly from
within the Metamorph API DLL.  See your Windows SDK manual for
details on \verb`MakeProcInstance()`.  You should not use
\verb`MakeProcInstance()` more than once for any given function if
possible.  Each call to it will use a little memory.

The return value of the handler function will be returned by
\verb`putmsg()` to the original caller.

\EXAMPLE
\begin{verbatim}
...

                                     /* a custom message handler */
int FAR PASCAL
msghandler(int n,char FAR *fn,char FAR *fmt,va_list args)
{
static char buf[256];                     /* place to sprintf to */
char        *d;

   if(n>=0 && n<100)        strcpy(buf,"ERROR: ");
   else if(n>=100 && n<200) strcpy(buf,"WARNING: ");
   else                     strcpy(buf,"FYI: ");
   if(fmt!=(char *)NULL){
      d = buf + strlen(buf);
      htsnpf(d, (buf + sizeof(buf)) - d, fmt, args);
   }
   if(fn!=(char *)NULL){
      strcat(buf," In the function: ");
      strcat(buf,fn);
   }
            /* display message in a standard windows message box */
   MessageBox(GetFocus(),(LPSTR)buf,(LPSTR)"Metamorph 3 Message",MB_OK);
   return(0);
}

...

HANDLE hInst;                              /* current instance */
FARPROC m;
APICP *acp;

   ...

   putmsg(MINFO,(char *)NULL,"Default handler active");

   m=MakeProcInstance(msghandler,hInst);

   if(m!=(FARPROC)NULL){

      setmmsg(m);

      putmsg(MINFO,(char *)NULL,"My custom handler active");

   }

   ...

   acp=openapicp();          /* open mm api control parameters */

\end{verbatim}

Windows programs are generally case insensitive pascal calling sequence.
Using the Metamorph API under Borland C with case sensitivity and C
calling sequence as defaults requires a little adjustment.

{\bf Borland C options:}
\begin{enumerate}
\item Windows large model exe.
\item define\_WINDOWS.
\item \verb`Borland C++ source` (detect \verb`C/C++` by extension).
\item Case sensitive exports as well as case sensitive link.
\end{enumerate}

{\bf api3.h modifications:}
\begin{enumerate}
\item Insert the ``pascal'' keyword before each function name in its prototype.
\item Redefine all functions as uppercase before their prototypes.
(e.g. \verb`"#define rdmmapi RDMMAPI"`)
\end{enumerate}
%\end{document}
