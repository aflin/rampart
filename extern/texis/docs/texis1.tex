
% notice of acknowledgement should appear near copyright info
% for now this page can just appear as it does, after T of C

%\chapter*{Preface}\addcontentsline{toc}{chapter}{Preface}
%\markboth{Preface}{}
\chapter{Preface}

\section{Acknowledgment}

We would like to thank Ray Ageloff of the University of Rhode Island
for his ``{\em Primer on SQL}'', published by Times Mirror/Mosby College
Publishing, Copyright (c) 1988.  We found this to be the very best
available text on Structured Query Language (SQL), and have drawn
heavily upon it in our explanations of SQL, in a way which can be
easily and practically understood by the end user.

\section{Documentation Caveat}

As Texis is a breakthrough development, some of the more advanced
features that have been planned for Texis have not yet been fully
implemented.  Our goal with this manual has been to document both
the features that are currently working, as well as those features
that are planned.  If a feature is shown as not currently
implemented, or you don't see the capabilites you need, please
call us to determine our current development timetable.

% 10-11-99 - no change bars
%\chgbarbegin To distinguish between the features that have been
%implemented and those that are still under development we have
%marked sections of the manual with change bars, similar to those
%on this paragraph.  The change bars indicate that the feature was
%not implemented at the time of going to press.
%\chgbarend

\newpage{\samepage
We thank you for your understanding, and encourage you to contact our
technical support personnel with any questions that may arise.  We are
available 10 a.m. to 6 p.m. Eastern Time, Monday - Friday, by mail or
Web, as follows:

\begin{center}
\begin{em}
Thunderstone Software - EPI, Inc. \\
14837 Detroit Ave. PMB \verb`#`303 \\
Lakewood, Ohio 44107 \\
Web: http://www.thunderstone.com
\end{em}
\end{center}

}
%%% This section add by JMT
\section{Documentation Structure}

There are three distinct sections to this manual.  Where you start
will depend on your needs. Chapters~\ref{chp:Intro}~to~\ref{chp:AdmDB}
of the book deal with the abilities of Texis and provide an
introduction to SQL.  These chapters also note the differences between
Texis and a typical SQL database.  These chapters can be skimmed by a
person knowledgeable about SQL to note the differences with standard
databases.  In particular you may want to read about Metamorph queries
in Chapter~\ref{Chp:MMLike}, and the section on \verb|LIKE| and
friends.

Part~V,~Chapter~\ref{Part:V:Chp:Embed} explains how to use the Texis server from
within a C program.  This chapter should be read be anyone intending
to write a program to access Texis.

Part~V,~Chapter~\ref{Part:V:Chp:Prog} describes the programs that come with Texis,
including the daemon and ad-hoc query tool.  This chapter is divided
into three sections.  These are the example programs, which are
complete examples of how to program with Texis, the programs required
to use Texis, and finally some maintenance and administration tools
that are useful.

%%% End of JMTs section

\chapter{Introduction}{\label{chp:Intro}}

\section{Texis: Thunderstone's Text Information Server}

\subsubsection{What is it?}

Texis is a relational database server that specializes in managing
textual information.  It has many of the same abilities as products
like Oracle(r), Informix(r), and Sybase(r) with one key difference:
it can intelligently search and manage databases that have natural
language text in them, which is something they can't do.

\subsubsection{Why is that different?}

Most other products are capable of storing a limited field that
contains text, and usually that information is limited to being less
than 500 characters long.  And when it comes to finding something in
that field you're limited to being able to search for a single word or
string of characters.

In Texis you can store text of any size, and you're able to query that
information in natural language for just about anything you can
imagine.  We took our powerful Metamorph concept based text engine and
built a specialized relational database server around it so that you
have the best of both worlds.

\subsubsection{What can we do with it?}

Look at your current info-system and for the occurrence of anything
that contains natural language information.  This includes things
like:  e-mail, personnel records, research reports, memos, faxes,
product descriptions, and word processing documents.  Now imagine
being able to collect and perform queries against these items as if
they were a traditional database.

If you look closely enough you'll probably discover that about half
the information that is resident within the organization has natural
language or text as one of its most significant attributes.  And
chances are that there is little or no ability to manage and query
these information resources based on their content.  Traditional
databases are fine as long as you are just adding up numbers or
manipulating inventories, but people use language to communicate and
no product except Texis can provide real access to the ``natural
language'' components.

% no buzzword section 10-23-00 per bart
% ----------------------------------------------------------------------------
%\subsection{Buzzword Compliance}
%
%\subsubsection{SQL (ANSI Structured Query Language)}
%
%We took the standard and added a few features.  Mostly we added a
%bunch of brains to the ``LIKE'' statement.
%
%\subsubsection{Client Server}
%
%Texis servers and clients can live on almost every UNIX, DOS,
%MS-Windows, and NT machine you have.  By the way, we recommend that
%you use a Unix machine as the server for big applications.
%
%\subsubsection{Open Systems, TCP/IP, LANS, WANS}
%
%We chose to use a TCP/IP foundation because it is the clear leader in
%open systems architectures.  If you put a Texis server on your
%``Information Superhighway'' it will be able to grow with your needs;
%both computational and topological.
%
%\subsubsection{SGML (Standard Generalized Markup Language)}
%
%%\chgbarbegin
%Texis has an import facility that will read the ``\verb`<tags>`'' in
%an SGML document.  The requested tagged items in the document are then
%converted into fields.  If you have a large body of homogeneous SGML
%documents, their content can be imported, exported, and queried as if
%they were a normal database.
%%\chgbarend
%
%\subsubsection{Multimedia and Objects}
%
%Usually getting a database to incorporate new data types and operators
%involves a lot of bubble gum and duct tape.  In Texis we allow the
%programmer to add types in a structured fashion so that it can support
%the new types just like the standard ones.  That way if we didn't
%think of it you can still get the job done correctly without resorting
%to a major kludge.  And because of Texis's inherent field storage and
%indexing abilities you won't be shoving a ``square peg into a round
%hole''.
%
%\subsubsection{Microsoft ODBC (Open Database Connectivity) Driver}
%
%We provide an ODBC driver for Windows that will allow you to quickly
%create your client interfaces in products like ACCESS, and Visual
%Basic.  The ODBC driver is currently only available to talk to
%32-bit servers, and requires TCP/IP.

% ----------------------------------------------------------------------------
\subsection{Features Unique to Texis}

Before we give you the specifications, we need to explain some
features that are unique to Texis.

\subsubsection{Zero Latency Insert}

When a record is added or updated within a Texis table it is available
for retrieval immediately.  With any other product you would have to
wait until the record was ``indexed'' before it would become
available.  The reason for this follows.

\subsubsection{Variable Sized Records}

Most databases allocate disk space in fixed size blocks that each
contain a fixed number of records.  The space allocated to each record
is the maximum size that that record definition allows.

For example, let's say you have a table that contains a 6 digit fixed
length part number, and a variable length part description that could
be up to 1000 characters long.  Under the definition above, a 10,000
record database would require at least 10,060,000 bytes of disk space.

But let's look a little closer at the facts behind our table.  Our
{\em maximum} part description is 1000 bytes, but that's only because
we have a few parts with really long winded descriptions; most of our
part descriptions have an average length of about 100 characters.
This is where Texis comes in; it only stores what you use, not what
you might use.  This means that our table would only require about 1
MB of disk space instead of 10 Mbytes.

But wait, it doesn't stop there!  We have another hat trick.  Because
we store our records in this manner we also remove the limitation of
having to specify the maximum length of a variable length field.  In
Texis any variable field can contain up to a Gigabyte.  (Not that we
recommend 1 Gig fields.)

\subsubsection{Indirect Fields}

Indirect fields are byte fields that exist as real files within the
file system.  This field type is usually used when you are creating a
database that is managing a collection of files on the server (like
word processing files for instance).  They can also be used when the 1
Gig limitation of fields is too small.

% MAW 09-16-94 - rm blob field paragraph add following 2
You may use indirect fields to point to your files anywhere on your
file system or you may let Texis manage them under the database.

Since files may contain any amount of any kind of data indirect
fields may be used to store arbitrarily large binary objects.
These Binary Large OBjects are often called BLOBs in other RDBMSes.

However in Texis the \verb`indirect` type is distinct from
\verb`blob`/\verb`blobz`.  While each \verb`indirect` field is a
separate external file, all of a table's \verb`blob`/\verb`blobz`
fields are stored together in one \verb`.blb` file adjacent to the
\verb`.tbl` file.  Thus, \verb`indirect` is better suited to
externally-managed files, or data in which nearly every row's field
value is very large.  The \verb`blob` (or compressed \verb`blobz`,
available in Texis Version 8 and later) type is better suited to data
that may often be either large or small, or which Texis can manage
more easily (e.g. faster access, and automatically track changes for
index updates).

\subsubsection{Variable Length Index Keys}

Traditional database systems allocate their indexes in fixed blocks,
and so do we; but we were faced with a problem.  Typical English
language contains words of extremely variant length, and we wanted to
minimize the overhead of storing these words in an index.  Traditional
Btrees have fixed length keys, so we invented a variable length key
Btree in order to minimize our overhead while not limiting the maximum
length of a key.

\subsubsection{Why all the variable stuff?}

Texis stands for Text Information Server, and text databases are
really different in nature to the content of most standard databases.
Have a look at the word processing files that are on your machine.
The vast majority are probably relatively small, but then there's an
occasional whopper.  The same is true for the content of most
documents:  their size and content are extremely variable.

Texis is optimized for two things:  Query time and variable sized
data.

% ----------------------------------------------------------------------------
\subsection{Specifications}

\begin{table}[h]
\caption{Specifications}{\label{tab:specs}}
\begin{center}
\begin{tabular}{|l|l|} \hline
Feature                        & Texis Specs           \\ \hline\hline
Multiple Servers per machine   & Yes                   \\
Multiple Databases per server  & Yes                   \\
Tables per database            & 10,000                \\
Max table size                 & \begin{minipage}[t]{3in}2 gigabytes (\verb`2^31`) on 32-bit systems, 9 exabytes (\verb`2^63`) on 64-bit systems\end{minipage}     \\
Rows per table                 & 1 billion             \\
Columns per table              & Unlimited             \\
Indexes per table              & Unlimited             \\
Max field size                 & 1 gigabyte            \\
Max field name                 & 32 characters         \\
Max tables per query           & 400                   \\
User password security         & Yes                   \\
Group password security        & Yes                   \\
Index types                    & Btree, Inverted, Text, Text inverted \\
Max index key size             & 8192                  \\
Standard Data Types            & \parbox[t]{3in}{bool, [var]byte, dbyte, qbyte, [var]char, short, int, long, [u]int64, float, double, time, indirect, counter, strlst, blob[z]} \\
Max user defined data types    & 64                          \\ \hline
\end{tabular}
\end{center}
\end{table}
% MAW 09-16-94 wtf dbyte, qbyte, time, assorted types in above table

\section{Texis as a Relational Database Management System}

Texis is a database management system (DBMS) which follows the
relational database model, while including methods for addressing the
inclusion of large quantities of narrative full text.  Texis provides
a method for managing and manipulating an organization's shared data,
where intelligent text retrieval is harnessed as a qualifying action
for selecting the desired information.

Texis serves as an ``intelligent agent'' between the database and the
people seeking data from the database, providing an environment where
it is convenient and efficient to retrieve information from and store
data in the database.  Texis provides for the definition of the
database and for data storage.  Through security, backup and recovery,
and other services, Texis protects the stored data.

At the same time Texis provides methods for integrating advanced full
text retrieval techniques and object manipulation with the more
traditional roles performed by the RDBMS (relational database
management system).

\section{Relational Database Background}

Texis, as most recent DBMSs, is based on the relational data model.
The fundamental organizational structure for data in the relational
model is the relation.  A {\em relation} is a two-dimensional table
made up of rows and columns.  Each relation, also called a table,
stores data about {\em entities}.  These entities are objects or
events on which an organization chooses to collect data.  Patients,
doctors, services, and insurance carriers are examples of entities.

The columns in a relation represent characteristics ({\em attributes},
{\em fields}, or {\em data items} of an entity, such as patient
identification number, patient name, address, etc.  The rows (called
{\em tuples} in relational jargon) in the relation represent specific
occurrences (or records) of a patient, doctor, insurance group number,
service rendered, etc.  Each row consists of a sequence of values, one
for each column in the table.

In addition, each row (or record) in a table must be unique.  The {\em
primary key} of a relation is the attribute or attributes whose value
uniquely identifies a specific row in a relation.  For example, a
Patient identification number (ID) is normally used as a primary key
for accessing a patient's hospital records.  A Customer ID number can
be the primary key in a business.

Over the years, many different sets of terms have been used
interchangeably when discussing the relational model.
Table~\ref{tab:RelDBTerm} lists these terms and shows their
relationship.

\begin{table}
\caption{Relational Database Terminology}{\label{tab:RelDBTerm}}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Relational Model Literature & Relational DBMS Products & File Processing \\ \hline\hline
Relation                    & Table                    & File   \\
Tuple                       & Row                      & Record \\
Attribute                   & Column                   & Field  \\ \hline
\end{tabular}
\end{center}
\end{table}

Figure~\ref{fig:PatInvRel} illustrates two relations.  The first one
depicts patients and the second represents outstanding patient
invoices.  A row in the PATIENT relation represents a particular
patient, while a row in the INVOICE relation represents a patient
invoice.  Thus, a relation provides a structure for storing data about
some entity within the organization.  In fact, a database in the
relational model consists of several relations, each representing a
different entity.

\begin{figure}
\caption{PATIENT and INVOICE Relations}{\label{fig:PatInvRel}}
\begin{screen}
a. PATIENT Relation
\begin{verbatim}
  PATIENT ID  PATIENT NAME    ADDRESS            CITY         STATE

  107         Pryor           1 Ninigret Ave     Quonsett     RI
  111         Margolis        3 Chester Ave      Westerley    RI
  112         Frazier         7 Conch Rd         New London   CT
  123         Chen            163 Namcock Rd     Attleboro    MA
  128         Steckert        14 Homestead       Norwich      CT
\end{verbatim}
\end{screen}
\begin{screen}
b. INVOICE Relation
\begin{verbatim}
  INVOICE NO      DATE             AMOUNT             PATIENT ID

  71115           11/01/92         255.00             112
  71116           11/03/92         121.25             123
  71117           11/08/92         325.00             111
  71118           11/08/92          48.50             112
  71119           11/10/92          88.00             107
  71120           11/12/92         245.40             111
  71121           11/15/92         150.00             112
  71122           11/17/92         412.00             128
  71123           11/22/92         150.00             112
\end{verbatim}
\end{screen}
\end{figure}

An important characteristic of the relational model is that records
stored in one table can be related to records stored in other tables
by matching common data values from the different tables.  Thus data
in different relations can be tied together, or integrated.  For
example, in Figure~\ref{fig:PatInvRel}, invoice 71115 in the INVOICE
relation is related to Patient 112, Frazier, in the Patient relation
because they both have the same patient ID.  Invoices 71118, 71121,
and 71123 are also related to Patient 112.

A database in the relational model is made up of a collection of
interrelated relations.  Each relation represents data (to the users
of the database) as a two-dimensional table.  The terms {\em relation}
and {\em table} are interchangeable.  For the remainder of the text,
the term {\em table} will be used when referring to a relation.

Access to data in the database is accomplished in two ways.  The first
way is by writing application programs written in procedural languages
such as C that add, modify, delete, and retrieve data from the
database.  These functions are performed by issuing requests to the
DBMS.  The second method of accessing data is accomplished by issuing
commands, or queries, in a fourth-generation language (4GL) directly
to the DBMS to find certain data.  This language is called a {\em
query language}, which is a nonprocedural language characterized by
high-level English-like commands such as \verb`UPDATE`, \verb`DELETE`, \verb`SELECT`, etc.
Structured Query Language (SQL, also pronounced ``Sequel'') is an
example of a nonprocedural query language.

\section{Support of SQL}

As more corporate data processing centers use SQL, more vendors are
offering relational database products based on the SQL language.

In 1986, the American National Standards Institute (ANSI) approved SQL
as the standard relational database language.  SQL is now the standard
query language for relational database management systems.

Texis supports the SQL query language.  Any program capable of issuing
SQL commands can interface with Texis, to accomplish the database
management, access, and retrieval functions.

For example, Microsoft ACCESS provides a means for creating a GUI
({\em graphical user interface}) front end for a database.  Using
icons in a point and click fashion familiar to the user, one can
maneuver through the database options where queries are created and
issued to the database.  While the user does not see the form of the
query, the ACCESS program is translating them to SQL.  These queries
can be passed to and implemented in a more powerful fashion by Texis,
where the results are passed back to the user via the Windows ACCESS
application.

For any application written in C, an embedded SQL processor allows the
C Programmer to use Texis within his or her application.

Texis is a SQL driven relational database server that merges the
functionality of METAMORPH, our concept based text retrieval engine
with a DB2-like database.  The prime differences to other systems are
in the \verb`LIKE` statement and in the allowable size of text fields.

This manual will explain SQL as the query language used in an enhanced
manner by Texis, so that users will be able to write queries accessing
data from a database.

\section{Case Example: Acme Industrial Online Corporate Library}

To provide a frame of reference to show the concepts and syntax of SQL
for use by Texis, we will use the example of Acme Industrial's Online
Corporate Library.  It is the job of the corporate librarian to make
selectively accessible to Management, Personnel, Marketing, and
Research \& Development (R\&D), the full text content of management,
personnel, marketing, and R\&D reports, both in tabulated and full
text form.

Many entities and their related functions are involved.  While a
researcher in R\&D requires a conceptual search and full text study of
all work that has been done similar to her own project, the Technology
Manager may be interested in hours spent by which staff, on what
projects, and to what final results in encapsulated form.  The
Marketing Director will want to keep track of finished reports on
subjects of interest, while having access to promotional budget
information to plan the focus of the ad campaign over the next two
quarters.

The Corporate Librarian must be able to supply concise short form and
expanded long form information on demand to those who request it,
while maintaining discretionary security.  Therefore a mix of fielded
and full text information must be available and easy to manipulate and
turn into generated report content.

It may even be that each department wishes to create their own front
end application program which defines the way in which they conduct
their daily business while accessing this information.  But where the
information is shared, the online library database is common to each
and must be managed as such.

All the daily activities of Acme Industrial create the need for
recording and storing vast amounts of data.  These activities affect
the Online Corporate Library System in numerous ways.  Data concerning
transactions and daily events must be captured in order to keep the
data in the system accurate.  The system must have the capability to
answer unplanned, one-time-only queries in addition to preplanned
queries.

Texis is the SQL Relational Database Server which has the horsepower
to manage this main repository of information.

This introductory chapter has introduced you to several concepts and
terms related to relational database management systems.  In addition
we have provided the background case of Acme Industrial's Online
Corporate Library System that will be used in examples throughout the
text.  In the next chapter you will learn how to define and remove
tables for use by Texis.

\chapter{Table Definition}{\label{chp:TabDef}}

Texis permits users to define, access, and manipulate data stored in a
database.  This chapter describes how a table is defined and deleted.
In addition, you will be shown an example of how data is loaded into a
table.

\section{Creating the Resume Table}

One of the functions of the Librarian is to maintain a resume database
for Personnel, for potentially qualified staff for jobs as they open
up.  Therefore one of the tables in the Acme Online Corporate Library
System is the {\tt RESUME} table.  This table is created by issuing the
{\tt CREATE TABLE} command.

If you enter the following:
\begin{verbatim}
     CREATE TABLE  RESUME
       ( RES_ID  CHAR(5),
         RNAME   CHAR(15),
         JOB     CHAR(15),
         EDUC    CHAR(60),
         EXP     VARCHAR(2000)
       );
\end{verbatim}
%JMT 03-04-96 - No NULLS yet.
%\begin{verbatim}
%     CREATE TABLE  RESUME
%       ( RES_ID  CHAR(5)    NOT NULL,
%         RNAME   CHAR(15),
%         JOB     CHAR(15),
%         EDUC    CHAR(60),
%         EXP     VARCHAR(2000)
%       );
%\end{verbatim}
%MAW 09-16-94 - comment following
%the message on the screen will be:
%\begin{verbatim}
%     Table Created
%\end{verbatim}
%When the table is created, the computer displays this message.

SQL statements as passed to Texis can be entered on one or more lines.
Indenting is recommended to improve readability, but it is not
required.

The {\tt CREATE TABLE} command is entered interactively at a
terminal, or as embedded in an application program.  Note that the
list of column definitions is enclosed in parentheses and that each
column definition is separated from the next column definition by a
comma.  In all examples in this text, each SQL statement is shown in
uppercase letters to help you identify what is to be entered.
However, in most cases you actually can enter the statement in either
upper or lowercase.

The first line in the {\tt CREATE TABLE} statement identifies the name of
the table:  {\tt RESUME}.  The next five lines define the five columns that
make up the {\tt RESUME} table.  The data types chosen to define each column
are explained further on in this chapter.

\begin{enumerate}
\item The first column, named RES\_ID, stores the resume's
identification number (ID).
%\chgbarbegin
%Since {\tt NOT NULL} has been included in the
%definition, data for a resume whose ID is unknown will not be stored
%in the RESUME table even if other resume data (name, job wanted,
%education) is known.
%\chgbarend
Five characters are allowed for a Resume ID,
following Acme internal naming conventions of a letter followed by up
to 4 other characters; e.g., `\verb`R243`' or `\verb`R-376`'.

\item The second column, named RNAME, stores the name of the resume's
job applicant.  No name longer than 15 characters can be stored in
this column.

\item The third column, named JOB, stores the job or jobs the person
is applying for.  A maximum of 15 characters is allowed for this
column.

\item The fourth column, named EDUC, stores a brief description of the
applicant's education.  A maximum of 60 characters is allowed for this
column.  Note:  One could choose to define EDUC with VARCHAR rather
than CHAR, so that a full educational description could be entered
without regard to waste of allocated space.

\item The fifth column, named EXP, stores the full text description of
the applicant's job experience as included in the resume.  You have
two choices for the text field:

 \begin{enumerate}
 \item You can store the entire description in the Texis table.  This
 is useful for short descriptive lines, for abstracts of one or more
 paragraphs, or for short reports of one to two pages as depicts the
 usual resume.  Data type would be defined as a variable length
 character VARCHAR(x) where X indicates the suggested number of
 characters.

 \item You can store filenames in the Texis table.  In this case Texis
 would use the filename to direct it to the text of the actual file.
 Data type would be defined as INDIRECT.
 \end{enumerate}

In our EXP text column for the RESUME table we have chosen to store
the full text in the Texis table, as concept searches of this column
are part of almost every resume search request.  If we only
occasionally referred to the full text content, we might prefer to
store filenames which would point to the full text only when
necessary.
\end{enumerate}

Tables defined with the {\tt CREATE TABLE} command are referred to as {\em
base tables}.  The table definition is automatically stored in a data
dictionary referred to as the {\em system catalog}.  This catalog is
made up of various tables that store descriptive and statistical
information related to the database.  The catalog can be accessed to
retrieve information about the contents and structure of the database.
The system catalog is discussed in more detail in
Chapter~\ref{chp:AdmDB}.

As shown in Figure~\ref{fig:CrTab}, the {\tt CREATE TABLE} command results
in an empty table.

\begin{figure}
\caption{RESUME Table after the {\tt CREATE TABLE} Command}{\label{fig:CrTab}}
\begin{screen}
\begin{verbatim}
  RES_ID RNAME            JOB            EDUC         EXP


  (No data is stored in the table at the time it is created.)
\end{verbatim}
\end{screen}
\end{figure}

\section{Inserting Data into the Resume Table}

Once the table has been created, and before any data can be retrieved,
data must be added to the table using the \verb`INSERT` command.  The first
row is added to the RESUME table as follows.

If you enter:
\begin{verbatim}
     INSERT INTO RESUME
     VALUES ('R323','Perkins, Alice','Snr Engineer',
             'M.B.A. 1984 George Washington Univ',
             'Presently employed at ...') ;
\end{verbatim}
% MAW 09-16-94 - comment following
%the message displayed on the screen will be
%\begin{verbatim}
%     1 Record Created
%\end{verbatim}

{\bf Syntax Notes:}
\begin{itemize}
\item Columns defined as CHAR (character) and VARCHAR (variable length
character) have values enclosed in single quotes.

\item Parentheses must be placed around the set of data values.

\item Each data value is separated by a comma.

\item A long full text column such as job experience, would be loaded
by a program function rather than manually typed in.
\end{itemize}

In the above statement, one row of data was stored in the RESUME
table.  Figure~\ref{fig:InsTab} shows the RESUME table after the first
record has been added.

\begin{figure}
\caption{RESUME Table with One Row Inserted}{\label{fig:InsTab}}
\begin{screen}
\begin{verbatim}
RES_ID RNAME          JOB          EDUC       EXP

R323   Perkins, Alice Snr Engineer M.B.A. ... Presently employed ...

\end{verbatim}
\end{screen}
\end{figure}

To add the second row into the RESUME table, you enter the \verb`INSERT`
command again.

If you enter
\begin{verbatim}
     INSERT INTO RESUME
     VALUES ('R421','Smith, James','Jr Analyst',
             'B.A. 1982 Radford University'
             'Experience has been in ...') ;
\end{verbatim}
% MAW 09-16-94 - comment following
%the message displayed on the screen will be
%\begin{verbatim}
%     1 Record Created
%\end{verbatim}

Figure~\ref{fig:Ins2Tab} shows the contents of the RESUME table after
two rows have been added.

\begin{figure}
\caption{RESUME Table with Two Rows Inserted}{\label{fig:Ins2Tab}}
\begin{screen}
\begin{verbatim}
RES_ID RNAME          JOB          EDUC       EXP

R323   Perkins, Alice Snr Engineer M.B.A. ... Presently employed ...
R421   Smith, James   Jr Analyst   B.A. ...   Experience has been ...

\end{verbatim}
\end{screen}
\end{figure}

Additional \verb`INSERT` commands are used to enter the RESUME data, as was
illustrated in Figure~\ref{fig:Ins2Tab}.  A more complete description
of the \verb`INSERT` command appears in Chapter~\ref{chp:DBCurr}.

\section{Defining a Table}

As illustrated in the creation of the RESUME table, tables are created
in Texis when you specify their structure and characteristics by
executing a {\tt CREATE TABLE} command.

{\samepage
The form of this command is:
\begin{verbatim}
     CREATE TABLE [table-type] table-name
       (column-name1 data-type
        [, column-name2 data-type] ...) ;
\end{verbatim}
%\begin{verbatim}
%     CREATE TABLE  table-name
%       (column-name1 data-type [NOT NULL]
%        [, column-name2 data-type [NOT NULL] ] ...) ;
%\end{verbatim}
}
{\bf Syntax Notes}:
A SQL statement may contain optional clauses or keywords.  These
optional parts are included in the statement only if needed.  Any
clause within brackets `\verb`[ xxx ]`' indicates an optional clause.

\subsubsection{Command Discussion}

The {\tt CREATE TABLE} command gives the name of the table, the name of each
column in the table, and the type of data placed in each column.  It
can also indicate whether null values are permitted in columns.

\begin{description}
% MAW 09-16-94 - doc dos fn limit 8 chars and case significance
% MAW 09-16-94 - wtf doc dos index fn limit somewhere (2 less than table)

\item[Table Type:] When creating a table you can optionally specify a
table type.  A standard database table will be created if no type is
specified.

Specifying a \verb`RAM` table will create a table that only exists in
memory for the current database connection.  The table is not added
to the system catalog, and is not visible to other database connections.
It can be used as a temporary working table in an application.  Within
Vortex a \verb`<sqlcp cache close>` or switching databases may remove
the temporary table.

A \verb`BTREE` table creates a table that is inherently indexed by
the fields in the order listed.  You can not create other indexes on
a \verb`BTREE` table.  This can be useful for key-lookup tables that
have a lot of small rows.

\item[Table Names:] Each table in Texis is assigned a name.  A table
name can have up to 18 characters (case is significant).  The first
character must be a letter, but the remaining characters can include
numbers, letters, and the underscore (\verb`_`) character.  Table names
may not be the same as SQL keywords or data types.  For example,
\verb`RESUME`, \verb`BUDGET93`, and \verb`PROD_TEST` are all valid table
names.  On MSDOS based systems table names must be unique regardless of
case in the first 8 characters.

\item[Column Names:] A column stores data on one attribute.  In our
example, we have attributes such as Resume ID, job sought, education,
and experience.  Each column within a table has a unique name and may
consist of up to 18 characters (case is significant).  The first
character must be a letter and the remaining characters may consist of
letters, numbers, and the underscore (\verb`_`) character.  No blank
spaces are allowed in the column name.  Table names may not be the same
as SQL keywords or data types.  Table~\ref{tab:Names} shows examples of
valid and invalid column names.

\begin{table}
\caption{Valid and Invalid Column Names}{\label{tab:Names}}
\begin{center}
\begin{tabular}{|l|l|l|} \hline
Valid Column Names & Invalid Column Names & Reason Invalid \\ \hline\hline
\verb`EMPNBR`        & \verb`EMP-NBR`       & Hyphen is not allowed.           \\
\verb`EMP_NBR`       & \verb`EMP.NBR`       & Period is not allowed.           \\
\verb`COST1`         & \verb`COST_IN_$`     & \verb`$` is not allowed.               \\
\verb`COST_PER_MILE` & \verb`COST PER MILE` & Spaces are not allowed.          \\
\verb`SALES1991`     & \verb`1991SALES`     & Name cannot start with a number. \\
\verb`Where`         & \verb`WHERE`         & Can not be SQL keyword.          \\
\verb`Date`          & \verb`DATE`          & Can not be SQL data type.        \\ \hline
\end{tabular}
\end{center}
\end{table}

% MAW 09-16-94 - wtf enumerate all data types below? time?
\item[Data Types:] Each column within a table can store only one type
of data.  For example, a column of names represents {\em character}
data, a column storing units sold represents {\em integer} data, and a
column of file dates represents {\em time} data.  In Texis, each
column name defined in the {\tt CREATE TABLE} statement has a data type
declared with it.  These data types include {\em character}, {\em
byte}, {\em integer}, {\em smallint}, {\em float}, {\em double},
{\em date}, {\em varchar}, {\em counter}, {\em strlst}, and {\em indirect}.
Table~\ref{tab:DTypes} illustrates the general format for each data
type.  A description of each of the Data Types listed in
Table~\ref{tab:DTypes} follows.

\begin{table}
\caption{Data Types Used in Texis}{\label{tab:DTypes}}
\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
Type of Data & Texis Syntax      & Example      & Data Value                \\ \hline\hline
Character    & CHAR(length)      & CHAR(10)     & SMITH                     \\
Character    & CHARACTER(length) & CHAR(25)     & 10 Newman Rd              \\
Byte         & BYTE(length)      & BYTE(2)      & DE23                      \\
Numeric      & LONG              & LONG         & 657899932                 \\
Numeric      & INTEGER           & INTEGER      & 657899932                 \\
Numeric      & SMALLINT          & SMALLINT     & -432                      \\
Numeric      & FLOAT             & FLOAT        & 8.413E-04                 \\
Numeric      & DOUBLE            & DOUBLE       & 2.873654219543E+100       \\
Numeric      & UNSIGNED INTEGER  & UNSIGNED INTEGER & 4000000000            \\
Numeric      & UNSIGNED SMALLINT & UNSIGNED SMALLINT & 60000                \\
Date/Time    & DATE              & DATE         & 719283474                 \\
Text         & VARCHAR(length)   & VARCHAR(200) & ``The subject of \ldots'' \\
Text         & INDIRECT          & INDIRECT     & Filename                  \\
Counter      & COUNTER           & COUNTER      & 2e6cb55800000019          \\
String list  & STRLST            & STRLST       & apple,orange,peach,       \\ \hline
\end{tabular}
\end{center}
\end{table}

\begin{description}
\item[CHAR(length):] Used to store character data, such as names, job
titles, addresses, etc.  Length represents the maximum number of
characters that can be stored in this column.  CHAR can hold the value
of any ASCII characters 1-127.  Unless you want to limit the size of
the field absolutely you should in general use VARCHAR instead as it
is more flexible.

\item[CHARACTER(length):] Same as CHAR, used to store character data,
an alternate supported syntax.  As with CHAR, length represents the
maximum number of characters that can be stored in this column.

\item[BYTE:] Similar to CHAR but with significant differences, BYTE is
used to store any unsigned (non-negative) ASCII values from 0-255.
Specifying BYTE indicates each is a one byte quantity.  A byte would
be used where you want to store a small number less than 255 such as
age, or perhaps a flag.  A VARBYTE can also be used where the length
of specified characters is variable rather than fixed, where you are
storing arbitrary binary data.

\item[LONG:] Used to store large whole numbers; i.e., those without
a fractional part, such as population, units sold, sales in dollars.
The range of long values will depend on the platform you are using.
For most platforms it is identical to INTEGER.

\item[INTEGER:] Used to store large whole numbers where you want to
ensure a 32-bit storage unit.
The largest integer value is +2147483647.  The smallest integer value
is -2147483648.

\item[UNSIGNED INTEGER:] Used for similar purposes as INTEGER when
you know the number will never be less than zero.  It also extends
the maximum value from 2,147,483,647 to 4,294,967,295.  This is
synonymous with DWORD.

\item[SMALLINT:] Used to store small whole numbers that require few
digits; for example, age, weight, temperature.  The largest value is
+32,767.  The smallest value is -32,768.

\item[UNSIGNED SMALLINT:] Can store positive numbers in the range from
0 to 65,535.  Can be used in many of the same places as SMALLINT.

\item[INT64:] Used to store large whole numbers when a 64-bit quantity
must be assured (LONG size varies by platform).  Value range is
-9,223,372,036,854,775,808 through +9,223,372,036,854,775,807.
Added in version 6.

\item[UINT64:] Similar to INT64, but unsigned.  Value range is
0 through 18,446,744,073,709,551,616.  Added in version 6.

\item[FLOAT:] Used to store real numbers where numerical precision is
important.  Very large or very small numbers expressed in scientific
notation (E notation).

\item[DOUBLE:] Used to hold large floating point numbers.  Having the
characteristics of a FLOAT, its precision is greater and would be used
where numerical precision is the most important requirement.

\item[DATE:] Used to store time measured in integer seconds since 00:00:00 Jan.
1 1970, GMT (Greenwich mean time).  When entered in this fashion the
format is an integer representing an absolute number of seconds; e.g.,
\verb`719283474`.  The DATE data type is used to avoid confusions
stemming from multi-sourced information originating from different time
zone notations.  This data type is entered by a program function rather
than manually, and would generally be converted to calendar time before
being shown to the user.  DATEs may also be entered as strings
representing a date/time format such as \verb`'1994-03-05 3:00pm'`

\item[VARCHAR(length):] Used to store text field information entirely
in Texis.  The specified length is offered as a suggestion only, as
this data type can hold an unlimited number of characters.  In the
example in Table~\ref{tab:DTypes}, there may be a short description of
the text, or a relatively small abstract which is stored in the field
of the column itself.

% MAW 09-16-94 - comment blob out
% JMT 1999-07-22 - restore
\item[BLOB:] Used to store text, graphic images, audio,
and so on, where the object is not stored in the table itself, but is
indirectly held in a BLOB field.  BLOB stands for
Binary Large Object, and can be used to store the content of many fields
or small files at once, eliminating the need for opening and closing
many files while performing a search.  BLOB is used when having a specific
filename is not desired.  The BLOB is created and managed at a system
level.  The total data held for all BLOBs in a table is limited by the
filesystem.  The BLOB file is not accessed unless the data in it is needed.
This will improve the performance of queries that do not need to access
the data.  This can also be useful if you are creating a METAMORPH
INVERTED index, and do not allow post processing, and do not display the
actual contents of the record, as the data will not be accessed at all,
and can be removed.  This should only be done with extreme caution.

% JMT 2011-03-14 - BLOBZ
\item[BLOBZ:] Similar to BLOB fields, except that each BLOBZ's data is
  compressed before storing on disk, and is decompressed upon reading
  from disk.  The compression/decompression is done internally.
  Alternatively, it can be handled externally via the executables
  specified by the {\tt Blob Compress EXE} and {\tt Blob Uncompress EXE}
  commands in the \verb`[Texis]` section of the
  \verb`texis.ini` configuration file.  External compression allows
  custom compression types to be deployed -- perhaps better than the
  \verb`gzip` format supported internally by Texis -- but at a speed
  penalty due to the overhead of running the executables.  The BLOBZ
  type is only supported in Texis Version 8 and later.

% MAW 09-16-94 - wtf sentence 3 make no sense to me
\item[INDIRECT:] Used to store filenames which point to data stored in
some other location.  Most frequently an INDIRECT column would point
to files containing quantities of full text.
%INDIRECT has an implicit
%length of one filename, where file specific information is stored with
%each file; i.e, one record per file.  These filenames would be loaded
%by a program function, rather than manually.
Only one filename may be stored in an INDIRECT field.  The filenames
can be inserted with SQL by specifying the filename as a string, or
through a program, which might generate the files to store the data.
The choice of storing
text or filenames only in Texis will depend on what you plan to do
with the files, and also how big they are.  INDIRECT can be used to
point to images or other objects as well as text, although currently
only text files can be meaniningfully indexed.

\item[COUNTER:] This field holds an 8 byte value, which can be made
unique across all tables in the database.  To insert a counter
value in SQL you can use the \verb`COUNTER` keyword in the insert clause.
A counter is made up of two fields, a time, and a sequence number.
This allows the field to be compared with times, to find all records
inserted before a particular time for example.

\item[STRLST:] A string list is used to hold a number of different
strings.  The strings are delimited by a user defined character in the
input string.  The delimiter character is printed as the last
character in the result string when a \verb`strlst` value is converted
to a \verb`varchar` result string (this aids conversion back to
\verb`strlst` when the \verb`varchartostrlstsep` setting,
p.~\pageref{`varchartostrlstsep'}, is ``\verb`lastchar`'').  This type
is most useful when combined with an application which needs lists of
strings, and set-like operators such as {\tt IN}, {\tt SUBSET} or {\tt
INTERSECT}.  Other operators are generally undefined for {\tt strlst},
though in Texis version 7 and later equality (``\verb`=`'' comparison
etc.) is defined to be monolithic string-compare of the entire list;
equality of {\tt strlst} and {\tt varchar} is the same, treating the
{\tt varchar} as a one-item strlst (if non-empty) or empty strlst (if
empty).
\end{description}

One large difference in Texis over other database management systems
is in the range of data types it supports.  While the traditional
fixed length forms of CHAR, INTEGER, FLOAT and so on are used, there
is a corresponding variable length data type which can be used when
appropriate, such as is represented in VARCHAR.

The length following CHAR, as in \verb`CHAR(100)`, indicates that 100
is the maximum number of allowed characters.  Each record with such a
data type defined will have a size of 100 characters, regardless of
whether 3 characters, 57 characters, or even a NULL value is entered.
The length following VARCHAR, as in \verb`VARCHAR(100)`, indicates
that 100 characters is a suggested length.  If an entry of 350
characters is required in this field, VARCHAR can make allowances to
handle it.

The 100 character suggestion in this case is used for memory
allocation, rather than field length limitation.  Therefore a VARCHAR
length should be entered as the average, rather than the largest size
for that field.  Entering an extremely large length to accommodate one
or two unusual entries would impair the handling of memory for normal
operations.

The sophisticated aspects of database design involving choice and use
of data types towards performance and optimization of table
manipulation are addressed in more depth in Chapter~\ref{chp:AdmDB},
{\em Administration of the Database}.

%\item[{\tt NOT NULL} Keyword:] \chgbarbegin In the definition of a column, the {\tt NOT NULL}
%keyword is optional.  If a {\tt NOT NULL} keyword is specified, the column
%may not contain a null, or unknown, value.  Any attempt to place a
%null value in such a column is rejected.  For example, assume the {\tt NOT
%NULL} keyword is part of the definition of Resume ID, a column in the
%RESUME table.  In this case, if you tried to add a resume that didn't
%include a Resume ID, you would not be able to add the record to the
%table.
%
%If {\tt NOT NULL} is omitted from a column definition, then a NULL value can
%be assigned to that column if the value is unknown.  For example,
%assume the definition of the resume name, job, and education columns
%does not include the {\tt NOT NULL} keyword.  Then, even though a resume's
%applicant name is not known (or job, education, or experience for that
%matter), the resume's record can be added to the table.  In the case
%of the resume's name, a null value is assigned. \chgbarend

The order in which the columns are listed in the {\tt CREATE TABLE} command
is the order in which the column names will appear in the table.
\end{description}

\section{Removing a Table}

When a table is no longer needed, it is deleted with the {\tt DROP TABLE}
command.  The format of this command is:
\begin{verbatim}
     DROP TABLE  table-name ;
\end{verbatim}

The information about the indicated table is removed from the system
catalog tables that Texis maintains on all tables in the database.  In
effect, you can no longer access, add, modify, or delete data stored
in the table.  From the user's viewpoint, the table definition and the
data stored in the table have been eliminated.

Indirect files referenced within the dropped table are not deleted
unless they are Texis managed indirects under the database. So if
you have indirects pointing to your own word processor files, they
won't be lost when the table is dropped.
% MAW 09-16-94 - wtf make texis rm texis managed indirects for table

For example, if the RESUME table becomes no longer needed, you can
delete this table.  If you enter the following:
\begin{verbatim}
     DROP TABLE  RESUME;
\end{verbatim}
% MAW 09-16-94 - comment following
%The message displayed will be:
%\begin{verbatim}
%     Table Dropped
%\end{verbatim}

This chapter has covered the creation and dropping of tables in Texis.
You were also shown how to insert data into a table.  In the next
chapter, you will begin to learn how to query the database, the most
important feature of Texis in differentiating its operation from other
database management systems.

\chapter{A First Look at Queries}{\label{chp:Quer}}

Texis uses a query language that gives users access to data stored in
a relational database.  The data manipulation component of this
language enables a user to:

\begin{itemize}
\item Write queries to retrieve information from the database.
\item Modify existing data in the database.
\item Add new data to the database.
\item Delete data from the database.
\end{itemize}

In this and the next two chapters, we will review the query
capabilities of Texis.  In Chapter~\ref{chp:DBCurr}, we will study the
update, insert, and delete features of the language.

After the tables have been created and loaded with data, you can
answer requests for information from a database without the help of
professional programmers.  You write a question, also called a query,
that consists of a single statement explaining what the user wants to
accomplish.  Based on this query, the computer retrieves the results
and displays them.  In this chapter you will study some of the simpler
ways to form queries.

In Texis, you retrieve data from tables using the \verb`SELECT` statement,
which consists of one or more \verb`SELECT`-\verb`\verb`FROM``-\verb`WHERE` blocks.  The structure
of this statement, in its simplest form, consists of one block
containing three clauses:  \verb`SELECT`, \verb`FROM`, and \verb`WHERE`.  The form of this
statement follows:
\begin{verbatim}
     SELECT  column-name1 [, column-name2] ...
     FROM    table-name
     [WHERE  search-condition] ;
\end{verbatim}
{\bf Syntax Notes:}
\begin{itemize}
\item The ``\ldots'' above indicates additional column names can be
added.
\item Brackets `\verb`[ ]`' surrounding a clause means the clause is
optional.
\end{itemize}

\subsubsection{Command Discussion}
\begin{description}
\item[\verb`SELECT`:] The \verb`SELECT` clause lists the column names that you want
displayed in answer to the query.

\item[\verb`FROM`:] The \verb`FROM` clause indicates the table of data ``FROM''
which you want to retrieve information.

\item[\verb`WHERE`:] The \verb`WHERE` clause is used to screen the rows you want to
retrieve, based on some criteria, or search condition, that you
specify.  This clause is optional, and, if omitted, all rows from the
table are retrieved.
\end{description}

\section{Retrieving From the Entire Table}

For this example, we will use a REPORT table, into which has been
loaded reports submitted by all departments, by title, author, and
reference filename.  A three character department code is used,
defined in long form in another DEPARTMENT table.

To retrieve the columns you want displayed, indicate the column names
after the keyword \verb`SELECT`.  The order in which the column names appear
after the \verb`SELECT` clause is the order in which these columns will be
displayed.

{\bf Example:}
Let's retrieve a list of all report titles.

If you enter the statement:
\begin{verbatim}
     SELECT  TITLE
     FROM    REPORT ;
\end{verbatim}
The result displayed on the screen will be:
\begin{screen}
\begin{verbatim}
  TITLE
  Innovations in Disappearing Ink
  Disappearing Ink Promotional Campaign
  Advertising Budget for 4Q 92
  Improvements in Round Widgets
  Target Market for Colored Paperclips
  Ink Color Panorama
  Departmental Meeting Schedule
\end{verbatim}
\end{screen}

The column name is automatically used as the column heading.

The first line in the \verb`SELECT` statement indicates the column name TITLE
is to be displayed.  The second line indicates that TITLE is found in
the REPORT table.

{\bf Example:}
If you want to display report titles, authors, and department, you
must specify that information in the \verb`SELECT` clause.

If you enter the statement:
\begin{verbatim}
     SELECT  TITLE, AUTHOR, DEPT
     FROM    REPORT ;
\end{verbatim}
where each column name is separated from the next by a comma, and
columns are displayed in the order you specify in the \verb`SELECT` clause,
the result displayed on the screen will be:

\begin{screen}
\begin{verbatim}
  TITLE                                  AUTHOR            DEPT
  Innovations in Disappearing Ink        Jackson, Herbert  RND
  Disappearing Ink Promotional Campaign  Sanchez, Carla    MKT
  Advertising Budget for 4Q 92           Price, Stella     FIN
  Improvements in Round Widgets          Smith, Roberta    RND
  Target Market for Colored Paperclips   Aster, John A.    MKT
  Ink Color Panorama                     Jackson, Herbert  RND
  Departmental Meeting Schedule          Barrington, Kyle  MGT
\end{verbatim}
\end{screen}

% ----------------------------------------------------------------------------
\subsection{Retrieving All the Columns}

You don't need to know the column names to select data from a table.
By placing an asterisk (*) in the \verb`SELECT` clause, all columns of the
table identified in the \verb`FROM` clause will be displayed.  This is an
alternative to listing all the column names in the \verb`SELECT` clause.

{\bf Example:}
Let's look at all the data stored in the REPORT table.

If you enter the statement
\begin{verbatim}
     SELECT  *
     FROM    REPORT ;
\end{verbatim}
the result displayed on the screen will be

\begin{screen}
\begin{verbatim}
  TITLE                        AUTHOR           DEPT FILENAME
  ... Disappearing Ink         Jackson, Herbert RND  /docs/rnd/ink.txt
  ... Ink Promotional Campaign Sanchez, Carla   MKT  /docs/mkt/promo.rpt
  ... Budget for 4Q 92         Price, Stella    FIN  /docs/ad/4q.rpt
  ... Round Widgets            Smith, Roberta   RND  /docs/rnd/widg.txt
  ... Paperclips               Aster, John A.   MKT  /docs/mkt/clip.rpt
  ... Color Panorama           Jackson, Herbert RND  /docs/rnd/color.txt
  ... Meeting Schedule         Barrington, Kyle MGT  /docs/mgt/when.rpt
\end{verbatim}
\end{screen}

% ----------------------------------------------------------------------------
%\subsection{Removing Duplicate Rows}
%
%\chgbarbegin The results of a query may include duplicate rows.  Sometimes the
%duplicates do not provide you with the precise answer you want, so you
%may want to eliminate them.
%
%The use of DISTINCT in the \verb`SELECT` clause eliminates duplicate rows.
%As a result, the row is displayed only once.
%
%{\bf Example:}
%Who has authored reports which have been submitted for shared use in
%the corporate library?
%
%If you enter:
%\begin{verbatim}
%     Version A:                 Version B:
%
%     SELECT  AUTHOR             SELECT  DISTINCT AUTHOR
%     FROM    REPORT ;           FROM    REPORT ;
%\end{verbatim}
%the result displayed would differ as follows:
%
%\begin{screen}
%\begin{verbatim}
%  Version A:                 Version B:
%
%  AUTHOR                     AUTHOR
%  Jackson, Herbert           Jackson, Herbert
%  Sanchez, Carla             Sanchez, Carla
%  Price, Stella              Price, Stella
%  Smith, Roberta             Smith, Roberta
%  Aster, John A.             Aster, John A.
%  Jackson, Herbert           Barrington, Kyle
%  Barrington, Kyle
%\end{verbatim}
%\end{screen}
%
%Compare the results of the two versions.  Notice that the repetition
%of authors is eliminated by using the qualifier DISTINCT.
%
%In Version A, the author ``Herbert Jackson'' appears in sequence, with
%each row retrieved.  As he submitted two reports, he appears twice.
%In Version B, duplications are removed, and only a unique set of
%authors appears in the list selected.
%
%When you use DISTINCT, however, the entire row being displayed must be
%unique.  Otherwise, the row is not considered identical, and it will
%not be removed.  For example:
%
%If you enter the statement:
%\begin{verbatim}
%     SELECT  DISTINCT AUTHOR, TITLE
%     FROM    REPORT ;
%\end{verbatim}
%the result displayed will be:
%
%\begin{screen}
%\begin{verbatim}
%  AUTHOR             TITLE
%  Jackson, Herbert   Innovations in Disappearing Ink
%  Sanchez, Carla     Disappearing Ink Promotional Campaign
%  Price, Stella      Advertising Budget for 4Q 92
%  Smith, Roberta     Improvements in Round Widgets
%  Aster, John A.     Target Market for Colored Paperclips
%  Jackson, Herbert   Ink Color Panorama
%  Barrington, Kyle   Departmental Meeting Schedule
%\end{verbatim}
%\end{screen}
%
%In this query duplicate authors are displayed, since all the row
%combinations (author, title) are unique.  However, if there were more
%than one row with the same (author, title) value (e.g.,
%\verb`'Jackson, Herbert'`, \verb`'Ink Color Panorama'`) only one would
%be displayed. \chgbarend
%
\section{Retrieving a Subset of Rows: Simple Conditions}

Often you don't want to retrieve all the rows in a table but want only
the rows that satisfy one or more conditions.  In this case, you would
include the \verb`WHERE` clause in the \verb`SELECT` statement to retrieve a
portion, or subset, of the rows in a table.

A {\em search condition} expresses the logic by which the computer
determines which rows of the table are retrieved and which are
ignored.  The search condition has many variations.  A simple search
condition is formed with a {\em conditional expression}, which
specifies a comparison between two values.  It has the following
format:
\begin{verbatim}
     expression    comparison operator    expression
\end{verbatim}

The expressions in the conditional expression are usually a column
name or a constant.  The comparison operator indicates a mathematical
comparison such as less than, greater than, equal to, etc.
Table~\ref{tab:CompOp} shows the comparison operators allowed in
Texis.

\begin{table}
\caption{Comparison Operators Supported in Texis}{\label{tab:CompOp}}
\begin{center}
\begin{tabular}{|l|l|} \hline
Type of Comparison       & Texis Symbol \\ \hline\hline
Equal to                 &  \verb`=`        \\
Less than                &  \verb`<`        \\
Less than or equal to    &  \verb`<=`       \\
Greater than             &  \verb`>`        \\
Greater than or equal to &  \verb`>=`       \\
Not equal to             &  \verb`<>` or \verb`!=`  \\ \hline
\end{tabular}
\end{center}
\end{table}

{\bf Example:}
Let's say there is a DEPARTMENT table which has listed in it the
department code, the long form department name, the department head,
the division to which the department belongs, and the annual
department budget.  The conditional expression to find departments
with a budget above \$25,000 can be written:
\begin{verbatim}
     BUDGET > 25000
\end{verbatim}
In this case BUDGET is being compared to a numeric constant.

The conditional expression to find all departments in the Product
Division is written:
\begin{verbatim}
     DIV = 'PROD'
\end{verbatim}
Character constants, sometimes called character strings, are enclosed
in single quotes.  The conditional expression can compare numeric
values to one another or string values to one another as just shown.

Each row in the indicated table is evaluated, or tested, separately
based on the condition in the \verb`WHERE` clause.  For each row, the
evaluation of the conditional expression is either true or false.
When a condition is true, a row is retrieved; when the condition is
false, the row is not retrieved.  For example, if a department has a
\$35,000 budget, then the conditional expression
``\verb`BUDGET > 25000`'' is true and the row is included in the query
result.  However, if the department had a budget of \$15,000, then the
result of the conditional expression ``\verb`BUDGET > 25000`'' is
false and the row is not retrieved.

{\bf Example:}
Let's develop a list of all departments, in long form, in the Product
Division.

Enter the statement:
\begin{verbatim}
     SELECT  DNAME
     FROM    DEPARTMENT
     WHERE   DIV = 'PROD' ;
\end{verbatim}
\verb`'PROD'` is the search condition, and as a character string must
be enclosed in quotes.

The result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME
  Research and Development
  Manufacturing
  Customer Support and Service
  Product Marketing and Sales
\end{verbatim}
\end{screen}

In the \verb`WHERE` clause, the condition ``DIV must equal PROD'' results in
the retrieval of the name of each department in the Product Division.
As only DNAME, the long form departmental name, was requested in the
\verb`SELECT` statement, a list of department names is all that is shown.

{\bf Example:}
Let's develop a list of all departments with a budget above \$25,000.

Enter the statement:
\begin{verbatim}
     SELECT  DNAME, BUDGET
     FROM    DEPARTMENT
     WHERE   BUDGET > 25000 ;
\end{verbatim}
Note that numeric values, as \verb`25000`, are not enclosed in
quotes.

The result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                                BUDGET
  Finance and Accounting               26000
  Corporate Legal Support              28000
  Research and Development             27500
  Manufacturing                        32000
  Strategic Planning and Intelligence  28500
\end{verbatim}
\end{screen}

\section{Retrieving a Subset of Rows: Compound Conditions}

The conditions illustrated in the previous section are called simple
conditions because each involves a single comparison.  It is also
possible to develop more complex conditions involving two or more
conditional expressions.  You combine conditions using the logical
operators {\tt AND}, {\tt OR}, or {\tt NOT} to connect conditional expressions.  When
two or more conditions are combined by logical operators, the
conditional expression is called a {\em compound condition}.  For
example, you may want a list of departments from the Product Division
only with budgets under \$20,000.

The form of the compound condition is:
\begin{verbatim}
     conditional   logical    conditional   logical    conditional
     expression1   operator   expression2   operator   expression3
\end{verbatim}
As with simple conditional expressions, the evaluation of a compound
condition is either true or false, with true resulting in retrieval of
a row and false resulting in no retrieval.

% ----------------------------------------------------------------------------
\subsection{Retrieval Using the {\tt AND} Operator}

When {\tt AND} is used to connect two conditions, each conditional
expression must be true for the condition to be true and the row
retrieved.  If any condition within a compound condition is false, the
compound condition is false and the row is not selected.

For example, if you want to retrieve the records of Corporate Division
Departments with a budget under \$10,000 you can write the following
compound condition:
\begin{verbatim}
     DIV = 'CORP'  AND  BUDGET < 12000
\end{verbatim}
In this example, \verb`AND` is the logical operator.

Table~\ref{tab:LogAnd} illustrates the four possible cases that can
occur with the logical operator {\tt AND} for the compound condition just
described.

\begin{table}
\caption{Logical Operator {\tt AND}}{\label{tab:LogAnd}}
\begin{center}
\begin{tabular}{|lccllll|} \hline
  & Values for  & Values for    & Condition1        & Condition2          &        &               \\
  & \verb`DIV`  & \verb`BUDGET` & \verb`DIV='CORP'` & \verb`BUDGET<12000` & Yields & Row Result    \\ \hline\hline
1 & \verb`CORP` & \verb`10500`  & True              & True                & True   & Retrieved     \\
2 & \verb`CORP` & \verb`28000`  & True              & False               & False  & Not retrieved \\
3 & \verb`PROD` & \verb`11000`  & False             & True                & False  & Not retrieved \\
4 & \verb`PROD` & \verb`27500`  & False             & False               & False  & Not retrieved \\ \hline
\end{tabular}
\end{center}
\end{table}

{\bf Example:}
Based on the above, let's develop a list of departments in the
Corporate Division with a budget under \$12,000.

If you enter the statement:
\begin{verbatim}
     SELECT  DNAME, DIV, BUDGET
     FROM    DEPARTMENT
     WHERE   DIV = 'CORP' AND BUDGET < 12000 ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                         DIV     BUDGET
  Supplies and Procurement      CORP    10500
\end{verbatim}
\end{screen}

% ----------------------------------------------------------------------------
\subsection{Retrieval Using the {\tt OR} Operator}

When {\tt OR} is used to connect two or more conditions, the compound
condition is true if any condition is true, and the row is then
retireved.  However, if all of the conditional expressions are false,
then the row is not selected.

For example, suppose management is interested in any Product Division
department OR any department with a budget of \$28,000 or greater.
This compound condition can be written as follows:
\begin{verbatim}
     DIV = 'PROD'  OR  BUDGET >= 28000
\end{verbatim}
In this case {\tt OR} is the logical operator used.

Table~\ref{tab:LogOr} illustrates the four possible cases that can
occur with the logical operator {\tt OR} for the example just given.

\begin{table}
\caption{Logical Operator {\tt OR}}{\label{tab:LogOr}}
\begin{center}
\begin{tabular}{|lccllll|} \hline
  & Values for  & Values for    & Condition1        & Condition2          &        &               \\
  & \verb`DIV`  & \verb`BUDGET` & \verb`DIV='PROD'` & \verb`BUDGET>=28000` & Yields & Row Result    \\ \hline\hline
1 & \verb`PROD` & \verb`32000`  & True              & True                & True   & Retrieved     \\
2 & \verb`PROD` & \verb`27500`  & True              & False               & True   & Retrieved     \\
3 & \verb`CORP` & \verb`28000`  & False             & True                & True   & Retrieved     \\
4 & \verb`CORP` & \verb`10500`  & False             & False               & False  & Not retrieved \\ \hline
\end{tabular}
\end{center}
\end{table}

{\bf Example:}
Based on the above, let's develop a list of departments for management
review, which are either in the Product Division or which have budgets
of \$28,000 or greater.

If you enter the statement:
\begin{verbatim}
     SELECT  DNAME, DIV, BUDGET
     FROM    DEPARTMENT
     WHERE   DIV = 'PROD' OR BUDGET >= 28000 ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                                DIV     BUDGET
  Corporate Legal Support              CORP    28000
  Research and Development             PROD    27500
  Manufacturing                        PROD    32000
  Customer Support and Service         PROD    11000
  Product Marketing and Sales          PROD    25000
  Strategic Planning and Intelligence  INFO    28500
\end{verbatim}
\end{screen}

% ----------------------------------------------------------------------------
\subsection{Retrieval Using Both {\tt AND} and {\tt OR} Operators}

Compound conditions can include both {\tt AND} and {\tt OR} logical operators.

{\bf Example:}
If you enter the query:
\begin{verbatim}
     SELECT  DNAME, DIV, BUDGET
     FROM    DEPARTMENT
     WHERE   DIV = 'CORP'  AND  BUDGET < 12000  OR  DIV = 'PROD' ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                         DIV     BUDGET
  Supplies and Procurement      CORP    10500
  Research and Development      PROD    27500
  Manufacturing                 PROD    32000
  Customer Support and Service  PROD    11000
  Product Marketing and Sales   PROD    25000
\end{verbatim}
\end{screen}

When you have a combination of {\tt AND} and {\tt OR} operators, the {\tt AND} operators
are evaluated first; then the {\tt OR} operators are evaluated.  Therefore,
in the above query, rows from the DEPARTMENT table are retrieved if
they satisfy at least one of the folloiwng conditions:

\begin{enumerate}
\item The department is in the Corporate Division with a budget under
\$12,000.

\item The department is in the Product Division.
\end{enumerate}

% ----------------------------------------------------------------------------
\subsection{Retrieval Using Parentheses}

Parentheses may be used within a compound condition to clarify or
change the order in which the condition is evaluated.  A condition
within parentheses is evaluted before conditions outside the
parentheses.

{\bf Example:}
Retrieve the department name, division name, and budget of all
departments who have a budget of less than \$12,000, and who are
either in the Corporate or the Product Division.

If you enter the query:
\begin{verbatim}
     SELECT  DNAME, DIV, BUDGET
     FROM    DEPARTMENT
     WHERE   BUDGET < 12000
       AND   (DIV = 'CORP' OR DIV = 'PROD') ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                         DIV     BUDGET
  Supplies and Procurement      CORP    10500
  Customer Support and Service  PROD    11000
\end{verbatim}
\end{screen}

This query retrieves rows from the DEPARTMENT table that satisfy both
of the following conditions:

\begin{enumerate}
\item The department has a budget of under \$12,000.

\item The department is in either the Corporate Division or the
Product Division.
\end{enumerate}

% ----------------------------------------------------------------------------
\subsection{Logical Operator {\tt NOT}}

The logical operator {\tt NOT} allows the user to express conditions that
are best expressed in a negative way.  In essence, it reverses the
logical value of a condition on which it operates.  That is, it
accepts all rows except those that satisfy the condition.  You write
the conditional expression with the keyword {\tt NOT} preceding the
condition:
\begin{verbatim}
     WHERE  NOT  condition
\end{verbatim}

The condition can be a simple condition or a condition containing
{\tt AND}s and {\tt OR}s.  The compound condition using {\tt NOT} is true if the
condition following {\tt NOT} is false; and the compound condition is false
if the condition following {\tt NOT} is true.

For example, suppose you are looking for all departments who are not
in the Corporate Division.  You can write the conditional expression:
\begin{verbatim}
     NOT (DIV = 'CORP')
\end{verbatim}
Parentheses are optional but are included to improve readability of
the condition.

If a department is in the Product Division, the program evaluates the
condition in the following manner:

\begin{center}
\begin{tabular}{|l|l|} \hline
Evaluation Process                     & Comments                                        \\ \hline\hline
Step 1:  \verb`NOT (DIV = 'CORP')`     & Original condition.                             \\ \hline
Step 2:  \verb`NOT ('PROD' = 'CORP')`  & Substitute \verb`PROD` for \verb`DIV`.          \\ \hline
Step 3:  \verb`NOT` (false)`           & Since \verb`PROD` does not equal \verb`CORP`,   \\
                                       & the condition \verb`DIV = 'CORP'` is false.     \\ \hline
Step 4:  true                          & {\tt NOT} changes false to true,                      \\
                                       & the row is retrieved.                           \\ \hline
\end{tabular}
\end{center}

{\tt NOT} is typically used with logical operators such as {\tt IN}, {\tt BETWEEN},
\verb`LIKE`, etc., which will be covered in a later section.

In the query condition \verb`NOT (DIV = 'CORP')`, you are more likely
to write the condition as follows:
\begin{verbatim}
     WHERE DIV != 'CORP'
\end{verbatim}
In this query the `\verb`!=`' operator is used to show that \verb`DIV`
must not be equal to \verb`CORP`.

{\bf Example:}
The {\tt NOT} operator can be used with more than one expression.  List all
departments except those in the Corporate Division or those in the
Product Divison.

Enter the statement:
\begin{verbatim}
     SELECT  DNAME, DIV
     FROM    DEPARTMENT
     WHERE   NOT (DIV = 'CORP' OR DIV = 'PROD') ;
\end{verbatim}
Note that \verb`NOT` precedes the entire condition.

The result displayed will be:
\begin{screen}
\begin{verbatim}
  DNAME                                  DIV
  Information Systems Management         INFO
  Corporate Library                      INFO
  Strategic Planning and Intelligence    INFO
\end{verbatim}
\end{screen}

This statement retrieves the department and division name for all
departments which are not Corporate or Product, revealing a division
not yet retrieved in the previous searches, the Information Division.

\section{Additional Comparison Operators}

Texis has several special comparison operators for use with search
conditions.  These operators are indicated by the keywords {\tt
BETWEEN}, {\tt IN}, {\tt SUBSET}, {\tt INTERSECT}, \verb`LIKE`,
\verb`LIKER`, \verb`LIKEP` and \verb`LIKE3`, \verb`LIKEIN`.

% ----------------------------------------------------------------------------
\subsection{Range and Geographical Searches Using {\tt BETWEEN}}

The {\tt BETWEEN} operator allows you to select rows of data in a given
column if data in a given column contain values within a range.  The
general form of this operator is:
\begin{verbatim}
     expression  [NOT]  BETWEEN  lower value  AND  upper value
\end{verbatim}

The condition is true if the expression is greater than or equal to
the lower value and less than or equal to the upper value.  If the {\tt NOT}
operator is used, the row is retrieved if the expression is less than
the lower value or greater than the upper value.

{\bf Example:}
Let's find all departments whose budgets are between \$15,000 and
\$25,000.

If you enter the statement:
\begin{verbatim}
     SELECT  DNAME, BUDGET
     FROM    DEPARTMENT
     WHERE   BUDGET  BETWEEN  15000  AND  25000 ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                              BUDGET
  Product Marketing and Sales        25000
  Corporate Library                  18500
  Information Systems Management     22500
\end{verbatim}
\end{screen}

The name of each department whose budget is between \$15,000 and
\$25,000 is retrieved.  The limits include any budget of \$15,000 and
of \$25,000; thus the Product Marketing and Sales Department with a
budget matching the upper limit has been included.

The {\tt AND} logical operator can also be used to form a query that selects
values from a range.  A query similar to the last example would look
like the following.

If you enter the following statement:
\begin{verbatim}
     SELECT  DNAME, BUDGET
     FROM    DEPARTMENT
     WHERE   BUDGET >= 15000  AND  BUDGET <= 25000 ;
\end{verbatim}
the result displayed will still be:

\begin{screen}
\begin{verbatim}
  DNAME                              BUDGET
  Product Marketing and Sales        25000
  Corporate Library                  18500
  Information Systems Management     22500
\end{verbatim}
\end{screen}

Notice that the results are identical to the output in example where
{\tt BETWEEN} was used in the \verb`WHERE` clause.

The {\tt BETWEEN} operator can be modified with the logical operator {\tt NOT} so
that rows outside a range will be selected.

{\bf Example:}
List the names of all departments who do not have a budget in the
range of \$15,000 to \$25,000.

If you enter the statement:
\begin{verbatim}
     SELECT  DNAME, BUDGET
     FROM    DEPARTMENT
     WHERE   BUDGET  NOT  BETWEEN  15000  AND  25000 ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                                BUDGET
  Corporate Legal Support              28000
  Supplies and Procurement             10500
  Customer Support and Service         11000
  Manufacturing                        32000
  Research and Development             27500
  Strategic Planning and Intelligence  28500
\end{verbatim}
\end{screen}

This statement retrieves the names of all departments with budgets
lower than \$15,000 or higher than \$25,000.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Geographical Searches with {\tt BETWEEN}}

A second form of \verb`BETWEEN` is used for doing geographical searches.
In this form the operator is used as:

\begin{verbatim}
    location [NOT] BETWEEN (corner1, corner2)
\end{verbatim}

(The parentheses are significant, and distinguish the special
two-dimensional geographical form of \verb`BETWEEN` from the normal
one-dimensional range search.)  The \verb`location`, \verb`corner1`
and \verb`corner2` values all represent single geographical
(latitude/longitude) points -- ``geocode'' values.  This form of the
\verb`BETWEEN` operator will be true for all \verb`location` points
that are within (or on) the rectangular box defined by
diagonally-opposite corners \verb`corner1` and \verb`corner2`.

The left-side \verb`location` must be a \verb`long` value.  It is a
geographically-encoded (``geocode'') value, returned from the SQL
function \verb`latlon2geocode()` or the Vortex function
\verb`<geo2code>`.  Typically \verb`location` is a \verb`long` geocode
column in a table representing the physical location of a row's data.

The right-side \verb`corner1` and \verb`corner2` points define
diagonally-opposite corners of the bounding box.\footnote{Prior to
version 5.01.1194489000 20071107, the box had to be specified as
``lower-left'', ``upper-right'' (i.e. SW, NE) only.  In that version
(and later), other diagonal combinations (i.e. NW, SE) are supported.}
They are typically also \verb`long` geocode values.  However, in
version 5.01.1194651000 20071109 and later, they may each be a single
\verb`varchar` (text) value containing a space- or comma-separated
latitude/longitude pair, which will automatically be converted to
geocode format.  E.g.:

\begin{verbatim}
   location BETWEEN ('40N 80W', '41N 81W')
\end{verbatim}

In version 6.00.1298946000 20110228 and later, the bounding box may be
computed inline from coordinates with \verb`latlon2geocodebox()`;
e.g. for a 0.5-degree ``radius'' bounding box centered on 40.5N, 80.5W:

\begin{verbatim}
  location BETWEEN (select latlon2geocodebox(40.5, -80.5, 0.5))
\end{verbatim}

When used in conjunction with a regular index on the \verb`expression`
column, the \verb`BETWEEN` operator can greatly speed up geographical
searches, as it reduces a two-dimensional {\tt AND} search (with its
potentially large merge or post-process) into a single-dimensional,
all-index operation.

% ----------------------------------------------------------------------------
\subsection{Set-like Searches Using {\tt IN}, {\tt SUBSET} and {\tt INTERSECT}}

  The {\tt IN}, {\tt SUBSET} and {\tt INTERSECT} operators can be used
for set-like searches on multi-value type fields such as
\verb`strlst`.  For example, to find rows where a query term is
present in a {\tt strlst} column, use {\tt IN}.  To find rows where a
\verb`strlst` column contains {\em any} of a list of query terms, use
{\tt INTERSECT} to find the set intersection of the row and the query
set.  To find rows where {\em all} query terms must be present in the
row, use {\tt SUBSET}.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Searches Using {\tt IN}}

%\chgbarbegin
The {\tt IN} operator is used to select rows that match one of several
listed values.  In Texis version 7 and later it behaves similar to the
{\tt SUBSET} operator (p.~\pageref{SubsetOperator}), i.e. it is true
if all left-side value(s) are also present on the right-side.  (See
below for version 6 and earlier differences.)

The format of this operator is:
\begin{verbatim}
     expression [NOT] IN (value1, value2, value3 ...)
\end{verbatim}

Value1, value2, and so on indicates a list of values.  Enclose the
entire list in parentheses.  Separate items in the list by commas.

{\bf Example:}
Let's list all departments in either the Corporate, Product, or
Information divisions.

Enter the statement:
\begin{verbatim}
     SELECT  DNAME, DIV
     FROM    DEPARTMENT
     WHERE   DIV IN ('CORP', 'PROD', 'INFO') ;
\end{verbatim}
The row is retrieved if a department's division is in the set of
divisions.

The result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                                DIV
  Management and Administration        CORP
  Finance and Accounting               CORP
  Corporate Legal Support              CORP
  Supplies and Procurement             CORP
  Recruitment and Personnel            CORP
  Research and Development             PROD
  Manufacturing                        PROD
  Customer Support and Service         PROD
  Product Marketing and Sales          PROD
  Information Systems Management       INFO
  Corporate Library                    INFO
  Strategic Planning and Intelligence  INFO
\end{verbatim}
\end{screen}

A semantically equivalent (but usually less efficient) query can be
formed using the logical operator {\tt OR}.  It looks like the
following:
\begin{verbatim}
     SELECT  DNAME, DIV
     FROM    DEPARTMENT
     WHERE   DIV = 'CORP'  OR  DIV = 'PROD'  OR  DIV = 'INFO' ;
\end{verbatim}

The right-side of the {\tt IN} operator may also be a \verb`strlst`
table column, in which case for each row, the left-side value is
compared against each individual \verb`strlst` item for that row.
Parentheses are not needed in this case:
\begin{verbatim}
     SELECT UserName
     FROM   Users
     WHERE  'Administrator' IN GroupMembership;
\end{verbatim}
In the above example, the {\tt GroupMembership} column is of type
\verb`strlst`, and contains the list of groups that each user (row) is
a member of.  The query will thus return all {\tt UserName}s that are
members of the ``\verb`Administrator`'' group.

The left-side of an {\tt IN} operator may also be multi-value (e.g. a
\verb`strlst` parameter), in which case {\em all} the left-side values
must be present on the right-side (if \verb`inmode` is
``\verb`subset`'').  The behavior of multi-value types other than
\verb`strlst` (on either side of {\tt IN}) is currently undefined and
thus such types should not be used.

The {\tt IN} operator can be modified with the logical operator {\tt
NOT} (note however that an index cannot be used to optimize such a
query).

{\bf Example:}
List all departments which are not in either the Corporate or the
Information divisions.

Enter the statement:
\begin{verbatim}
     SELECT  DNAME, DIV
     FROM    DEPARTMENT
     WHERE   DIV NOT IN ('CORP','INFO') ;
\end{verbatim}
The result displayed will be:
\begin{screen}
\begin{verbatim}
  DNAME                                DIV
  Research and Development             PROD
  Manufacturing                        PROD
  Customer Support and Service         PROD
  Product Marketing and Sales          PROD
\end{verbatim}
\end{screen}
%\chgbarend

Note that {\tt IN} differs from {\tt SUBSET} and {\tt INTERSECT} in
the interpretation of empty {\tt varchar} values: for {\tt IN} they
are single-item empty-string sets.  See
p.~\pageref{InSubsetIntersectCommonality} for details, as well as for
other behaviors that {\tt IN}, {\tt SUBSET} and {\tt INTERSECT} share
in common.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{{\tt IN} with Version 6 Or Earlier}
\label{InWithVersion6}

In Texis version 6 (or \verb`compatibilityversion` 6) and earlier,
\verb`IN` behaved much like the \verb`INTERSECT` operator
(p.~\pageref{IntersectOperator}) instead of \verb`SUBSET`, i.e. it was
true if {\em any} left-side value was present on the right-side.  This
behavior can be restored with the \verb`inmode` SQL property,
p.~\pageref{InmodeProperty} (or the \verb`compatibilityversion`
property, p.~\pageref{SqlPropertyCompatibilityVersion}).  Note however
that with a single non-empty left-side value, there is no difference,
as intersection and subset then behave the same.

Additionally, \verb`IN` with version 6 and earlier did not always
utilize indexes (e.g. if the table column was on the right-side), and
had other quirks.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Searches Using {\tt SUBSET}}
\label{SubsetOperator}

  The {\tt SUBSET} operator allows subset queries, and is typically
used with multi-value (i.e. \verb`strlst`) fields that are treated as
sets.  It is true if the left-side is a subset of the right-side,
i.e. if there are no values on the left-side that are missing from the
right-side.  Duplicates count, i.e. they must match one-to-one from
left side to right.

  For example, suppose the table \verb`Users` contains one row per
user (\verb`UserName`), and has a \verb`strlst` column
\verb`GroupMembership` that lists all the groups that row's user is a
member of.  To find all users that are members of groups
``\verb`Management`'', ``\verb`Sales`'' {\em and}
``\verb`Marketing`'', a {\tt SUBSET} query can be used:

\begin{verbatim}
     SELECT UserName
     FROM   Users
     WHERE  ('Management', 'Sales', 'Marketing')
          IS SUBSET OF GroupMembership;
\end{verbatim}

(Syntactically, {\tt SUBSET} is always used as part of the phrase {\tt
IS SUBSET OF}, as it is only valid in {\tt WHERE} clauses.)  The above
query will return the users that are members of all three groups --
including any users that may also be members of additional groups.

Note that {\tt SUBSET} is not commutative, i.e. if the left- and
right-sides are reversed, the meaning is changed (unlike e.g. {\tt
INTERSECT}).  If \verb`A` is a subset of \verb`B`, then \verb`B` is
{\em not} necessarily a subset of \verb`A`; \verb`B` is a subset of
\verb`A` if and only if both sets contain the same values.  E.g. this
query:

\begin{verbatim}
     SELECT UserName
     FROM   Users
     WHERE  GroupMembership
          IS SUBSET OF ('Management', 'Sales', 'Marketing');
\end{verbatim}

while merely the reversed version of the earlier query, behaves
differently: it would list the users whose are in zero or more of the
Management, Sales or Marketing groups -- {\em and} are not in any
other groups.

In set logic the empty set is a subset of any set; thus if there are
{\em no} values on the left-side, {\tt SUBSET} is true no matter what
the right-side value(s) are.  Note that {\tt SUBSET} interprets an
empty {\tt varchar} value as empty-set, not single-item empty-string
set set (as {\tt IN} does).  See
p.~\pageref{InSubsetIntersectCommonality} for details, as well as
additional behaviors that {\tt IN}, {\tt SUBSET} and {\tt INTERSECT}
share in common.  {\tt SUBSET} was added in Texis version 7.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Index Usage by {\tt SUBSET}}
\label{SubsetIndexUsage}

  A {\tt SUBSET} query can often utilize a regular (B-tree) index to
increase performance.  Generally the index should be created with
\verb`indexvalues` set to \verb`splitstrlst` (the default), as this
enables individual values of \verb`strlst`s to be accessed as needed.
There are some limitations and caveats for {\tt SUBSET} and indexes
however:

\begin{itemize}
  \item {\bf Empty parameter, \verb`strlst` column (either side):} \\
    Queries with empty-set parameters (i.e. zero-item \verb`strlst`,
    or empty \verb`varchar`) and a \verb`strlst` column cannot use an
    \verb`indexvalues=splitstrlst` index, regardless of which side of
    {\tt SUBSET} the parameter and column are on.  An index with
    \verb`indexvalues=all` can be used however.  It may be created in
    addition to the normal \verb`indexvalues=splitstrlst` index, and
    the Texis optimizer will choose the appropriate one at search
    time.

  \item {\bf Empty \verb`strlst` column left-side, non-empty parameter
    right-side:} \\
    With a \verb`strlst` column on the left-side, and a non-empty
    parameter on the right, empty rows will not be returned if an
    index is used -- even though they properly match (as empty set is
    a subset of any set).
\end{itemize}

These caveats are due to limitations in \verb`indexvalues=strlst`
indexes; see p.~\pageref{indexvalues} for more information.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Searches Using {\tt INTERSECT}}
\label{IntersectOperator}

  The {\tt INTERSECT} operator allows set-intersection queries,
typically on multi-value (i.e. \verb`strlst`) values.  It returns the
intersection of the left and right sides, i.e. the ``set''
(\verb`strlst`) of all values that are present on both sides.
Duplicates are significant, i.e. they must match one-to-one to be
included in the intersection.

  For example, suppose the table \verb`Users` contains one row per
user (\verb`UserName`), and has a \verb`strlst` column
\verb`GroupMembership` that lists all the groups that row's user is a
member of.  To find all users that are members of groups
``\verb`Management`'', ``\verb`Sales`'' {\em or} ``\verb`Marketing`'',
an {\tt INTERSECT} query can be used:

\begin{verbatim}
     SELECT UserName
     FROM   Users
     WHERE  GroupMembership INTERSECT
          ('Management', 'Sales', 'Marketing') IS NOT EMPTY;
\end{verbatim}

This will return users where the intersection of a user's {\tt
GroupMembership} with the three named groups is not empty
(i.e. contains at least one value).  Thus, users that are members of
any of the three named groups are returned.  The phrase {\tt IS NOT
EMPTY} must be added immediately after, both to turn the expression
into a true/false condition suitable for a {\tt WHERE} clause, and to
allow an index to be used to resolve the query.  (The phrase {\tt IS
EMPTY} is also permitted, for negation.  However indexes cannot be
used to resolve such queries.)

{\tt INTERSECT} may also be used in a {\tt SELECT} clause, to return
the actual intersection set itself, rather than be used as a
true/false condition.  For example, given the same {\tt Users} table
above, to find each user's membership amongst just the three named
groups, this query may be used:

\begin{verbatim}
     SELECT UserName, GroupMembership INTERSECT
          ('Management', 'Sales', 'Marketing') AS SubMembership
     FROM   Users;
\end{verbatim}

This will return the membership of each user ({\tt SubMembership}) in
just the three named groups, as a \verb`strlst`.  If a user is not a
member of any of the three groups, {\tt SubMembership} will be empty.
If a user is a member of some other group(s), they will not be named
in {\tt SubMembership}.

Note that unlike {\tt SUBSET}, {\tt INTERSECT} is commutative,
i.e. reversing the left- and right-sides does not change its meaning.
(The ``\verb`=`'' equals operator is also commutative, for example:
{\tt x = y} has the same meaning as {\tt y = x}.)  Also note that {\tt
INTERSECT} interprets an empty {\tt varchar} value as empty-set, not
single-item empty-string set (as {\tt IN} does).  See
p.~\pageref{InSubsetIntersectCommonality} for details, as well as
additional behaviors that {\tt IN}, {\tt SUBSET} and {\tt INTERSECT}
share in common.  {\tt INTERSECT} was added in Texis version 7.

% . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Index Usage by {\tt INTERSECT}}

  An {\tt INTERSECT} query can utilize a regular (B-tree) index to
increase performance.  The index should be created with
\verb`indexvalues` set to \verb`splitstrlst` (the default), as this
enables individual values of \verb`strlst`s to be accessed as needed.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{{\tt IN}, {\tt SUBSET}, {\tt INTERSECT} Commonality}
\label{InSubsetIntersectCommonality}

The {\tt IN}, {\tt SUBSET} and {\tt INTERSECT} operators, being
set-like, share certain behaviors in common in Texis version 7 (or
\verb`compatibilityversion` 7) and later:

  A \verb`varchar` value on either side of these operators is treated
as a single-item \verb`strlst` set -- regardless of the current
\verb`varchartostrlstsep` setting.  This aids usage of {\tt IN}/{\tt
SUBSET}/{\tt INTERSECT} in Vortex when \verb`arrayconvert` is active
for parameters: it provides consistent results whether the Vortex
variable is single- or multi-value.  A single \verb`varchar` value
will not be unexpectedly (and incorrectly) split into multiple values
using its last character as a separator.

  However, the operators differ on interpretation of {\em empty} {\tt
varchar} values.  With {\tt IN}, an empty {\tt varchar} value is
considered a single-item empty-string set, because {\tt IN} is most
often used with single-value (i.e. non-set-like) parameters.  This
makes the clause ``{\tt WHERE varcharColumn IN ('red', 'green',
'blue')}'' only return ``\verb`red`'', ``\verb`green`'' or
``\verb`blue`'' {\tt varcharColumn} values -- not empty-string values
too, as {\tt SUBSET} would.  This empty-string interpretation
difference is the one way in which {\tt IN} differs from {\tt SUBSET}
(and {\tt INTERSECT}, if \verb`inmode` is \verb`intersect`).

  With {\tt SUBSET}/{\tt INTERSECT} however, an empty {\tt varchar}
value is considered an empty set, because {\tt SUBSET}/{\tt INTERSECT}
are more clearly set-like operators where both operands are sets, and
an empty string is more likely to be intended to mean ``empty set''.
This is also more consistent with {\tt convert()} and {\tt INSERT}
behavior: an empty string converted or inserted into a {\tt strlst}
value becomes an empty {\tt strlst}, not a one-item (empty-string)
{\tt strlst}.

  The current (or indexed) \verb`stringcomparemode` setting value is
used during {\tt IN}/{\tt SUBSET}/{\tt INTERSECT} operations; thus
case-insensitive comparisions can be accomplished by modifying the
setting.  At search time, the Texis optimizer will choose the index
whose \verb`stringcomparemode` setting is closest to the current value.

  {\bf Caveat:} {\tt IN}/{\tt SUBSET}/{\tt INTERSECT} behavior with
multi-value types other than \verb`strlst` is currently undefined and
should be avoided.  Single-value types other than \verb`varchar` have
limited support currently; it is recommended that only \verb`varchar`
(and \verb`strlst`) types be used.

  See also p.~\pageref{InWithVersion6} for version 6 and earlier
{\tt IN} issues.

% ----------------------------------------------------------------------------
\subsection{Search Condition Using {\tt LIKE}}

In most SQL applications, a column value that contains character
values can be matched to a pattern of characters for the purpose of
retrieving one or more rows from a table.  This is often referred to
as {\em pattern matching}.  Pattern matching is useful when a user
cannot be specific about the data to be retrieved.  For instance:

\begin{itemize}
\item You're not sure if someone's last name is Robinson, Robertson,
or Robbins.  You search using the pattern ``Rob''.

\item You want a list of all employees who live on Newman Avenue, Road
or Street.  You search using the pattern ``Newman''.

\item You want a list of all employees whose name ends in ``man'',
such as Waterman, Spellman, or Herman.  You search using the pattern
``man''.
\end{itemize}

The \verb`LIKE` operator is used in the \verb`WHERE` clause to enable you to
retrieve records that have a partial match with a column value.  The
\verb`LIKE` operator has the following format:
\begin{verbatim}
     WHERE  column-name  LIKE  'pattern'
\end{verbatim}

In Texis the capabilities of the \verb`LIKE` clause have been exponentially
increased through implementation of all features of the Metamorph
search engine.  Rather than the limited single item string search
allowed in traditional SQL applications, Texis allows any valid
Metamorph query to be substituted for the \verb`'pattern'` following
\verb`LIKE`.

Therefore, in addition to traditional string searches, text fields can
be searched with all of Metamorph's pattern matchers to find concepts,
phrases, variable expressions, approximations, and numeric quantities
expressed as text.  These queries can contain multiple search items
combining calls to different Metamorph pattern matchers.
Intersections of such items can be located in proximity to one another
within defined text units such as sentences, paragraphs, or the whole
record.

It is this integration of Metamorph through the \verb`LIKE` clause which
brings together intelligent full text searching with relational
database technology.  For instance, within the confines of the Texis
relational database, you can also issue queries to find the following:

\begin{itemize}
\item All Research and Development reports covering conceptually
similar research done on a field of interest.  For example, a request
for all research done concerning ``red lenses'' could discover a
report about ``rose colored glasses''.

\item All strategic information reports concerning marketing campaigns
over a certain dollar amount.  For example, such a request for
marketing information about wheels could reveal a ``sales'' campaign
where ``twenty-five thousand dollars'' was allocated to promote
``tires''.

\item An employee whose name sounds like Shuler who helps fix computer
problems.  For example, a query for approximately Shuler and computers
could find Elaine ``Schuller'' who works in ``data processing''. And
since you are querying a relational database, you could also pull up
her phone extension and call for help.
\end{itemize}

Full use of the Metamorph query language is discussed in depth in
Chapter~\ref{Chp:MMLike}.  In this section we will concentrate on
simple examples to illustrate how the \verb`LIKE` clause can be used to
further qualify \verb`WHERE`.

\subsubsection{Command Discussion}

\begin{itemize}
\item The column name following the \verb`WHERE` clause must contain
character values; otherwise, the \verb`LIKE` operator cannot be used.

\item The \verb`LIKE` operator compares the value in the specified column
with the pattern, as inserted in single quotes following \verb`LIKE`.  A row
is retrieved if a match occurs.

\item You can put any Metamorph query in quotes (\verb`'query'`) in
place of a fixed length string, although you would need to escape a
literal \verb`'` with another \verb`'` by typing \verb`''`, if you
want the character \verb`'` to be part of the query.

\item The ``pattern'' inside single quotes following \verb`LIKE` will be
interpreted exactly as Metamorph would interpret such a query on its
query line, in any Metamorph application (with the only exception
being that a single quote or apostrophe must be escaped with
another \verb`'` to be interpreted literally).

\item Concept searching is off by default for Metamorph queries
following \verb`LIKE`, but can be selectively invoked on a word using the
tilde `\verb`~`'.

\item Syntax for complete use of Metamorph query language is covered
in Chapter~\ref{Chp:MMLike}.

\item Queries using \verb`LIKE` can make use of any indexing which has been
done.  An alternate form of \verb`LIKE` may also be used called \verb`LIKE3`, which
uses indexing exclusively with no post search.  See
Chapter~\ref{Chp:MMLike} for a thorough explanation of all types of
text searches possible with \verb`LIKE` and \verb`LIKE3`, and their relation to
indexed information.
\end{itemize}

{\bf Example:}
Let's start with a simple example.  You wish to retrieve all reports
where ``ink'' is part of the title, without knowing the full title.

If you enter the statement:
\begin{verbatim}
     SELECT  TITLE
     FROM    REPORT
     WHERE   TITLE  LIKE  'ink' ;
\end{verbatim}
the result displayed will be:

\begin{screen}
\begin{verbatim}
  TITLE
  Innovations in Disappearing Ink
  Disappearing Ink Promotional Campaign
  Ink Color Panorama
\end{verbatim}
\end{screen}

In this query, you are retrieving the titles of all reports whose
title is ``like'' the pattern ``ink''.

In other cases you may not know the exact words you are looking for.
A simple example where a wildcard '\verb`*`' is used follows.

\begin{verbatim}
     SELECT  AUTHOR, DEPT
     FROM    REPORT
     WHERE   AUTHOR  LIKE  'san*' ;
\end{verbatim}
The result will be:
\begin{screen}
\begin{verbatim}
  AUTHOR                 DEPT
  Sanchez, Carla         MKT
  Sanders, George G.     FIN
  Claus, Santa           MKT
\end{verbatim}
\end{screen}

% ----------------------------------------------------------------------------
\subsection{Relevance Ranking Using {\tt LIKER} and {\tt LIKEP}}

In addition to the Metamorph searches listed above there is another
 type of search based on Metamorph.  This will return rows in order of
 relevance, with the most relevant record first (unless other clauses
 alter this order, e.g. an \verb`ORDER BY`).  \verb`LIKER` calculates
 a relevance based solely on the presence or absence of the terms in
 the document.  \verb`LIKEP` uses this same information, but also uses
 the proximity of the terms to calculate relevance.

There are several restrictions and points to note about \verb`LIKER`
 and \verb`LIKEP`.  The conditions that must be met to obtain a
 relevancy search are that a Metamorph index exists on the field in
 question.  \verb`LIKER` can only work with an index; while
 \verb`LIKEP` can work without such an index, it performs best with
 one.  The other condition is that the query should consist of word
 terms only.  None of the other pattern matchers are available with
 \verb`LIKER`; they are available with \verb`LIKEP`, but at a cost
 in performance (post-processing is required).

The query is a list of terms to be searched for.  The words are weighted
by their uniqueness in the document set being searched.  This means that
infrequent words are weighted more than common words.

The weight that was calculated for the record is available by
 selecting the generated field \verb`$rank`, which will contain the rank
 value.  The rank value for \verb`LIKER` is unscaled.  With
 \verb`LIKEP` the number will range between 0 and 1000, where greater
 values indicate greater computed relevance to the query.

The default ordering of \verb`LIKER` and \verb`LIKEP`
 (rank-descending) may be changed by an \verb`ORDER BY` clause.
  Historically (prior to Texis version 8), an \verb`ORDER BY`
 containing \verb`$rank` (or potentially any expression containing
 \verb`$rank`) would usually order descending as well -- despite the
 typical default \verb`ORDER BY` order being {\em ascending} --
 because rank-descending is considered more useful (and often low-rank
 results are eliminated prior to ordering anyway).  However, this
 caused confusion when giving the \verb`DESC` flag, as then {\tt ORDER
 BY \$rank DESC} would return {\em ascending} results.

Thus, in Texis version 8 and later, \verb`ORDER BY` clauses containing
 \verb`$rank` will order consistently with other \verb`ORDER BY`
 clauses -- i.e. numerically ascending unless the \verb`DESC` flag is
 given.  This means that in version 8 and later, most {\tt ORDER BY
 \$rank} clauses should probably be {\tt ORDER BY \$rank DESC}, to get
 rank-descending behavior.  This behavior may be altered by the
 \verb`legacyversion7orderbyrank` SQL setting
 (p.~\pageref{SqlPropertyLegacyVersion7OrderByRank}).

For fuller details on using the logic operators in \verb`LIKE` see
Chapter~\ref{Chp:MMLike}
\subsubsection{Command Discussion}

Result ranking is a useful feature, although due to the variety of cases
where you might want to use ranking, there are a number of variables that
control the ranking algorithm.

The first major choice will be whether proximity is important.  This
will indicate if you want to use \verb`LIKER` or \verb`LIKEP`.  \verb`LIKER` uses the index
to determine the frequencies of the terms, and the presence of absence
of the terms in each document to determine the rank for each document.
Each term is assigned a weight between 0 and 1000, and the rank value
for the document is the sum of the weights for all the terms that
occur.

\verb`LIKER` has a threshold value, such that documents with a lower
rank value than the threshold value will not be returned.  This prevents
a large number of irrelevant documents from being returned.  Initially
the threshold is set to the weight of the term with the highest weight.
If there are more than five terms then the threshold is doubled, and if
there are more than 10 terms the threshold is doubled again.  This keeps
queries containing a lot of terms from returning irrelevant hits.  It
is possible to force the threshold lower if desired to return more records.
This can be performed either by specifying the maximum number of records
a term should occur in, and still be returned by \verb`LIKER`.  This is the
\verb|likerrows| variable.  For example, in a three term query, where
the terms occur in 400, 900 and 1400 records respectively, setting
\verb|likerrows| to 1000 would allow records containing only the second
search term to be returned.

In general \verb`LIKEP` will perform the same initial step as \verb`LIKER` to
determine which documents to rank.  \verb`LIKEP` then looks at the
\verb|likeprows| highest ranked documents from \verb`LIKER`, and recalculates
the rank by actually looking inside the document to see where the
matching terms occur.  Because of this it will be slower than \verb`LIKER`,
although if you are using a Metamorph inverted index the ranks may
still be determinable from the index alone, saving actual table
accesses.

There are a number of variables that can be set with \verb`LIKEP`, which
affect both how documents are ranked, as well as how many documents
are returned.  See the ``Rank knobs'' (p.~\pageref{rankknobs}) and
``Other ranking properties'' (p.~\pageref{otherrank}) discussions
in the Server Properties section of the manual.

% ----------------------------------------------------------------------------
\subsection{Query searching using {\tt LIKEIN}}

\verb`LIKEIN` is used for doing profiling, where you have a lot of queries
and you want to find which queries match the given text.  This is typically
used when the number of queries is large and relatively constant, and there
is a stream of new texts to match.  \verb`LIKEIN` will find the queries
that would match the text.  To work efficiently you should have a
\verb`METAMORPH COUNTER` index created on the field containing the queries.

% ----------------------------------------------------------------------------
\subsection{Search Condition Using {\tt MATCHES}}

The {\tt MATCHES} keyword allows you to match fields against expressions.  This
is most useful when you have fields with a small amount of text and do not
need the full power of Metamorph.  Typical uses would be names, part numbers
or addresses.

In the query an underscore will match any single character, and a percent
sign will match any number of characters.  For example

\begin{verbatim}
     SELECT  AUTHOR, DEPT
     FROM    REPORT
     WHERE   AUTHOR  MATCHES  'San%' ;
\end{verbatim}
The result will be:
\begin{screen}
\begin{verbatim}
  AUTHOR                 DEPT
  Sanchez, Carla         MKT
  Sanders, George G.     FIN
\end{verbatim}
\end{screen}

The special characters used with {\tt MATCHES} can be changed using the
{\tt set matchmode} SQL statement.  The default value of 0 produces
the behavior documented above which is standard in SQL.  Setting
\verb|MATCHMODE| to 1 will change the special characters such that
asterix will match any number of characters, and a question mark will
match any single character, which is more familiar to many people.

Comparing the results to the earlier example using \verb`LIKE` you will see that
Claus, Santa does not match, as the match has to occur at the beginning of
the field.

{\tt MATCHES} can make use of a regular index on the field.  It will not use
a Metamorph index.

% ----------------------------------------------------------------------------
%\subsection{Search Condition Using NULL}
%
%\chgbarbegin Occasionally, when data is entered into a row, the value for one or
%more columns is unknown.  For example, a new employee who doesn't have
%a phone extension assigned at the time the record is added to the
%EMPLOYEE table has a null value stored in the phone extension column.
%Likewise a report entered into the REPORT table where the title is
%known but the author is not can be entered with a null value stored in
%the author column.
%
%There are times when you wish to test for the presence or absence of
%null values in a specific column.  The keywords IS NULL are used to
%find rows that contain null values in a specific column.  The general
%form of this search condition is as follows:
%
%\begin{verbatim}
%     column-name IS [NOT] NULL
%\end{verbatim}
%
%NULL is used with the word IS instead of with the comparison operators
%equal `\verb`=`' or not equal `\verb`!=`'.  If a query to find null
%values is written in the following form:
%\begin{verbatim}
%     WHERE column-name = NULL                 (Incorrect)
%\end{verbatim}
%no rows containing null values will be retrieved.
%
%{\bf Example:}
%List the title of any report whose author is unknown (null).
%
%If you enter the statement:
%\begin{verbatim}
%     SELECT  TITLE
%     FROM    REPORT
%     WHERE   AUTHOR IS NULL ;
%\end{verbatim}
% MAW 09-16-94 - comment following
%the message displayed will be:
%\begin{verbatim}
%     No Records Selected
%\end{verbatim}
%In this example the search retrieved no records; as all the reports
%currently entered have the author column filled in. \chgbarend
%
\section{Sorting Your Results}

The output from the above queries may not be in the desired order.
For example, you may want the list of departments arranged
alphabetically.  Sorting is the process of rearranging data into some
specific order.  To sort the output into a desired sequence, a field
or fields are specified that determine the order in which the results
are arranged.  These fields are called {\em sort keys}.

For example, if the department data is sorted into alphabetical order
by department, the department name is the sort key.  The budget field
is the sort key if the department table is sorted by amount of budget.
Note that the sort key can be numeric (budget) or character
(department name).

Results can be sorted into ascending or descending sequence by sort
key.  Ascending means increasing order, and descending means
decreasing order.  For example, sorting the department table in
ascending order by budget means the department data will be arranged
so that the department with the lowest budget is first and the
department with the highest budget is last.  If we instead sorted in
descending order, the department with the highest budget would appear
first, the department with the lowest budget would appear last.

Sorting character data in ascending or descending order is based on a
coding, or collating, sequence assigned to numbers and letters by the
computer.  For example, when department name is the sort key and you
want the data arranged alphabetically, that indicates ascending order.
If you want the data arranged in reverse alphabetical order, then
specify descending order.

To sort your results using Texis, add the {\tt ORDER BY} clause to the
\verb`SELECT` statement.  The form of this clause is:
\begin{verbatim}
     ORDER BY  column-name  [DESC]
\end{verbatim}
where DESC indicates the rows are to be arranged in descending order.
If DESC is omitted, your output is sorted in ascending order.

This clause fits into the \verb`SELECT` expression following the \verb`WHERE`
clause, as shown below:
\begin{verbatim}
     SELECT      column-name1 [,column-name2] ...
     FROM        table-name
     [WHERE      search-condition]
     [ORDER BY   column-name [DESC] ] ;
\end{verbatim}

{\bf Example:}
Retrieve a list of departments arranged by division, and within that
division, arranged by highest budget first.

If you enter the statement:
\begin{verbatim}
     SELECT      DNAME, DIV, BUDGET
     FROM        DEPARTMENT
     ORDER BY    DIV, BUDGET DESC ;
\end{verbatim}
Output will appear in ascending order automatically if DESC is
omitted.

The result displayed will be:

\begin{screen}
\begin{verbatim}
  DNAME                                  DIV     BUDGET
  Corporate Legal Support                CORP    28000
  Finance and Accounting                 CORP    26000
  Management and Administration          CORP    22000
  Recruitment and Personnel              CORP    15000
  Supplies and Procurement               CORP    10500
  Strategic Planning and Intelligence    INFO    28500
  Information Systems Management         INFO    22500
  Corporate Library                      INFO    18500
  Manufacturing                          PROD    32000
  Research and Development               PROD    27500
  Product Marketing and Sales            PROD    25000
  Customer Support and Service           PROD    11000
\end{verbatim}
\end{screen}

Notice that all departments in the same division are listed together,
with the divisions listed in ascending order, as the default ordering
for DIV.  Within each division, the department with the highest budget
is listed first, since descending order was specified for BUDGET.

% JMT 09-16-94 - 50 fields
It is possible to have as many as 50 sort
keys.  The order in which the sort keys are listed is the order in
which the data will be arranged.
%
%Sort keys can also be specified by using relative position numbers
%instead of column names.  In this case, a number following the
%keywords {\tt ORDER BY} indicates the item or items on which to sort.  The
%relative position number refers to the position of an item in the
%\verb`SELECT` clause.  The first item is assigned position number 1, the
%second item is assigned position number 2, and so on. The ability to
%use numbers as sort keys is most helpful when you sort on a calculated
%field.  (This will be covered in Chapter~\ref{chp:CalcQuer}).
%
%{\bf Example:}
%List the department names, budgets, and divisions of all departments
%with a budget of \$25,000 or greater.  Arrange the output so that the
%department with the highest budget appears first.
%
%If you enter the statement:
%\begin{verbatim}
%     SELECT      DNAME, BUDGET, DIV
%     FROM        DEPARTMENT
%     WHERE       BUDGET >= 25000
%     ORDER BY    2 DESC ;
%\end{verbatim}
%The result displayed will be:
%
%\begin{screen}
%\begin{verbatim}
%  DNAME                                  BUDGET     DIV
%  Manufacturing                          32000      PROD
%  Strategic Planning and Intelligence    28500      INFO
%  Corporate Legal Support                28000      CORP
%  Research and Development               27500      PROD
%  Finance and Accounting                 26000      CORP
%  Product Marketing and Sales            25000      PROD
%\end{verbatim}
%\end{screen}
%
%Note that the {\tt ORDER BY} clause contains a number instead of a column
%name.  The number refers to the second position in the \verb`SELECT` clause.

This chapter has introduced several ways to retrieve rows and columns
from a table.  In the next chapter, you will learn how to perform
calculations on data stored in a table.
