% -*- mode: LaTeX -*-
% $Id$

\chapter{Indexing for Increased Performance}

\section{When and How to Index}

There are two basic mechanisms for accessing Texis tables:  a table
space scan which is sequential, and an index based scan which is
direct.  Index based retrieval is usually more efficient than table
space scan with some exceptions.

The use of indexes is one of the major ways in which the performance
of queries (i.e. the speed with which results are retrieved) can be
improved in relational databases.  Indexes allow the DBMS to retrieve
rows from a table without scanning the entire table, much as a library
user can use a card catalog to find books without scanning the entire
library.

The creation of indexes improves the performance associated with
processing large tables.  However, an excessive number of indexes can
result in an increase in processing time during update operations
because of the additional effort needed to maintain the indexes.
Thus, for tables undergoing frequent change, there could be a ``cost''
associated with an excessive number of indexes.

In addition, as the number of indexes increases, the storage
requirements needed to hold the indexes becomes significant.  Other
cautions include not indexing small amounts of data as doing so may
slow down searches due to the overhead of looking in an index.  The
point at which it makes sense to use an index will depend upon the
system in use.  And it would be important to use the correct kind of
index for the job.

Since there are so many factors involved in the decision as to whether
and what kind of index will most optimize the search, Texis largely
takes over the management of these decisions.  The user can suggest
those tables on which an index ought to be created.  Beyond this, the
user would not know the status of the index, which is always in flux,
nor whether it has been updated at the time of the search.

Unlike other systems, Texis ensures that all information which has
been added to any table can be searched immediately, regardless of
whether it has been indexed, and regardless of whether it has been
suggested that an index be maintained on that table or not.
Sequential table space scans and index based scans are efficiently
managed by Texis so that the database can always be searched in the
most optimized manner, with the most current information available to
the user.

To this end, there are two types of indexes supported by Texis:

\begin{enumerate}
\item The canonical sorted order alphabetical index found in
traditional SQL systems, and

\item The Metamorph index, optimized for systems containing a large
number of rows, or a lot of text, or both.  The Metamorph index is
used when it is expected that \verb`LIKE` or its variants will be
common on the field being indexed.
\end{enumerate}

When an index is created, neither an end user nor an application
programmer need (nor can) reference the index in a query.  Indexes are
used automatically by Texis when needed to choose the best path to the
data.

% ============================================================================
\section{Creating An Index}

The {\tt CREATE INDEX} command is used to establish an index.  The form of
this command is:

\begin{verbatim}
     CREATE INDEX index-name
     ON table-name (column-name [DESC] [, column-name [DESC]] ...)
     [WITH option-name [value] [option-name [value] ...]] ;
\end{verbatim}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Command Discussion}

\begin{itemize}
\item Each index is assigned a name and is related to a particular
table based on the {\tt ON table-name} clause.

\item The entries in an index are ordered on a specified column within
the specified table, and arranged in either ascending or descending order.

\item The term {\em index key} refers to the column (or set of
columns) in a table that is used to determine the order of entries in
an index.  Where an index does consist of multiple columns, the most
important column is placed first.

\item Further options controlling how and what type of index is created
      may be set in the {\tt WITH} clause; see p.~\pageref{IndexOptions}.

\item A table can have many different indexes associated with its
columns.  Each index is created by issuing a separate {\tt CREATE INDEX}
command.
\end{itemize}

{\bf Example}:
Many queries to the \verb`EMPLOYEE` table reference the employee's
department; therefore, the database designer decides to create an
index using the \verb`DEPT` column to improve performance related to these
queries.

This command:
\begin{verbatim}
     CREATE INDEX DEPTINDEX
     ON EMPLOYEE (DEPT) ;
\end{verbatim}

would direct the creation of an index called \verb`DEPTINDEX` (the
Index name) on the table \verb`EMPLOYEE`, using the
\verb`DEPT` column as indicated in parentheses as the Index key.

The index can be used by the system to provide quick access to
employee data that are subject to conditions related to the employee's
department.

% ============================================================================
\section{Creating a Unique Index}

The {\em primary key} is an important concept in data processing.  The
primary key is a field or combination of fields in a record that
allows you to uniquely identify a record from all the other records in
a table.  For example, companies assign IDs to employees as unique
identifiers.  Thus, an employee ID can serve as a primary key for
personnel records.

When a table is created in Texis, duplicate records can be stored in
the table.  The uniqueness characteristic is not enforced
automatically.  To prevent duplicate records from being stored in a
table, some steps must be taken.

First, a separate file called an ``index'' must be created.  In this
case the index is created so that the DBMS can ensure that all values
in a special column or columns of a table are unique.  For example,
the \verb`EMPLOYEE` table can be indexed on \verb`EID` (employee ID)
so that each row of the \verb`EMPLOYEE` table contains a different
employee ID value (i.e., no duplicate \verb`EID`s can be entered.)

%\if \HaveNull
%Next, in addition to defining an index, the column or columns that
%represent the primary key should be designated as {\tt NOT NULL} during the
%{\tt CREATE TABLE} definition.  The {\tt NOT NULL} keyword prevents unknown values
%from being stored in the column that you want as the primary key.  The
%combination of a unique index and the {\tt NOT NULL} specification is
%necessary to define a primary key in Texis.
%\fi % HaveNull

A variation of the {\tt CREATE INDEX} command, {\tt CREATE UNIQUE INDEX}, is used
to establish an index that assures no duplicate primary key values are
stored in a table.  The form of this command is:

\begin{verbatim}
     CREATE [UNIQUE] INDEX index-name
     ON table-name (column-name [DESC] [,column-name [DESC]] ...) ;
\end{verbatim}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Command Discussion}

\begin{itemize}

\item The keyword \verb`UNIQUE` in the clause {\tt CREATE UNIQUE INDEX}
specifies that in the creation and maintenance of the index no two
records in the index table can have the same value for the index
column (or column combination).  Thus, any \verb`INSERT` or
\verb`UPDATE` command that attempts to add a duplicate row in the
index would be rejected.

\item Each index is assigned a name and is related to a particular
table based on the {\tt ON table-name} clause.

\item An index is based on the specified column within the specified
table, and will be arranged in ascending order.
\end{itemize}

{\bf Example:}
Create an index for the \verb`EMPLOYEE` table that prevents records with the
same employee ID from being stored in the table with this command:
\begin{verbatim}
     CREATE UNIQUE INDEX EMPINDEX
     ON EMPLOYEE (EID) ;
\end{verbatim}

This command directs the creation of a unique index on the
\verb`EMPLOYEE` table, where the index name is
\verb`EMPINDEX`.  The \verb`EID` column as indicated in
parentheses is the Index key.

In other words, an index called \verb`EMPINDEX` has been created on the
\verb`EMPLOYEE` table for the employee ID number.

The index is stored separately from the \verb`EMPLOYEE` table.  The
example below shows the relationship between \verb`EMPLOYEE` and
\verb`EMPINDEX` after ten employees have been added to the \verb`EMPLOYEE`
table.  Each row of the index, \verb`EMPINDEX`, consists of a column value
for the index column and a pointer, or physical address, to the
location of a row in the \verb`EMPLOYEE` table.  As employees are added or
deleted from the \verb`EMPLOYEE` table, Texis automatically updates the index
in the most efficient and timely manner.

To conceptualize how the index works, assume you didn't realize
Chapman's record was already stored in the \verb`EMPLOYEE` table and you
attempt to add her record again.  You enter the command:

\begin{verbatim}
     INSERT INTO EMPLOYEE
     VALUES ('103','Chapman, Margaret','LIB','STAFF','PART',22000) ;
\end{verbatim}

and Texis responds with an error message, such as:

\begin{verbatim}
     ERROR: Duplicate Value in Index
\end{verbatim}

This message occurs because the value 103, the employee ID (\verb`EID`), is
already stored in \verb`EMPINDEX` and attempting to add another 103 value
results in a duplicate value, which is not permitted in a unique
index.

When we add a new employee named Krinski with an \verb`EID` equal to 110 by
entering this command:

\begin{verbatim}
     INSERT INTO EMPLOYEE
     VALUES ('110','Krinski','LIB','DHEAD','FULL',32500) ;
\end{verbatim}

the record is successfully created.  The value 110 did not previously
exist in the unique index \verb`EMPINDEX`, and so it was allowed to be
entered as a new row in the \verb`EMPLOYEE` table.  As the
\verb`EMPINDEX` is in sorted order, it is much faster to ascertain
that information than it would be by searching the entire
\verb`EMPLOYEE` table.

The relationship between \verb`EMPINDEX` the index, and
\verb`EMPLOYEE` the table, appear below as they would containing 10
employee records.  The dashed lines indicate pointers from the index
to rows in the table.  However, this is conceptual rather than actual,
and not all pointers are shown.

\begin{screen}
\begin{verbatim}
EMPINDEX      EMPLOYEE
Index         Table
              EID  ENAME               DEPT   RANK   BENEFITS   SALARY
101 --------> 101  Aster, John A.      MKT    STAFF  FULL       32000
102 --+       109  Brown, Penelope     MKT    DHEAD  FULL       37500
103   |       104  Jackson, Herbert    RND    STAFF  FULL       30000
104   |  +--> 108  Jones, David        RND    DHEAD  FULL       37500
105   +--|--> 102  Barrington, Kyle    MGT    DHEAD  FULL       45000
106      |    106  Sanchez, Carla      MKT    STAFF  FULL       35000
108 -----+    105  Price, Stella       FIN    DHEAD  FULL       42000
107           103  Chapman, Margaret   LIB    STAFF  PART       22000
109           107  Smith, Roberta      RND    STAFF  PART       25000
110 --------> 110  Krinski, Wanda      LIB    DHEAD  FULL       32500
\end{verbatim}
\end{screen}

% ============================================================================
\section{Creating a Metamorph Index}

A sorted order index is optimized for columns containing values of
limited length, which can easily be canonically managed.  In some
cases, especially when a column contains a large amount of text, there
is a need for an index which goes beyond the methods used in these
previous examples.

For example, let us take the case of the News database being archived
on a daily basis by the Strategic Planning and Intelligence
Department.  The entire body of the news article is stored in a table,
whether the data type in use is \verb`VARCHAR`, indicating a variable length
number of characters, or \verb`INDIRECT`, indicating it points elsewhere to
the actual location of the files.  While subjects, dates, and bylines
are important, the most often queried part is the body of the article,
or the text field itself.  The column we want to index is a text
column rather than something much more concise like an an employee ID
number.

To accurately find text in the files, where search items are to be
found in proximity to other search items within some defined
delimiters, all the words of all the text in question must be indexed
in an efficient manner which still allows everything relevant to be
found based on its content, even after it has been archived away.  A
Metamorph index combines indexing technology with a linear free text
scan of selected portions of the database where appropriate in order
to accomplish this.  This linear scan following the index lookup is
referred to as a {\em post-search} or {\em post-processing}.

Metamorph query language as used following \verb`LIKE` and its
variants is described in detail in Chapter~\ref{Chp:MMLike}, {\em
Intelligent Text Search Queries}.  Where you anticipate such
\verb`LIKE` queries will be common on that field, it would be
appropriate to create a Metamorph index.

The form of the command is:

\begin{verbatim}
     CREATE METAMORPH [INVERTED|COUNTER] INDEX index-name
     ON table-name (column-name [, column-name...]) ;
\end{verbatim}

Syntax is the same as in the previous {\tt CREATE INDEX} examples,
except that you are specifying the type of index you want created
(i.e. a Metamorph index).

{\bf Example:}
The news database that is being accumulated from selected news
articles is getting too large to search from beginning to end for
content based searches which make heavy use of the \verb`LIKE` clause.  A
Metamorph index should be created for the Strategic Planning and
Intelligence Department to enhance their research capability.  The
column containing the text of the articles is called \verb`BODY`.

An index called \verb`BODYINDEX` will be created and maintained on the
\verb`BODY` column of the \verb`NEWS` table, which contains the full
text of all collected news articles.  Now content searches can stay
fast as well as accurate, regardless of how large this database
becomes.

Additional columns can be specified in addition to the text field to
be indexed.  These should be fixed length fields, such as dates,
counters or numbers.  The extra data in the index can be used to
improve searches which combine a \verb`LIKE` statement with restrictions
on the other fields, or which {\tt ORDER BY} some or all of the other fields.

% ----------------------------------------------------------------------------
\subsection{Metamorph Index Types: Inverted vs. Compact vs. Counter}

  There are three types of Metamorph index: inverted, compact and
counter.  All are used to aid in resolving
\verb`LIKE`/\verb`LIKEP`/\verb`LIKE3`/\verb`LIKER`/\verb`LIKEIN`
queries, and are created with some variant of the syntax {\tt CREATE
METAMORPH INDEX}.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Inverted}

An inverted Metamorph index is the most commonly used type of
Metamorph index, and is created with {\tt CREATE METAMORPH INVERTED
  INDEX}.  In Texis version 7 (and \verb`compatibilityversion` 7) and
later, this is the default Metamorph index type created when no other
flags are given, e.g. {\tt CREATE METAMORPH INDEX}; in version 6 (or
\verb`compatibilityversion` 6), a compact index is created.  The
version 7 index option {\tt WORDPOSITIONS 'on'}
(p.~\pageref{IndexOptions}) also explicitly creates this type of
Metamorph index (same effect as the \verb`INVERTED` flag after
\verb`METAMORPH`).

  An inverted Metamorph index maintains knowledge not only of what
rows words occur in, but also what position in each row the words
occur in (the \verb`WORDPOSITIONS`).  With such an index Texis can
often avoid a post-search altogether, because the index contains all
the information needed for phrase resolution and rank computation.
This can speed up searches more than a compact Metamorph index,
especially for ranking queries using \verb`LIKEP`, or phrase searches.
Because of the greater range of queries resolvable with an inverted
Metamorph index (vs. compact), in Texis version 7 and later it is the
default Metamorph type created.  However, an inverted Metamorph index
consumes more disk space, typically 20-30\% of the text size versus
about 7\% for a compact Metamorph index.  Index updating is also
slower because of this.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Compact}

  A compact Metamorph index maintains knowledge of what rows words
occur in, but does not store word position information.  In Texis
version 7 and later, it is created by adding the index option {\tt
WORDPOSITIONS 'off'} (p.~\pageref{IndexOptions}).  In Texis version 6
and earlier, this was the default Metamorph index type, and was
created with {\tt CREATE METAMORPH INDEX} (no flags/options).

  Because of the lack of word position information, a compact
Metamorph index only consumes about 7\% of the text size in disk space
(vs. about 20-30\% for a Metamorph inverted index); this compact size
can also speed up its usage.  However, a post-process search is needed
after index usage if the query needs word-position information
(e.g. to resolve phrases, within ``\verb`w/N`'' operators,
\verb`LIKEP` ranking), which can greatly slow such queries.  Thus a
compact Metamorph index is best suited to queries that do not need
word position information, such as single non-phrased words with no
special pattern matchers, and no ranking (e.g. \verb`LIKE`).  A
\verb`LIKER` or \verb`LIKE3` search (below), which never does a
post-search, can also use a compact Metamorph index without loss of
performance.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Counter}

  A Metamorph counter index contains the same information that a
compact Metamorph index has, but also includes additional information
which improves the performance of \verb`LIKEIN` queries.  If you are
doing \verb`LIKEIN` queries then you should create this type of index,
otherwise you should use either the normal or inverted forms of the
Metamorph index.  A Metamorph counter index is created with {\tt
CREATE METAMORPH COUNTER INDEX}; in Texis version 7 and later the {\tt
COUNTS 'on'} index option (p.~\pageref{IndexOptions}) can be given
instead of the \verb`COUNTER` flag to accomplish the same action.

% ----------------------------------------------------------------------------
\subsection{Metamorph Index Capabilities and Limitations}

As with any tool the best use can be obtained by knowing the
capabilities and limitations of the tool.  The Metamorph index
allows for rapid location of records containing one or more
keywords.  The Metamorph index also takes care of some of the
set logic.

The following should be noted when generating queries.  The most
important point is the choice of keywords.  If a keyword is chosen
that occurs in many files, then the index will have to do more
work to keep track of all the files possibly containing that word.
A good general rule of thumb is ``The longer the word, the faster
the search''.

  Also, neither type of Metamorph index is useful for special
pattern matchers (REX, XPM, NPM) as these terms cannot be indexed.
If other indexable terms are present in the query, the index will
be used with them to narrow the result list, but a post-search
or possibly even a complete linear scan of the table may be needed
to resolve special pattern matchers.

% ============================================================================
\section{Using {\tt LIKE3} for Index Only Search (No Post-Search)}

In certain special cases, such as static information which does not
change at all except under very controlled circumstances easily
managed by the system administrator, there may be instances where an
index based search with no qualifying linear post-search may be done
without losing meaningful responses to entered queries.

This kind of search is completely optimized based on certain defaults
which would be known to be acceptable, including:

\begin{itemize}
\item All the search items can be keywords (i.e., no special
pattern matchers will be used).

\item All searches can be done effectively within the length of the
field (i.e., the delimiters used to define proximity of search items
is the length of the whole text field).
\end{itemize}

As more often than not maintaining all the above rules is impractical,
dispensing with the post-search would not be done very frequently.
However, in some circumstances where these rules fit, the search
requirements are narrow, and speed is of the essence, the post-search
can be eliminated for optimization purposes.

Texis will examine the query given to \verb`LIKE`, and if it can
guarantee the same results without the post-search it will not perform
the post-search, and \verb`LIKE` will then be equivalent to
\verb`LIKE3`.  With these caveats in mind, \verb`LIKE3` may be
substituted for \verb`LIKE` in any of the queries illustrated in the
previous chapters.

% ============================================================================
\section{Creating an Inverted Index}

The inverted index (not to be confused with a Metamorph inverted
index--a different type of index) is a highly specialized index, which
is designed to speed up one class of query only, and as such has some
limitations on its use.  The primary limitation is that it can
currently only be used on a field that is of the type {\tt UNSIGNED INT} or
\verb`DATE`.
%\chgbarbegin It is
%expected that this restriction will be relaxed in future versions of
%Texis.\chgbarend

Inverted indexes can be used to speed up the {\tt ORDER BY} operation in
the case that you are ordering by the field that was indexed only.
For maximum effect you should also have the indexed ordered in the
same manner as the {\tt ORDER BY}.  In other words if you want a descending
order, you should have a descending index.

An inverted index can be created using this command:
\begin{verbatim}
     CREATE INVERTED INDEX SALINDEX
     ON EMPLOYEE (SALARY) ;
\end{verbatim}

% ============================================================================
\section{Index Options}
\label{IndexOptions}

  A series of index options may be specified using a {\tt WITH} clause
at the end of any {\tt CREATE [index-type] INDEX} statement:

\begin{verbatim}
     CREATE [index-type] INDEX index-name
     ON table-name (column-name [DESC] [, column-name [DESC]] ...)
     [WITH option-name [value] [option-name [value] ...]] ;
\end{verbatim}

  Index options control how the index is made, or what sub-type of
index is created.  Many options are identical to global or server
properties set with the {\tt SET} statement
(p.~\pageref{ServerProperties}), but as options are set directly in
the {\tt CREATE INDEX} statement, they override those server
properties, yet only apply to the statement they are set in.  Thus,
using index options allows modularization of {\tt CREATE INDEX}
statements, making it clearer what settings apply to what index by
directly specifying them in the {\tt CREATE} statement, and avoiding
side-effects on later statements.

  Note that the {\tt WITH} clause is only supported in Texis version 7
and later.  Previous releases can only set server-wide properties, via
the {\tt SET} statement.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Available Options}

  The available index options are as follows.  Note that some options
are only applicable to certain index types, as noted; using a option
that does not apply to the given index type will result in an error:

\begin{itemize}
  \item \verb`counts 'on'|'off'` \\

    For Metamorph or Metamorph counter index types only.  If set to
    ``\verb`on`'', creates a Metamorph counter type index (useful for
    \verb`LIKEIN` searches); if ``\verb`off`'' (the default), a
    regular Metamorph or Metamorph inverted index is created.

  \item \verb`indexmaxsingle N` \\

    For Metamorph, Metamorph inverted, and Metamorph counter index
    types only.  Same as the {\tt indexmaxsingle} server property
    (p.~\pageref{indexmaxsingle}).

  \item \verb`indexmem N` \\
  \item \verb`indexmeter N|type` \\
  \item \verb`indexspace N` \\
  \item \verb`indexvalues type` \\

    These options have the same effect as the same-named server
    properties set with {\tt SET}.

  \item \verb`indexversion N` \\
  \item \verb`keepnoise 'on'|'off'` \\
  \item \verb`noiselist ('word','word',...)` \\
  \item \verb`textsearchmode mode` \\
  \item \verb`wordexpressions ('expr','expr',...)` \\

    For Metamorph, Metamorph inverted, and Metamorph counter index
    types only.  Same effect as the same-named server properties.

  \item \verb`wordpositions 'on'|'off'` \\

    For Metamorph and Metamorph inverted index types only.  If
    ``\verb`on`'' (the default in version or
    \verb`compatibilityversion` 7 and later), creates a full-inversion
    (Metamorph inverted) index; if ``\verb`off`'', creates a compact
    (Metamorph) index.

  \item \verb`max_index_text N` \\

    For a regular index created on a varchar field this controls
    how the maximum number of characters from the field that are indexed.
    This allows indexing the beginning of potentially large fields, either
    for approximate sorting, or to find records based on a prefix of the
    field.

  \item \verb`stringcomparemode mode` \\

    For regular index types only.  Same effect as the same-named
    server properties.
\end{itemize}

% ============================================================================
\section{Dropping an Index}

Any index -- unique or non-unique, sorted order or Metamorph -- can be
eliminated if it is no longer needed.  The {\tt DROP INDEX} command is
used to remove an index.  The format of this command is similar to the
{\tt DROP TABLE} command illustrated in Chapter~\ref{chp:TabDef}.

\begin{verbatim}
     DROP INDEX  index-name ;
\end{verbatim}

{\bf Example:}
Let's say the \verb`DEPTINDEX` is no longer needed.  Delete it with this
statement:
\begin{verbatim}
     DROP INDEX  DEPTINDEX ;
\end{verbatim}

% MAW 09-18-94 - comment out msg
%It results in the message
%
%\begin{verbatim}
%     Index Dropped
%\end{verbatim}

The table on which the index was created would not be touched.
However, the index created for it has been removed.

\chapter{Keeping the Database Current}{\label{chp:DBCurr}}

To keep the data in your database current, three types of transactions
must be performed on the data.  These transactions are:

\begin{enumerate}
\item Adding new records.
\item Changing existing records.
\item Deleting records no longer needed.
\end{enumerate}

\section{Adding New Records}

Once a table has been defined and before any data can be retrieved,
data must be entered into the table.  Initially, data can be entered
into the table in several ways:

\begin{itemize}
\item Batch mode: Data is loaded into the table from a file.

\item Interactive mode: Data for each record is added by interactive
prompting of each column in a record.

\item Line Input:  A row of data is keyed for insertion into a table
using a line editor and then is submitted to the database.
\end{itemize}

Generally a Load Program would be used to load data into the tables at
the outset.  It would be unusual to use line input especially to get
started, but it is used in the following examples so that the correct
syntax can be clearly seen.

\subsection{Inserting One Row at a Time}

In addition to initially loading data into tables, records can be
added at any time to keep a table current.  For example, if a new
employee is hired, a new record, or row, would be added to the
EMPLOYEE table.  The \verb`INSERT` command is used to enter a row into a
table.  The command has two formats:

\begin{enumerate}
\item Entering one row at a time.
\item Entering multiple rows at a time.
\end{enumerate}

In the first format, the user enters values one row at a time, using
the following version of the \verb`INSERT` command:

\begin{verbatim}
     INSERT INTO  table-name [(column-name1 [,column-name2] ... )]
     VALUES  (value1, value2 ... ) ;
\end{verbatim}

%When all columns in a table have data values assigned, the
%``column-name'' option following table-name is not required.

\subsubsection{Command Discussion}

\begin{itemize}
\item The {\tt INSERT INTO} clause indicates that you intend to add a row to
a table.

\item Following the {\tt INSERT INTO} clause, the user specifies the name of
the table into which the data is to be inserted.

\item When data values are being entered in the same order the
columns were created in
there is no need to list the column names following the {\tt INSERT INTO}
clause.  However, sometimes when a row is added, the correct ordering of
column values is not known.  In those cases, the columns
being added must be listed following the table name in the order that
the values will be supplied.
%\if HaveNull
%\chgbarbegin All column values of the new row that are not
%listed receive a NULL value.\chgbarend
%\fi % HaveNull

\item Following the keyword VALUES are the values to be added to one
row of a table.  The entire row of values is placed within
parentheses.  Each data value is separated from the next by a comma.
The first value corresponds to the first column in the table; the
second value corresponds to the second column in the table, and so on.
\end{itemize}

{\bf Example:}
When the EMPLOYEE table is first created, it has no employee data
stored in it.  Add the first record to the table, where the data
values we have are as follows:
\begin{verbatim}
     EID = 101
     ENAME = Aster, John A.
     DEPT = MKT
     RANK = STAFF
     BENEFITS = FULL
     SALARY = 32000
\end{verbatim}
You can create a record containing these values by entering this
command:
\begin{verbatim}
     INSERT INTO EMPLOYEE
     VALUES (101,'Aster, John A.','MKT','STAFF','FULL',32000) ;
\end{verbatim}

Quotes are placed around character values so Texis can distinguish
data values from column names.

A new employee record gets added to the EMPLOYEE table, so that the
table now looks like this, if this were the only row entered:

\begin{screen}
\begin{verbatim}
  EID  ENAME               DEPT   RANK   BENEFITS   SALARY

  101  Aster, John A.      MKT    STAFF  FULL       32000


\end{verbatim}
\end{screen}

\subsection{Inserting Text}

There are a few different ways to manage large quantities of text in a
database.  The previous examples given for the REPORT table
concentrated on the VARCHAR (variable length character) column which
held a filename as a character string; e.g., \verb`'/data/rnd/ink.txt'`
as stored in the FILENAME column.  This column manages the filename
only, not the text contained in that file.

In the examples used in Chapter~\ref{chp:TabDef}, {\em Table
Definition}, a RESUME table is created which uses a VARCHAR field of
around 2000 characters to hold the text of the resumes.  In this case,
the job experience text of each resume is stored in the column EXP.  A
Load Program would be used to insert text of this length into the
column of a table.

Another way Texis has of managing text is to allow the files to remain
outside the confines of the table.  Where the INDIRECT data type is
used, a filename can be entered as a value which points to an actual
file, rather than treated as a character string.  The INDIRECT type
looks at the contents of the file when doing \verb`LIKE`, and these contents
can be retrieved using the API (Application Program Interface).

The form of the {\tt INSERT INTO} command is the same as above.  Where a
data type is defined as \verb`INDIRECT`, a filename may be entered as the
value of one or more columns.

{\bf Example:}
Let's say we have the following information available for a resume to
be entered into the RESUME table, and that the job experience column EXP
has been defined as INDIRECT.

\begin{verbatim}
    RES_ID = R421
    RNAME = Smith, James
    JOB = Jr Analyst
    EDUC = B.A. 1982 Radford University
    EXP = contained in the resume file "/usr/local/resume/smith.res"
\end{verbatim}

Use this {\tt INSERT INTO} statement to add a row containing this
information to the RESUME table:

\begin{verbatim}
     INSERT INTO RESUME
     VALUES ('R421','Smith, James','Jr Analyst',
             'B.A. 1982 Radford University',
             '/usr/local/resume/smith.res') ;
\end{verbatim}

The EXP column acts as a pointer to the full text files containing the
resumes.  As such, the text in those files responds to all
\verb`SELECT`-\verb`FROM`-\verb`WHERE` statements.  Thus Metamorph queries used after \verb`LIKE`
can be done on the text content manipulated by Texis in this table.

\subsection{Inserting Multiple Rows at a Time}

In addition to adding values to a table one row at a time, you can
also use a variation of the \verb`INSERT` command to load some or all data
from one table into another table.  The second form of the \verb`INSERT`
command is used when you want to create a new table based on the
results of a query against an existing table.  The form of this \verb`INSERT`
command is:
\begin{verbatim}
     INSERT INTO table-name
       SELECT  expression1 [,expression2] ...
       FROM    table-name
       [WHERE  search-condition] ;
\end{verbatim}

\subsubsection{Command Discussion}

\begin{itemize}
\item The {\tt INSERT INTO} clause indicates that you intend to add a row or
rows to a table.

\item Following the {\tt INSERT INTO} clause, the user specifies the name of
the table to be updated.

\item The query is evaluated, and a copy of the results from the query
is stored in the table specified after the {\tt INSERT INTO} clause.  If
rows already exist in the table being copied to, then the new rows are
added to the end of the table.

\item Block inserts of text columns using \verb`INDIRECT` respond just as any
other column.
\end{itemize}

{\bf Example:}
Finance wants to do an analysis by department of the consequences of a
company wide 10\% raise in salaries, as it would affect overall
departmental budgets.  We want to manipulate the relational
information stored in the database without affecting the actual table
in use.

{\em Step 1:} Create a new table named EMP\_RAISE, where the projected
results can be studied without affecting the live stored information.
Use this {\tt CREATE TABLE} statement, which defines data types as in the
original table, EMPLOYEE, creating an empty table.

\begin{verbatim}
     CREATE TABLE  EMP_RAISE
       (EID       INTEGER
        ENAME     CHAR(15)
        DEPT      CHAR(3)
        RANK      CHAR(5)
        BENEFITS  CHAR(4)
        SALARY    INTEGER) ;
\end{verbatim}

{\em Step 2:} Copy the data in the EMPLOYEE table to the EMP\_RAISE
table.  We will later change salaries to the projected new salaries
using the \verb`UPDATE` command.  For now, the new table must be loaded as
follows:

\begin{verbatim}
     INSERT INTO  EMP_RAISE
       SELECT  *
       FROM    EMPLOYEE ;
\end{verbatim}

The number of records which exist in the EMPLOYEE table at the time
this {\tt INSERT INTO} command is done is the number of records which will
be created in the new EMP\_RAISE table.  Now that the new table has
data values, it can be queried and updated, without affecting the data
in the EMPLOYEE table.

An easier way to create a copy of the table is to use the following
syntax:

\begin{verbatim}
     CREATE TABLE  EMP_RAISE AS
       SELECT  *
       FROM    EMPLOYEE ;
\end{verbatim}

which creates the table, and copies it in one statement.  Any indexes
on the original table will not be created on the new one.

\section{Updating Records}

Very often data currently stored in a table needs to be corrected or
changed.  For example, a name may be misspelled or a salary figure
increased.  To modify the values of one or more columns in one or more
records of a table, the user specifies the \verb`UPDATE` command.  The
general form of this statement is:

\begin{verbatim}
     UPDATE  table-name
     SET     column-name1 = expression1
             [,column-name2 = expression2] ...
     [WHERE  search-condition] ;
\end{verbatim}

\subsubsection{Command Discussion}

\begin{itemize}
\item The \verb`UPDATE` clause indicates which table is to be modified.

\item The SET clause is followed by the column or columns to be
modified.  The expression represents the new value to be assigned to
the column.  The expression can contain constants,
%NULL,
column names,
or arithmetic expressions.
%\if HaveNull
%\chgbarbegin  Using NULL as an expression stores a null
%value in the specified column.\chgbarend
%\fi % HaveNull

\item The record or records being modified are found by using a search
condition.  All rows that satisfy the search condition are updated.
If no search condition is supplied, all rows in the table are updated.
\end{itemize}

{\bf Example:}
Change the benefits for the librarian Margaret Chapman from partial to
full with this statement:
\begin{verbatim}
     UPDATE EMPLOYEE
     SET    BENEFITS = 'FULL'
     WHERE  EID = 103 ;
\end{verbatim}

The value \verb`'FULL'` is the change being made.  It will replace the
current value \verb`'PART'` listed in the BENEFITS column for Margaret
Chapman, whose employee ID number is 103.  A change is made for all
records that satisfy the search condition; in this example, only one
row is updated.

{\bf Example:}
The finance analysis needs to include the effects of a 10\% pay raise
to all staff; i.e., to all employees whose RANK is STAFF.

Use this statement to update all staff salaries with the intended
raise:
\begin{verbatim}
     UPDATE  EMP_RAISE
     SET     SALARY = SALARY * 1.1
     WHERE   RANK = 'STAFF' ;
\end{verbatim}

If a portion of the EMP\_RAISE table looked like this before the
update:

\begin{screen}
\begin{verbatim}
  EID  ENAME               DEPT   RANK   BENEFITS   SALARY
  101  Aster, John A.      MKT    STAFF  FULL       32000
  102  Barrington, Kyle    MGT    DHEAD  FULL       45000
  103  Chapman, Margaret   LIB    STAFF  PART       22000
  104  Jackson, Herbert    RND    STAFF  FULL       30000
  105  Price, Stella       FIN    DHEAD  FULL       42000
  106  Sanchez, Carla      MKT    STAFF  FULL       35000
  107  Smith, Roberta      RND    STAFF  PART       25000
\end{verbatim}
\end{screen}

It would look like this after the update operation:

\begin{screen}
\begin{verbatim}
  EID  ENAME               DEPT   RANK   BENEFITS   SALARY
  101  Aster, John A.      MKT    STAFF  FULL       35200
  102  Barrington, Kyle    MGT    DHEAD  FULL       45000
  103  Chapman, Margaret   LIB    STAFF  PART       24200
  104  Jackson, Herbert    RND    STAFF  FULL       33000
  105  Price, Stella       FIN    DHEAD  FULL       42000
  106  Sanchez, Carla      MKT    STAFF  FULL       38500
  107  Smith, Roberta      RND    STAFF  PART       27500
\end{verbatim}
\end{screen}

Notice that only the STAFF rows are changed to reflect the increase.
DHEAD row salaries remain as they were.  As a word of caution, it's
easy to ``accidentally'' modify all rows in a table.  Check your
statement carefully before executing it.

\section{Making a Texis Owned File}

When a file is inserted into an INDIRECT column, the ownership and
location of the file remains as it was when loaded.  If the resume
file called ``\verb`/usr/local/resume/smith.res`'' was owned by the
Library, it will remain so when pointed to by the INDIRECT column
unless you take steps to make it otherwise.  For example, if Personnel
owns the RESUME table but not the files themselves, an attempt to
update the resume files would not be successful.  The management and
handling of the resume files is still in the domain of the Library.

The system of INDIRECT data types is a system of pointers to files.
The file pointed to can either exist on the system already and remain
where it is, or you can instruct Texis to create a copy of the file
under its own ownership and control.  In either case, the file still
exists outside of Texis.

Where you want Texis to own a copy of the data, a Texis owned file can
be made with the TOIND function.  You can then do whatever you want
with one version without affecting the other, including removing the
original if that is appropriate.  The permissions on such Texis owned
files will be the same as the ownership and permissions assigned to
the Texis table which owns it.

The file is copied into the table using an \verb`UPDATE` statement.  The form
of \verb`UPDATE` is the same, but with special use of the expression for the
column name following SET.  The form of this portion of the \verb`UPDATE`
statement would be:

\begin{verbatim}
     UPDATE  table-name
     SET     column-name = toind (fromfile ('local-file') ) ;
\end{verbatim}

The change you are making is to the named column.  With SET, you are
taking text from the file (``fromfile'') as it currently exists on the
system (``local-file''), and copying it to an INDIRECT text column
(``toind'') pointed to by the Texis table named by \verb`UPDATE`.  The name
of the local file is in quotes, as it is a character string, and is in
parentheses as the argument of the function ``\verb`fromfile`''.  The
whole ``\verb`fromfile`'' function is in parentheses as the argument
of the function ``\verb`toind`''.

{\bf Example:}
To make a Texis owned copy of the Smith resume file for the RESUME
table, use this \verb`UPDATE` statement:

\begin{verbatim}
     UPDATE  RESUME
     SET     EXP = toind (fromfile ('/usr/local/resume/smith.res') ) ;
\end{verbatim}

The ``\verb`smith.res`'' file now exists as part of the Texis table
RESUME, while still remaining outside it.  Once you have made Texis owned
copies of any such files, you can operate on the text in the table without
affecting the originals.  And you can decide whether it is prudent to
retain the original copies of the files or whether that would now be an
unnecessary use of space.

\section{Deleting Records}

Records are removed from the database when they are no longer relevant
to the application.  For example, if an employee leaves the company,
data concerning that person can be removed.  Or if we wish to remove
the data from certain departments which are not of interest to the pay
raise analysis, we can delete those records from the temporary
analysis table.

Deleting a record removes all data values in a row from a table.  One
or more rows from a table can be deleted with the use of the \verb`DELETE`
command.  This command has the following form:
\begin{verbatim}
     DELETE FROM  table-name
     [WHERE  search-condition] ;
\end{verbatim}

\subsubsection{Command Discussion}

\begin{itemize}
\item The {\tt DELETE FROM} clause indicates you want to remove a row from a
table.  Following this clause, the user specifies the name of the
table from which data is to be deleted.

\item To find the record or records being deleted, use a search
condition similar to that used in the \verb`SELECT` statement.

\item Where INDIRECT text columns are concerned, such rows will be
deleted just as any other when {\tt DELETE FROM} is used.  However, the
files pointed to by INDIRECT will only be removed where managed by
Texis, as defined in the previous section on Texis owned files.
\end{itemize}

An employee whose ID number is 117 has quit his job.  Use this
statement to delete his record from the EMPLOYEE table.

\begin{verbatim}
     DELETE FROM EMPLOYEE
     WHERE  EID = 117 ;
\end{verbatim}

All records which satisfy the search condition are deleted.  In this
case, one record is deleted from the table.  Note that the entire
record:
\begin{verbatim}
     117  Peters, Robert      SPI    DHEAD  FULL       34000
\end{verbatim}
is deleted, not just the column specified in the \verb`WHERE` clause.

When you delete records, aim for consistency.  For example, if you
intend to delete Peters' record in the EMPLOYEE table, you must also
delete the reference to Peters as department head in the DEPARTMENT
table and so on.  This would involve two separate operations.

{\bf Example:}
Let's say we want to delete all the department heads from the
EMP\_RAISE table as they are not really part of the analysis.  Use
this statement:

\begin{verbatim}
     DELETE FROM EMP_RAISE
     WHERE  RANK = 'DHEAD' ;
\end{verbatim}

The block of all records of employees who are department heads are
removed from the EMP\_RAISE table, leaving the table with just these
entries:

\begin{screen}
\begin{verbatim}
  EID  ENAME               DEPT   RANK   BENEFITS   SALARY
  101  Aster, John A.      MKT    STAFF  FULL       32000
  103  Chapman, Margaret   LIB    STAFF  PART       22000
  104  Jackson, Herbert    RND    STAFF  FULL       30000
  106  Sanchez, Carla      MKT    STAFF  FULL       35000
  107  Smith, Roberta      RND    STAFF  PART       25000
\end{verbatim}
\end{screen}

If the finance analyst wanted to empty the table of existing entries
and perhaps load in new ones from a different part of the
organization, this could be done with this statement:
\begin{verbatim}
     DELETE FROM  EMP_RAISE ;
\end{verbatim}

All rows of EMP\_RAISE would be deleted, leaving an empty table.
However, the definition of the table has not been deleted; it still
exists even though it has no data values, so rows can be added to the
table at any time.

It is important to note the difference between the \verb`DELETE` command and
the {\tt DROP TABLE} command.  In the former, you eliminate one or more rows
from the indicated table.  However, the structure of the table is
still defined, and rows can be added to the table at any time.  In the
case of the {\tt DROP TABLE} command, the table definition is removed from
the system catalog.  You have removed not only access to the data in
the table, but also access to the table itself.  Thus, to add data to
a ``dropped'' table, you must first create the table again.

%\if \HaveViews
%This completes the data manipulation features of Texis.  In the next
%chapter you will learn about views, a mechanism to limit a user's
%access to specific portions of a database.
%
%\chapter{Views}{\label{Chp:View}}
%
%\section{Defining Views}
%
%\chgbarbegin In the previous chapters, queries were used to access base tables.  A
%{\em base table} is a table defined by using the CREATE TABLE command.
%These tables represent the permanent tables in the database and are
%associated with the stored data in the database.
%
%In addition to base tables, Texis allows users of a database to have
%several different ways of looking at the same database.  Each of these
%different ways is called a {\em view}.  A view is a derived table;
%that is, a table that does not physically exist, although to the user
%of the view, it appears to exist.  Actually, the contents of a view
%table are derived from data in the base tables according to the
%definition of a view.  The view may consist of a subset of the columns
%and/or rows from a single table.  In addition, views may be more
%complex, involving computed values or rows and columns from several
%tables.
%
%There are several reasons for creating a view:
%
%\begin{itemize}
%\item You may not want every user to have access to the entire
%database.  Even though data in a database is shared, each individual
%or group of users may need to access only the portion of the database
%that applies to their particular work.  Thus, a view can be used to
%limit a user's access to data, since only columns or rows included in
%the view are accessible to users retrieving data from that view.
%
%For example, several users may have access to EMPLOYEE data:  the
%Research \& Development department can retrieve all information about
%their own R\&D employees but not other employees; the Benefits
%Manager in Personnel can retrieve data on all employees, but on
%benefits only; Management can retrieve EMPLOYEE data joined with
%DEPARTMENT data.  Each user is operating on a view that is derived
%from the EMPLOYEE table.
%
%\item You may want to simplify the user's perception of the database.
%Since a view usually contains fewer columns than the overall data and
%can be conceptualized as a single table rather than a collection of
%tables, it should be easier to work with.  Thus, the user is better
%able to understand the data he or she is working with.
%\end{itemize}
%
%A view is defined in Texis by using the CREATE VIEW command.  In
%defining a view, you assign a name to the view and provide a query
%that specifies which rows and columns will be included in the view.
%
%The general form of the command is:
%
%\begin{verbatim}
%     CREATE VIEW view-name [(view-column-name1 [,view-column-name2] ... )]
%       AS SELECT    expression1 [,expression2] ...
%        FROM        table-name1 [,table-name2] ...
%        [WHERE      search-condition]
%        [GROUP BY   column-name1 [,column-name2] ... ]
%        [HAVING     search-condition] ;
%\end{verbatim}
%
%In other words, you are working out a complex \verb`SELECT`-\verb`FROM`-\verb`WHERE` query
%ahead of the need to retrieve this information, and storing it in the
%form of a VIEW which can be manipulated within its own scope of
%entities and operations.
%
%\subsubsection{Command Discussion}
%
%\begin{itemize}
%\item If view-column names are omitted, the names of the columns in
%the view are the same as the columns appearing in the \verb`SELECT` clause of
%the view definition.  If you want to rename the columns in a view,
%then the view-column names must be added to the view definition.  In
%fact, view-column names must be specified for all columns in a view if
%any column within the view is based on a function (SUM, AVG, etc.) or
%on an arithmetic calculation.
%
%\item All variations of a \verb`SELECT` statement can be used to define a
%view.  The only restriction is that the {\tt ORDER BY} clause is not
%permitted when defining a view.
%
%\item The creation of a view does not result in a duplicate set of
%stored data.  Instead, the definition of a view including the \verb`SELECT`
%command, is saved in the system catalog (see Chapter~\ref{chp:AdmDB}).
%When a query references the database via a view, Texis combines the
%query defining the view with the user's query to form a query that is
%used to access the original ``base'' tables where the data is stored.
%
%\item A view is normally established by a database administrator, the
%individual responsible for the overall function of the database,
%rather than by a user.  Once the view is defined, many users query the
%database via the view rather than the original ``base'' tables.
%
%\item There may be many user views defined for the same database.
%Each view provides a customized structure of data for a particular
%user.
%\end{itemize}
%
%{\bf Example:}
%The R\&D office manager has access to the data in the Employee table,
%but only regarding personnel from R\&D, and not including their
%salaries.  The following view is developed for her use:
%
%\begin{verbatim}
%     CREATE VIEW  RND
%       AS SELECT  EID, ENAME, RANK, BENEFITS
%        FROM      EMPLOYEE
%        WHERE     DEPT = 'RND' ;
%\end{verbatim}
%
%This command creates a view named RND with four columns (employee ID
%number, employee name, rank, and benefits status), which correspond to
%the four named columns in the \verb`SELECT` statement.  The DEPT column is
%not needed as this view deals only with the Research and Development
%Department.  SALARY information is considered confidential at this
%level of management.  The rows included in the view represent
%employees in the RND department.
%
%No new table is created.  However, the user can visualize this view as
%another table in the database, which would appear as follows:
%
%\begin{screen}
%\begin{verbatim}
%  EID  ENAME               RANK   BENEFITS
%  104  Jackson, Herbert    STAFF  FULL
%  107  Smith, Roberta      STAFF  PART
%  108  Jones, David        DHEAD  FULL
%\end{verbatim}
%\end{screen}
%
%This is a subset of the EMPLOYEE data which the user of the RND view
%is allowed to access.  Once a view has been created, it can be queried
%just like any other table.
%
%{\bf Example:}
%The office manager needs to send to Personnel a list of the RND staff
%and their benefits status.  Rather than forming a query from the
%EMPLOYEE table, she can use her view of that data as follows:
%
%\begin{verbatim}
%     SELECT    ENAME, BENEFITS
%     FROM      RND
%     ORDER BY  BENEFITS ;
%\end{verbatim}
%
%It results in this list:
%
%\begin{screen}
%\begin{verbatim}
%  ENAME               BENEFITS
%  Jackson, Herbert    FULL
%  Jones, David        FULL
%  Smith, Roberta      PART
%\end{verbatim}
%\end{screen}
%
%The view name is used where table name would be used after \verb`FROM`.
%Notice that only the names of the RND staff are retrieved, without the
%need to qualify with a \verb`WHERE` clause.  Note also that the {\tt ORDER BY}
%clause may not be used in defining a view.  However, {\tt ORDER BY} may be
%used when querying that view.
%
%If R\&D's Office Manager tries to to get data outside her view it will
%fail.  For example, suppose she is asked to total the salaries for her
%department and submit to Accounting.  She may try this query:
%
%\begin{verbatim}
%     SELECT    SUM (SALARY)
%     FROM      RND ;
%\end{verbatim}
%
%Since salary data was not defined as part of the RND view, the query
%cannot be executed and she will get an error message.
%
%RND is an example of a view that consists of a subset of rows and
%columns from a single base table.  A view can also involve summary
%statistics as the next example illustrates.
%
%{\bf Example:}
%Create a view for the Business Manager that permits the retrieval
%of
%departmental salary totals and number of employees without disclosing
%individual salaries.
%
%Enter this statement to create a view named EMP\_SUM:
%\begin{verbatim}
%     CREATE VIEW  EMP_SUM(DEPT, SUMSAL, EMPCOUNT)
%       AS SELECT    DEPT, SUM(SALARY), COUNT(*)
%        FROM        EMPLOYEE
%        GROUP BY    DEPT ;
%\end{verbatim}
%
%The names in parentheses following the view named EMP\_SUM are the
%names assigned to the columns in that view.  The column names that
%will be used to access data from EMP\_SUM are DEPT, SUMSAL, and
%EMPCOUNT.
%
%The sum of the salaries will be calculated with the aggregate function
%SUM, and stored in a column named SUMSAL.  The number of employees in
%each department will be calculated with the COUNT function and stored
%in a column named EMPCOUNT.  {\tt GROUP BY DEPT} indicates the aggregate
%functions will be organized by department.
%
%Now the Business Manager can query the view to obtain information
%about the Marketing and R\&D departments only with this statement:
%
%\begin{verbatim}
%     SELECT  DEPT, EMPCOUNT, SUMSAL
%     FROM    EMP_SUM
%     WHERE   DEPT = 'MKT'
%        OR   DEPT = 'RND' ;
%\end{verbatim}
%
%The query of his view will result in the following:
%
%\begin{screen}
%\begin{verbatim}
%  DEPT    EMPCOUNT    SUMSAL
%
%  MKT     3           104500
%  RND     3            92500
%\end{verbatim}
%\end{screen}
%
%Note than anyone using the EMP\_SUM view cannot retrieve individual
%employee records.  For example, this statement:
%
%\begin{verbatim}
%     SELECT  DEPT, ENAME
%     FROM    EMP_SUM ;
%\end{verbatim}
%would result in an error message such as:
%\begin{verbatim}
%     Error: Invalid Column Name
%\end{verbatim}
%as ENAME is not part of the EMP\_SUM view.
%
%Sometimes a view, or table, is developed that consists of columns from
%several tables.  The user visualizes the data as one table rather than
%several tables; this simplifies the user's perception of the data that
%can be accessed.
%
%{\bf Example:}
%The Department Head for Marketing needs a quick view of the status of
%her department resources.  The employee and salary information is
%stored in the EMPLOYEE table, but the operating budget for her
%department is stored in the DEPARTMENT table.  As she needs this same
%information every time she does her planning for the next quarter, a
%view is created to accommodate her requests, combining the necessary
%information from both tables.
%
%\begin{verbatim}
%    CREATE VIEW  MKT_RPT (NO_STAFF, PAYROLL, OP_BUDGET)
%      AS SELECT  EMPLOYEE.COUNT(*), EMPLOYEE.SUM(SALARY), DEPARTMENT.BUDGET
%       FROM      EMPLOYEE, DEPARTMENT
%       WHERE     EMPLOYEE.DEPT = DEPARTMENT.DEPT
%       AND       DEPARTMENT.DEPT = 'MKT'
%       GROUP BY  EMPLOYEE.DEPT
%       HAVING    EMPLOYEE.DEPT = 'MKT' ;
%\end{verbatim}
%
%In this example, defining the view requires the use of the join
%operation to combine rows and columns from two tables.  This is
%specified after \verb`WHERE`. The aggregate functions called for on the
%EMPLOYEE table are specified after {\tt GROUP BY} and {\tt HAVING}.
%
%Names must be given to the columns in the {\tt AS SELECT} clause since two
%of them are derived from aggregate functions.  In this example,
%NO\_STAFF, PAYROLL, and OP\_BUDGET are assigned as names more
%appropriate to the information required in this report.
%
%When the Marketing Department Head wants to see a summary view of her
%department resources, she can enter the following rather than having
%to recreate the complex query which this view represents:
%
%\begin{verbatim}
%     SELECT  *
%     FROM    MKT_RPT ;
%\end{verbatim}
%
%It would result in the following:
%
%\begin{screen}
%\begin{verbatim}
%  NO_STAFF   PAYROLL       OP_BUDGET
%
%  3          104500        25000
%\end{verbatim}
%\end{screen}
%
%\section{Using A View to Modify a Table}
%
%In addition to using views to write queries, you can also use \verb`INSERT`,
%\verb`UPDATE`, and \verb`DELETE` commands with views.
%
%{\bf Example:}
%Employee Chapman from Corporate Library is transferred to R\&D.
%Personnel logs her into RND by updating the department column in the
%EMPLOYEE table only.  The office manager for R\&D is responsible to
%review her benefit plan and increase her benefits from partial to
%full.  When this is confirmed, the benefits status is updated from
%R\&D using their view of the employee information as follows:
%
%\begin{verbatim}
%     UPDATE   RND
%       SET    BENEFITS = 'FULL'
%       WHERE  EID = 103 ;
%\end{verbatim}
%
%The change in Chapman's row has actually been made to the base table
%EMPLOYEE.  However, the result of this change is now visible to users
%of the RND view, the EMPLOYEE table, and users of other views whose
%definition includes the column BENEFITS.
%
%There are some restrictions when modifying a table through a view.
%The use of \verb`INSERT`, \verb`DELETE`, and \verb`UPDATE` as applied to views is not
%permitted under the following conditions:
%
%\begin{itemize}
%\item If the view definition consists of any of the operations:  join,
%{\tt GROUP BY}, DISTINCT, or any aggregate function.  For example, the view
%MKT\_RPT consists of columns derived from aggregate functions, and
%information joined from two tables; therefore it cannot be modified.
%
%\item If a view consists of a column derived from an expression.  For
%example, if a view includes the column monthly salary (SALARY/12), the
%view cannot be modified.
%\end{itemize}
%
%\section{Dropping A View}
%
%A view may be deleted at any time simply by using the DROP command.
%The general format of this command is:
%
%\begin{verbatim}
%     DROP VIEW  view-name ;
%\end{verbatim}
%
%{\bf Example:}
%Eliminate the marketing report for the Marketing Department Head with
%this statement:
%
%\begin{verbatim}
%     DROP VIEW  MKT_RPT ;
%\end{verbatim}
%Any queries that attempt to access the view MKT\_RPT will no longer
%work since the view no longer exists.
%
%This chapter covered the view mechanism -- a way to limit a user's
%access to specific portions of a database.  While views provide some
%degree of security, the granting and revoking of privileges is the
%primary means used in Texis to provide security, along with permission
%assignments provided by the operating system in use.  This topic will
%be covered in the next chapter.\chgbarend
%
%\fi %HaveViews

\chapter{Security}{\label{Chp:Sec}}

Many people have access to a database:  managers, analysts, data-entry
clerks, programmers, temporary workers, and so on.  Each individual or
group needs different access to the data in the database.  For
example, the Finance Director needs access to salary data, while the
receptionist needs access only to names and departments.  R\&D needs
access to the library's research reports, while Legal needs access to
depositions in pertinent court cases.

%\if \HaveViews
%The creation of a user view as was discussed in
%Chapter~\ref{Chp:View}, is a partial solution to the security issue:
%it limits the rows and columns a user can access.  But it's not the
%whole solution.  Some users only need to retrieve data, others need to
%update data, and still others need to update and retrieve data.  Thus,
%including additional security features may be important to the success
%of a database application.
%\fi % HaveViews

Texis maintains permissions which work in conjunction with the
operating system security.  Texis will not change the operating
system permissions on a table, but it will change the permissions
on the indices to match those on the table.

This scheme allows
the operating system to give a broad class of security, while
Texis maintains finer detail.  The reason for the combination
is that Texis can not control what the user does with the
operating system, and the operating system does not have the
detailed permissions required for a database.

When a table is created it initially has full permissions for the
creator, and read/write operating system permissions for the creator
only.

%Texis has two modes of operation with respect to security and
%permissions.  The first uses only the permissions which are
%available through the operating system.  The second uses its
%own internal mechanism for keeping track of permissions.

%The choice between the two methods is made at the time of
%invocation.  If a user name and password are specified then it
%assumes that these are internal names and passwords, and uses
%it's own security.  If no username and password are given then
%it will allow any access that the operating system allows.  When
%you are using one permissions scheme it is not possible to access
%the facilities of the other scheme without exiting, and restarting
%Texis.

When using Texis permissions the operating system can still deny
access which Texis believes is proper.  To prevent this from
happening Texis should always be run as one user id, which owns
the database.  The easiest way of doing this on Unix is to set
the suid bit on all the programs that form the Texis package,
as well as any user programs written with the direct library,
and change the user to a common user, for example texis.
Alternative methods may exist for other operating systems.

\section{Creating Users and Logging In}

When a database is created there are two users created by default.
The default users are {\tt PUBLIC} and {\tt \_SYSTEM}.  {\tt PUBLIC}
has the minimal permissions possible in Texis, and {\tt \_SYSTEM} has
the maximum permissions in Texis.  When these are created they are
created without any password.  You should change the password on
{\tt \_SYSTEM} to prevent security issues.  The password on {\tt PUBLIC}
can be left blank to allow anonymous access to the database, or it can
be set to restrict access.

When logging into Texis the username will default to {\tt PUBLIC} if
none is specified.  This means that tables will be created
owned by {\tt PUBLIC}, and all users will have permissions to use
the tables.  It is possible to use only the {\tt PUBLIC} user while
developing a database, although if multiple people are working
on the database you should see the previous comments about
operating system permissions.

To create new users in the database you must may either use the
program {\tt tsql -a a}, and you will be prompted for the user's
information, or you can user the {\tt CREATE USER} SQL statement.
You must log in as {\tt \_SYSTEM} to add or delete users.

The syntax for the user administration command in SQL are as follows:

\begin{verbatim}
CREATE USER username IDENTIFIED BY password ;

ALTER  USER username IDENTIFIED BY password ;

DROP   USER username ;
\end{verbatim}

You may issue the \verb`ALTER` \verb`USER` command if you are logged
in as the same user that is given in the statement, or if you are
{\tt \_SYSTEM}.  The password should be given as a string in single
quotes.  The \verb`ALTER` \verb`USER` statement is used to change a
user's password; the new password being specified in the command.
Dropping a user will not remove any tables owned by that user.

%\section{Operating System permissions under Unix}
%
%This section documents the behavior of Texis when run with operating
%system permissions under Unix.  This is the default case when run
%under Unix with no user name.  See the documentation on the {\tt -u}
%option to {\tt tsql} and
%the {\tt serveruser} call for information on how to specify a user
%name to get Texis permissions.
%
%At its current release, Texis supports Unix permissions for security, as
%covered in the Unix manuals documenting security on the Unix system in
%use.  Unix security allows for granting permissions to User, Group,
%and Other.  The Unix system administrator would be in charge of
%assigning the proper permission set to the Texis tables.  As regards
%Texis database access, User always has full permissions.  Only one
%Group can have permissions, as well as Other.  Only read and write are
%known as classes of permission.  Write implies read.
%
%Texis uses the normal keywords listed below; e.g., {\tt GRANT SELECT},
%{\tt GRANT INSERT}, and so on, but functionality is limited to and meanings
%are mapped to Unix meanings.  For example, \verb`SELECT` maps to Unix read
%permissions; \verb`INSERT` maps to Unix write permissions.  The {\tt USER}
%specified in a {\tt GRANT SELECT} below is actually a Unix group.

\section{Granting Privileges}

In Texis, the creator of the database would be the automatic
administrator of security.  This individual can grant to other users
different powers, such as the ability to read only, to modify, or to
delete data in the database.  Through the authorization subsystem,
user names and password control which users can see what data.  Each
user signs onto the computer system with his or her own user name and
password (i.e., user identification) and cannot access without
permission tables created by some other user with a different user
name.

The person who creates a table is considered the ``owner'' of the
table.  Initially, that person is the only one who can access, update,
and destroy the table. The owner, however, can grant to other users
the right, or privilege, to do the following:

\begin{itemize}
\item Access the tables
%\if \HaveViews
%or views
%\fi %HaveViews
created by the owner.
\item Add, change, or delete values in a table.
\item Grant rights the user receives from the owner to other users.
\end{itemize}

The owner of the table can grant to other users privileges that
include the following:

\begin{description}
\item \verb`SELECT`: Retrieve rows without changing values in a table.
\item \verb`INSERT`: Add new rows to a table.
\item \verb`UPDATE`: Change values in a table.
\item \verb`DELETE`: Remove rows from a table.
%\if HaveAlter
%\item \verb`ALTER`: Modify the definition of a table.
%\fi % HaveAlter
\end{description}

The authorization subsystem of Texis is based on privileges that are
controlled by the statements GRANT and REVOKE.  The GRANT command
allows the ``owner'' of a table to specify the operations, or
privileges, that other users may perform on a table.  The format of
the command is:

\begin{verbatim}
     GRANT  [ALL]
            privilege1 [,privilege2] ...
     ON     table-name1
     TO     PUBLIC
            userid1 [,userid2] ...
     [WITH GRANT OPTION] ;
\end{verbatim}

\subsubsection{Command Discussion}

\begin{itemize}
\item GRANT is a required keyword that indicates you are granting
access to tables
%\if \HaveViews
%or views
%\fi % HaveViews
to other users.

\item Privilege refers to the type of privilege or privileges you are
granting.  One or more of the following privileges can be granted:
\verb`SELECT`, \verb`INSERT`, \verb`UPDATE`, \verb`DELETE`, and \verb`ALTER`.  Alternatively, ALL can be
specified if all of the above actions are to be granted to the user.

\item ON indicates the table(s)
%\if  \HaveViews
%or view(s)
%\fi % HaveViews
to which these privileges
are being assigned.

\item PUBLIC is used if the privileges are to granted to all users.
If you want only certain users to have privileges assigned to this
table, you must list the user identifications (``\verb`userid's`'') of
all those who will be allowed to share the table.

\item If the clause {\tt WITH GRANT OPTION} is specified, the recipient of
the privileges specified can grant these privileges to other users.
\end{itemize}

{\bf Example:}
The Systems Administrator in the Information Systems Management
Department created the EMPLOYEE table, and is therefore its owner.  As
owner of the EMPLOYEE table, he grants the \verb`SELECT` privilege to the
firm's CPA in Accounting.  As owner of the table he issues the
following command:

\begin{verbatim}
     GRANT   SELECT
     ON      EMPLOYEE
     TO      CPA ;
\end{verbatim}

% MAW 09-18-94 comment following msg
%A message will come back as follows:
%
%\begin{verbatim}
%     Grant Succeeded
%\end{verbatim}

{\bf Syntax Notes:}
\begin{itemize}
\item When the \verb`SELECT` privilege is granted, it is done so with
read-only access.  Therefore the person granted the \verb`SELECT` privilege
can read the data in the table, but cannot write to it, or in other
words, cannot change it with \verb`UPDATE` or other such privileges.

\item ON refers to the table these privileges are being granted on; in
this case, the EMPLOYEE table.

\item What follows TO is the user ID (\verb`userid`) of the person to
whom the privilege is granted.  In this case the \verb`SELECT` privilege is
granted to the person in accounting whose user ID is ``CPA''.
\end{itemize}

{\bf Example:}
The owner of the EMPLOYEE table allows the clerks in Personnel to add
and modify employee data with this command:

\begin{verbatim}
     GRANT   UPDATE, INSERT
     ON      EMPLOYEE
     TO      CLERK1, CLERK2 ;
\end{verbatim}

In this case there are two clerks with two separate user ID's,
``CLERK1'' and ``CLERK2''.  Both are granted privileges to \verb`UPDATE` and
\verb`INSERT` new information into the EMPLOYEE table.

{\bf Example:}
The owner of the EMPLOYEE table, the System Administrator, gives the
Director of Personnel complete access (\verb`SELECT`, \verb`INSERT`, \verb`UPDATE`, \verb`DELETE`,
\verb`ALTER`) to the EMPLOYEE table, along with permission to assign these
privileges to others.  This statement is used:

\begin{verbatim}
     GRANT   ALL
     ON      EMPLOYEE
     TO      PERS
     WITH GRANT OPTION ;
\end{verbatim}

ALL following GRANT includes all 5 of the privileges.  {\tt PERS} is the
user ID of the Director of Personnel.  {\tt WITH GRANT OPTION} allows the
Director of Personnel to grant these privileges to other users.

{\bf Example:}
A systems analyst in the Strategic Planning and Intelligence
Department has created and is owner of the NEWS table in which they
are daily archiving online news articles of interest.  It is decided
to give all employees read-only access to this database.  Owner of the
table can do so with this command:

\begin{verbatim}
     GRANT   SELECT
     ON      NEWS
     TO      PUBLIC ;
\end{verbatim}

Anyone with access to the server on which the news table is stored
will have permission to read the articles in the NEWS table, since the
\verb`SELECT` privilege has been granted to PUBLIC.

%\if \HaveViews
%In many organizations, the owner of a table, or the person responsible
%for the administration of the database, will create different views of
%the data ({\em see Chapter~\ref{Chp:View}}) and then grant various
%users certain privileges with respect to these views.  For example, a
%view of an employee table can be defined so that it excludes salaries.
%Another view might provide only summary salary data by department or
%job classification.  The authorization subsystem of Texis ensures that
%access to these views is given only to users specifically authorized
%to use the views.
%
%{\bf Example:}
%Coach for Acme's baseball team is given read-only access to a view of
%the employee table that includes the employee's ID, name, department,
%and rank.
%
%{\em Step 1:} Director of Personnel as owner of the table creates a
%view for the coach with this statement:
%
%\begin{verbatim}
%     CREATE VIEW  PLAYERS
%       AS SELECT  EID, ENAME, DEPT, RANK
%            FROM  EMPLOYEE ;
%\end{verbatim}
%
%{\em Step 2:}  Read-only access to the view is granted with this
%statement:
%
%\begin{verbatim}
%     GRANT  SELECT
%     ON     PLAYERS
%     TO     COACH ;
%\end{verbatim}
%
%Now the coach, who was granted read-only access to the PLAYERS table,
%wants a list of all employee names and departments to make up a
%baseball team.  So this statement is entered:
%
%\begin{verbatim}
%     SELECT  ENAME, DEPT
%     FROM    PERS.PLAYERS ;
%\end{verbatim}
%
%User ID of the owner of a table or view is normally required as a
%prefix to the table or view name in order to access a table or
%view owned by someone else.  A sampling of the results of the query
%are:
%
%\begin{screen}
%\begin{verbatim}
%  ENAME               DEPT
%  Aster, John A.      MKT
%  Brown, Penelope     MKT
%  Chapman, Margaret   LIB
%  Jackson, Herbert    RND
%  Jones, David        RND
%  Krinski, Wanda      LIB
%  Sanchez, Carla      MKT
%  Smith, Roberta      RND
%\end{verbatim}
%\end{screen}
%
%In order for you to access a table ``owned'' by someone else (assuming
%you have been granted permission), you must prefix the table (or view)
%being accessed in the \verb`FROM` clause with the ``owner's'' user ID.
%
%If the Coach should want to see information about employee 104 and
%queries it in this way:
%
%\begin{verbatim}
%     SELECT  EID, ENAME
%     FROM    PERS.EMPLOYEE
%     WHERE   EID = '104' ;
%\end{verbatim}
%
%an error message will result, as follows:
%
%\begin{verbatim}
%     Table of View Does Not Exist
%\end{verbatim}
%
%The error message is displayed because the coach has not been granted
%access to the EMPLOYEE table, only to the view of it, called PLAYERS.
%\fi % HaveViews

\section{Removing Privileges}

Privileges assigned to other users can be taken away by the person who
granted them.  In Texis, the REVOKE statement would be used to remove
privileges granted by the GRANT command.  The general form of this
statement is:

\begin{verbatim}
     REVOKE  [ALL]
             privilege1 [,privilege2] ...
     ON      table-name1
     TO      PUBLIC
             userid1 [,userid2] ... ;
\end{verbatim}

\subsubsection{Command Discussion}

\begin{itemize}
\item REVOKE is a required keyword that indicates you are removing
access to tables
%\if \HaveViews
%or views
%\fi %HaveViews
.

\item Privilege refers to the type of privilege or privileges you are
revoking.  One or more of the following privileges can be revoked:
\verb`SELECT`, \verb`INSERT`, \verb`UPDATE`, \verb`DELETE`, and \verb`ALTER`.  Alternatively, ALL can be
specified if all of the above actions are to be taken away from the
user.

\item The ON clause indicates the table(s)
%\if \HaveViews
%or view(s)
%\fi % HaveViews
from which these
privileges are being removed.

\item PUBLIC is used if the privileges are taken away from all users
of the indicated table(s).  Otherwise, you list the user names of only
those who are no longer allowed to share the table.
\end{itemize}

{\bf Example:}
The Personnel clerks no longer need to access the EMPLOYEE table.
Revoke their privileges as follows:

\begin{verbatim}
     REVOKE  UPDATE, INSERT
     ON      EMPLOYEE
     FROM    CLERK1, CLERK2 ;
\end{verbatim}

This completes the discussion of security features in Texis.  In the
next chapter, you will be introduced to certain other administrative
features that can be implemented in Texis.

\chapter{Administration of the Database}{\label{chp:AdmDB}}

This chapter covers topics related to the administration of the
database.  The topics include the following:

\begin{itemize}
\item Accessing information about the database by using Texis's system
catalog.

%\if HaveAlter
%\item Modifying the structure of a table by using the \verb`ALTER` command.
%\fi % HaveAlter

\item Texis reserved words to avoid in naming tables and columns.
\end{itemize}

\section{System Catalog}

In Texis, information about the database, such as the names of tables,
columns, and indexes, is maintained within a set of tables referred to
as the {\em system catalog}.  Texis automatically maintains these
tables in the system catalog in response to commands issued by users.
For example, the catalog tables are updated automatically when a new
table is defined using the {\tt CREATE TABLE} command.

Database administrators and end users can access data in the system
catalog just as they access data in other Texis tables by using the
\verb`SELECT` statement.  This enables a user to inquire about data in the
database and serves as a useful reference tool when developing
queries.

Table~\ref{tab:SysCat} lists the tables that make up the system
catalog for Texis.

\begin{table}
\caption{Overview of System Catalog Tables in Texis}{\label{tab:SysCat}}
\begin{center}
\begin{tabular}{|l|l|} \hline
Table Name          & Description  \\ \hline\hline
\verb`SYSTABLES`    & Contains one row per table in the database.   \\
\verb`SYSCOLUMNS`   & Contains one row per column for each database table.  \\
\verb`SYSINDEX`     & Contains one row per canonical index in the database. \\
\verb`SYSPERMS`     & Holds the permissions information. \\
\verb`SYSUSERS`     & Contains information about users known to the system. \\
\verb`SYSTRIG`      & Contains one row per trigger defined to the system. \\
\verb`SYSMETAINDEX` & Contains one row per Metamorph index in the database. \\ \hline
\end{tabular}
\end{center}
\end{table}

One commonly referenced table, SYSTABLES, contains a row for each
table that has been defined.  For each table, the name of the
table, authorized ID of the user who created the table, type of table,
and so on is maintained.  When users access SYSTABLES, they see data
pertaining to tables that they can access.

Texis's system catalog table, ``SYSTABLES'' has these columns, defined
with the following data types:

\begin{verbatim}
     NAME     -  CHAR(20)
     TYPE     -  CHAR
     WHAT     -  CHAR(255)
     FC       -  BYTE
     CREATOR  -  CHAR(20)
     REMARK   -  CHAR(80)
\end{verbatim}

Each field is fixed length rather than variable length, so the
designated size limits do apply.

\begin{description}
\item[NAME] is the name of the table.  Each of the tables comprising
the system catalog are entered here, as well as each of the other
database relations existing as ``normal'' tables.

\item[TYPE] indicates the type of table.
\begin{description}
\item[S] indicates a System table, and is Texis owned.  `S' is
assigned to all tables where the user who created the table is
``texis''.
\item[T] indicates a normal Table.
\item[V] indicates a normal View.

\item[B] indicates a Btree table.  A Btree is a special type of table
that can be created through the API only, that contains all the data
in the index.  It is of limited special purpose use.  It is somewhat
quicker and more space efficient if you have a few, small fields, and
if you will never need to index on the fields in a different order.
Use of the API is covered in Part~V,~Chapter~\ref{Part:V:Chp:Embed}.

\item[t] indicates a temporary table.  These are not directly
accessible, and exist only briefly.  They are used when a temporary
table is needed by the system -- for example when compacting a table
-- and may have the same name as another, normal table.  They are
automatically removed when no longer needed.

\item[D] indicates a Deleted table.  On some operating systems (such
as Windows), when a table is \verb`DROP`ped, it cannot be removed
immediately and must continue to exist -- as a deleted table -- for a
short time.  Deleted tables are not directly accessible, and are
automatically removed as soon as possible.

\end{description}

\item[WHAT] is the filename designating where the table actually
exists on the system.

\item[FC] stands for Field Count.  It shows how many columns have been
defined for each table entered.

\item[CREATOR] is a User ID and shows who created the table.

\item[REMARK] is reserved for any explanatory comments regarding the
table.
\end{description}

{\bf Example:}
Provide a list of all tables in the database with this statement:

\begin{verbatim}
     SELECT  NAME, TYPE
     FROM    SYSTABLES ;
\end{verbatim}

The result will be a listing of the available tables, as follows:

\begin{screen}
\begin{verbatim}
  NAME             TYPE

  SYSCOLUMNS       S
  SYSINDEX         S
  SYSMETAINDEX     S
  SYSTABLES        S
  CODES            T
  DEPARTMENT       T
  EMPLOYEE         T
  NEWS             T
  REPORT           T
  RESUME           T
\end{verbatim}
\end{screen}
%\if \HaveViews % Add These above
%  RND              V
%  EMP_SUM          V
%  MKT_RPT          V
%  PLAYERS          V
%\fi % HaveViews

In the above example, the first four tables:  SYSCOLUMNS, SYSINDEX,
SYSMETAINDEX, and SYSTABLES, comprise the system catalog and are marked as
type S, for ``{\em system}''.

The next six in the list are the tables which have been used for examples
throughout this manual:  CODES, DEPARTMENT, EMPLOYEE, NEWS, REPORT, and
RESUME.  These are marked as type T, for ``{\em table}''.

%\if \HaveViews
%The last four in the list are the views which were used in the
%examples in Chapter~\ref{Chp:View}}:  RND, EMP\_SUM, MKT\_RPT, and
%PLAYERS.  These are marked as type V, for ``{\em view}''.
%\fi % HaveViews

The table SYSCOLUMNS contains a row for every column of every table
%\if \HaveViews
%or
%view
%\fi % HaveViews
in the database.  For each column, its name, name of the table to
which it belongs, data type, length, position in the table, and
whether NULL is permitted in the columns is maintained information.
Users querying SYSCOLUMNS can retrieve data on columns in tables to
which they have access.

Texis's system catalog table ``SYSCOLUMNS'' has these columns, defined
with the following data types:

\begin{verbatim}
     NAME             -  CHAR(35)
     TBNAME           -  CHAR(35)
     TYPE             -  CHAR(15)
     SIZE             -  INT
     ORDINAL_POSITION -  INT
     IDX              -  CHAR(35)
     NULLABLE         -  SHORT
     SQLTYPE          -  SHORT
     PRECIS           -  INT
     LENGTH           -  INT
     SCALE            -  SHORT
     RADIX            -  SHORT
     REMARK           -  CHAR(80)
\end{verbatim}

\begin{description}
\item[NAME] is the column name itself.

\item[TBNAME] is the table the column is in.

\item[TYPE] is the data type assigned to the column, defined as a
string.  TYPE might contain ``char'', ``varchar'', ``integer'',
``indirect'', and so on.

\item[IDX] is the name of an index created on this column.  (This
field is reserved for use in future versions of Texis.  As it is not
currently being used, one should not be surprised if the IDX field
is empty.)

\item[NULLABLE] indicates whether the field was declared to support NULLs.
(Texis does not currently support NULLs, even if the field is listed as
NULLABLE)

\item[SQLTYPE] this is the value which would be used for the sqltype
argument to the texis\_param API call, e.g. SQL\_INTEGER or SQL\_LONGVARCHAR.

\item[PRECIS] is the number of significant digits, or length of string.

\item[LENGTH] how many bytes are used to store the column

\item[SCALE] reserved for future use, will be 0 in this version.

\item[RADIX] reserved for future use, will be 10 in this version.

\item[REMARK] is reserved for any user comment about the column.
\end{description}

{\bf Example:}
A user wants to obtain data about employees in the R\&D Department,
but doesn't know any of the column names in the EMPLOYEE table.
Assume that the user does know there is a table named EMPLOYEE.

This statement:
\begin{verbatim}
     SELECT  NAME
     FROM    SYSCOLUMNS
     WHERE   TBNAME = 'EMPLOYEE' ;
\end{verbatim}

would result in the following:

\begin{screen}
\begin{verbatim}
  NAME

  EID
  ENAME
  DEPT
  RANK
  BENEFITS
  SALARY
\end{verbatim}
\end{screen}

In this way one can find out what kind of data is stored, so as to
better formulate queries which will reveal what you actually want to
know.

Texis has two other system catalog tables called ``SYSINDEX'' and
``SYSMETAINDEX''.  Texis's system catalog table ``SYSINDEX'' has these
columns, defined with the following data types:

\begin{verbatim}
     NAME     -  CHAR(20)
     TBNAME   -  CHAR(20)
     FNAME    -  CHAR(20)
     ORDER    -  CHAR
     TYPE     -  BYTE
     UNIQUE   -  BYTE
     FIELDS   -  CHAR(20)
\end{verbatim}

\begin{description}
\item[NAME] is the name of the index.

\item[TBNAME] is the table the index is on.

\item[FNAME] is the file name of the index.

\item[ORDER] indicates sort order.  `A' indicates {\em ascending}; `D'
indicates {\em descending}.  This field is not currently used, but is
planned for future releases.

\item[TYPE] indicates the type of index, either Btree or Metamorph.

\item[UNIQUE] indicates whether the values entered should be unique.
This field is not currently used, but is planned for future releases.

\item[FIELDS] indicates which field is indexed.
\end{description}

``SYSMETAINDEX'' controls a demon that checks Metamorph indexes, those
indexes used on text oriented columns.  The demon waits a certain
number of seconds between checks, and has a threshold in bytes at
which size the update process is required to run.

Texis's system catalog table ``SYSMETAINDEX'' has these columns,
defined with the following data types:

\begin{verbatim}
     NAME     -  CHAR(20)
     WAIT     -  INTEGER
     THRESH   -  INTEGER
\end{verbatim}

\begin{description}

\item[NAME] is the name of the Metamorph index.

\item[WAIT] indicates how long to wait in seconds between index
checks.

\item[THRESH] is a number of bytes which have changed.  This is the
threshold required to re-index.
\end{description}

The system catalog tables are a good place to start when initially
becoming familiar with what a database has to offer.

% ============================================================================
\section{Optimization}
% wtf merge/expand with other ALTER TABLE docs below

% ----------------------------------------------------------------------------
\subsection{Table Compaction}

  After a table has been extensively modified, its disk file(s) may
accumulate a certain amount of unused free space, especially if a
large number of rows have been deleted.  This free space will be
re-used as much as possible whenever new rows are inserted or updated,
to try to avoid expanding the table's disk footprint.  However, if the
table is no longer to be modified in the future -- e.g. it is now a
search-only archive -- this free space will never be reclaimed.  It is
now wasted disk space, as well as a potential performance impairment,
as larger seeks may be needed by the operating system to access actual
payload data.

  Free space in a table may be reclaimed by compacting the table
(retaining all payload data), with the following SQL:

\verb`ALTER` \verb`TABLE` $name$ \verb`COMPACT`

This will compact the table $name$ to eliminate its free space.  The
process may take some time for a large table, or where there are many
indexes on it.  Also, while the end result will generally be less disk
usage for the table, {\em during} the compaction disk usage will
temporarily increase, as copies of the table and most of its index
files are created.  Therefore, before starting, ensure that there is
free disk space (in the database's partition) at least equal to the
combined size of the table and its indexes.

Because extensive modifications are needed, the table will not be
modifiable during compaction: attempts to insert, delete or update
rows will block until compaction is finished.  The table is readable
during compaction, however, so \verb`SELECT`s are possible.  Progress
meters may be printed during compaction by setting the SQL property
\verb`meter` to \verb`'compact'`.  The \verb`ALTER` \verb`TABLE`
$name$ \verb`COMPACT` syntax was added in version 6.00.1291080000
20101129.  {\bf NOTE: Versions prior to version 6.00.1291080000
  20101129 should not attempt to access the table during compaction,
  or corruption may result.}

  Note that compacting a table is generally only useful when the table
will no longer be modified, or has undergone a large amount of
deletions that will not be replaced by inserts.  Conversely, a
``steady-state'' continuously-modified table rarely benefits from
compaction, because it will merely accumulate free space again: the
short-term gains of compaction are outweighed by the significant cost
and delay of repeatedly runnning the compaction.

% ----------------------------------------------------------------------------
\subsection{Index Maintenance}

  B-tree (regular) and inverted indexes never require explicit
optimization by the database administrator, as they are automatically
kept up-to-date (optimized) at every table modification
(\verb`INSERT`, \verb`DELETE` or \verb`UPDATE`).

  However, this is not possible for Metamorph indexes due to their
fundamentally different nature.  Instead, table changes are logged for
incorporation into the index at the next optimization (index update),
and Texis must linearly search the changed data until then.  Thus, the
more a table has been modified since a Metamorph index's last
optimization, the more its search performance potentially degrades.
When the index is re-optimized, those changes are indexed and merged
into the Metamorph index, restoring its performance.  A Metamorph
index may be optimized in one of several ways, as follows.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Manual Index Optimization via {\tt CREATE METAMORPH INDEX}}

A Metamorph index may be optimized manually simply by re-issuing the
same \verb`CREATE` \verb`METAMORPH`
$[$\verb`INVERTED`$|$\verb`COUNTER`$]$ \verb`INDEX` $...$ statement
that was used to create it.  Instead of producing an error noting that
the index already exists -- as would happen with regular or inverted
indexes -- the Metamorph index is re-optimized.  (If the index is
already fully optimized, the statement returns success immediately.)

Note that the {\tt ALTER INDEX} statement (p.~\pageref{alterIndex}) is
an easier method of optimizing indexes.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Manual Index Optimization via {\tt ALTER INDEX}}
\label{alterIndex}

  Since the full syntax of the original \verb`CREATE` statement may
not be known, or may be cumbersome to remember and re-enter, a
Metamorph index may also be optimized with an \verb`ALTER INDEX` statement:

\verb`     ALTER INDEX` $indexName$$|$\verb`ALL` [\verb`ON` $tableName$] \\
\verb`         OPTIMIZE`$|$\verb`REBUILD`

This will optimize the index named $indexName$, or all indexes in the
database if \verb`ALL` is given.  Adding the optional \verb`ON`
$tableName$ clause will limit the index(es) optimized to only those on
the table named $tableName$.  If a non-Metamorph index is specified,
it will be silently ignored, as non-Metamorph indexes are always
in an optimized state.

If the keyword \verb`REBUILD` is given instead of \verb`OPTIMIZE`, the
index is rebuilt from scratch instead.  This usually takes more time,
as it is the same action as the initial creation of the index, and
thus the whole table must be indexed, not just changes since last
optimization.  Any index type may be rebuilt, not just Metamorph
indexes.  During rebuilding, the original index is still available for
search use; however inserts, deletes and updates may be postponed
until the rebuild completes.  Rebuilding is not generally needed, but
may be useful if the index is suspected to be corrupt.  The
\verb`ALTER INDEX` syntax was added in Texis version 7.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Automatic Index Optimization via {\tt chkind}}

  Another method of Metamorph index optimization is automatically, via
the \verb`chkind` daemon, and is enabled by default.  This is a
process that runs automatically in the background (as part of the
database monitor), and periodically checks how out-of-date Metamorph
indexes are.  When an index reaches a certain (configurable) threshold
of ``staleness'', it is re-optimized.  See p.~\pageref{chkindDaemon}
for more details on \verb`chkind` and its configuration.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Choosing Manual vs. Automatic Index Optimization}

  Whether to optimize Metamorph indexes manually (via a SQL statement)
or automatically (via \verb`chkind`) depends on the nature of table
changes and searches.

  Deployments where table changes occur in batches, and/or search load
predictably ebbs and flows, are good candidates for manual
optimization.  The optimizations can be scheduled for just after the
batch table updates, and if possible when search load is low.  This
will keep the index(es) up-to-date (and thus performing best) for the
longest amount of time, while also avoiding the performance penalty of
updating both the table and the index simultaneously.  Optimizing at
off-peak search times also improves peak-load search performance by
freeing up resources during the peak.  Contrast this with automatic
optimization, which cannot know about upcoming table updates or search
load, and thus might trigger an index update that coincides with
either, negatively impacting performance.

  Applications where tables are changed at a more constant rate
(e.g. a steady stream of changes) may be better candidates for
automatic updating.  There may not be any predictable ``best time'' to
run the optimization, nor may it be known how much the indexes are
out-of-date.  Thus the decision on when to optimize can be left to
\verb`chkind`'s automatic out-of-date scan, which attempts to minimize
both staleness of the index and frequency of index optimizations.

  Some situation may call for a combination, e.g. \verb`chkind` to
handle miscellaneous table updates, and an occasional manual
optimization after batch updates, or just before peak search load.

%\if HaveAlter
%\chgbarbegin
%\section{Modifying the Database Definition}
%
%As you work with data, you may find that changes to the database are
%necessary.  For example, you may want to enlarge a name column from 10
%to 15 characters or add a Floor location column to the DEPARTMENT
%table.  Revision is the process of changing the structure of the
%database once the database has been established.
%
%The revision capabilities are limited to permitting the user to add
%new columns to the right of all the other columns in an existing
%table.  The {\tt ALTER TABLE} command is used to revise a table in Texis.
%The format of this command is:
%
%\begin{verbatim}
%     ALTER TABLE table-name
%       ADD column-name data-type ;
%\end{verbatim}
%
%\subsubsection{Command Discussion}
%
%\begin{itemize}
%\item The {\tt ALTER TABLE} clause identifies the table you intend to
%modify.
%
%\item Following the keyword ADD is the column name and data type that
%is to be added to the table.
%
%\item The {\tt ALTER TABLE} statement may contain only one ADD clause.
%\end{itemize}
%
%{\bf Example:} Let's add a Floor location to the DEPARTMENT table.  We
%can abbreviate ``floor'' with the column name FL.  Use this statement:
%
%\begin{verbatim}
%     ALTER TABLE DEPARTMENT
%       ADD FL CHAR(2) ;
%\end{verbatim}
%
%It should result in the message:
%
%\begin{verbatim}
%     Table Altered
%\end{verbatim}
%
%The DEPARTMENT table now looks like this:
%
%\begin{screen}
%\begin{verbatim}
%  DEPT  DNAME                                DHEAD       DIV    BUDGET  FL
%  MGT   Management and Administration        Barrington  CORP   22000
%  FIN   Finance and Accounting               Price       CORP   26000
%  LEG   Corporate Legal Support              Thomas      CORP   28000
%  SUP   Supplies and Procurement             Sweet       CORP   10500
%  REC   Recruitment and Personnel            Harris      CORP   15000
%  RND   Research and Development             Jones       PROD   27500
%  MFG   Manufacturing                        Washington  PROD   32000
%  CSS   Customer Support and Service         Ferrer      PROD   11000
%  MKT   Product Marketing and Sales          Brown       PROD   25000
%  ISM   Information Systems Management       Dedrich     INFO   22500
%  LIB   Corporate Library                    Krinski     INFO   18500
%  SPI   Strategic Planning and Intelligence  Peters      INFO   28500
%\end{verbatim}
%\end{screen}
%
%The new column, FL for ``Floor'' now exists, but no data values are
%stored in it.  They are assigned NULL value.
%
%If the type of changes to a table involve deleting columns,
%rearranging columns, inserting columns within the table, or modifying
%a column's size, you must first create a new table and then load data
%into the new table from the existing table by using the second form of
%the \verb`INSERT` command discussed in Chapter~\ref{chp:DBCurr}, under the
%section {\em Inserting Multiple Rows at a Time}.
%
%\chgbarend
%
%{\bf Example:}
%After using the EMPLOYEE table for some time, you decide the table
%needs to be modified.  Add a new column, first name (FNAME), ahead of
%the ENAME column.  Expand the ENAME column to 18 characters, and
%rename it LNAME for last name.
%
%{\em Step 1:} Create a new table with the revised columns.  Use this
%statement:
%
%\begin{verbatim}
%     CREATE TABLE  EMPLOYEE2
%       (EID        INTEGER,
%        FNAME      CHAR(10),
%        LNAME      CHAR(18),
%        DEPT       CHAR(3),
%        RANK       CHAR(5),
%        BENEFITS   CHAR(4),
%        SALARY     INTEGER) ;
%\end{verbatim}
%
%A new table name is assigned for the new table: EMPLOYEE2.
%
%The EMPLOYEE2 table contains seven columns:  EID, FNAME, LNAME, DEPT,
%RANK, BENEFITS, and SALARY.  This is different from the EMPLOYEE table
%which consists of six columns only.  The new definition for name spans
%two columns, where 10 characters are allocated to the first name
%column FNAME and 18 characters are allocated to the last name column
%LNAME.  In the base table EMPLOYEE, ENAME exists as one column of 15
%characters only for employee name.
%
%{\em Step 2:} The next step is to load the existing EMPLOYEE data into
%the new table (EMPLOYEE2).  Use this statement:
%
%\begin{verbatim}
%     INSERT INTO   EMPLOYEE2(EID,LNAME,DEPT,RANK,BENEFITS,SALARY)
%     SELECT        EID, ENAME, DEPT, RANK, BENEFITS, SALARY
%     FROM          EMPLOYEE ;
%\end{verbatim}
%
%The EMPLOYEE table now looks like this:
%
%\begin{screen}
%\begin{verbatim}
%  EID  FNAME         LNAME               DEPT   RANK   BENEFITS   SALARY
%  101                Aster, John A.      MKT    STAFF  FULL       32000
%  109                Brown, Penelope     MKT    DHEAD  FULL       37500
%  103                Chapman, Margaret   LIB    STAFF  PART       22000
%  104                Jackson, Herbert    RND    STAFF  FULL       30000
%  108                Jones, David        RND    DHEAD  FULL       37500
%  110                Krinski, Wanda      LIB    DHEAD  FULL       32500
%  106                Sanchez, Carla      MKT    STAFF  FULL       35000
%  107                Smith, Roberta      RND    STAFF  PART       25000
%\end{verbatim}
%\end{screen}
%
%A new column exists called FNAME, to hold the first names.  For
%now, NULL values are assigned for each FNAME column in the table.
%
%To complete this action, you will have to \verb`INSERT` the first names into
%the NULL FNAME column, and \verb`UPDATE` the LNAME column to hold the last
%names only.
%
%\fi % HaveAlter

\section{Lock Management}

Locks are generally managed automatically in Texis, however you are able to
manually set locks which can improve performance when doing bulk operations.
{\bf Warning:} Care should be used when locking manually as it is possible to
degrade performance, or even deadlock the system if locks are held too long, or
acquired in different sequences.

\subsection{Manual Locking}

Tables can be manually locked using:

\verb`     LOCK TABLES ` $tableName$ \verb`READ|WRITE [, ` $tableName$ \verb` READ|WRITE]`\\
\verb`     ...`\\
\verb`     UNLOCK TABLES`

Issuing a new \verb`LOCK TABLES` before \verb`UNLOCK TABLES` will release the prior locks.
All tables that will be used in the manually locked section \emph{should} be locked manually,
and the locks should be released as soon as possible to avoid blocking other connections.

\subsection{Querying Lock Status}

The current lock status can be viewed with:

\verb`     SHOW TABLE LOCK`

which will return a table with a row for each table with a lock, whether there are any
exclusive or write locks, and how many locks are granted and pending.  Locks are
automatically released when the connection to the database is closed.

\section{Reserved Words}

The following words are reserved words in SQL.  Texis makes use of
many of them, and future versions may make use of others.  These words
should not be used as ordinary identifiers in forming names.

Allowances will be made in future versions of Texis so that the words
may be used as delimited identifiers if deemed vital, by enclosing
them between double quotation marks.

\begin{verbatim}
ADA                 DELETE              INTO                REFERENCES
ADD                 DESC                IS                  REVOKE
ALL                 DESCRIPTOR          KEY                 ROLLBACK
ALTER               DISTINCT            LANGUAGE            SCHEMA
AND                 DOUBLE              LIKE                SECQTY
ANY                 DROP                LIKE3               SELECT
AS                  EDITPROC            LOCKSIZE            SET
ASC                 END-EXEC            MATCHES             SMALLINT
AUTHORIZATION       ERASE               MAX                 SOME
AVG                 ESCAPE              METAMORPH           SQLCODE
BETWEEN             EXECUTE             MIN                 STOGROUP
BLOB                EXISTS              MODULE              SUM
BUFFERPOOL          FETCH               NOT                 SYNONYM
BY                  FIELDPROC           NULL                TABLE
C                   FLOAT               NUMERIC             TABLESPACE
CHAR(ACTER)?        FOR                 NUMPARTS            TO
CHECK               FOREIGN             OF                  UNION
CLOSE               FORTRAN             ON                  UNIQUE
CLUSTER             FOUND               OPEN                UPDATE
COBOL               FROM                OPTION              USER
COLUMN              GO                  OR                  USING
COMMIT              GO[ \t]*TO          ORDER               VALIDPROC
COMPACT             GOTO                PART                VALUES
CONTINUE            GRANT               PASCAL              VARCHAR
COUNT               GROUP               PLAN                VCAT
CREATE              HAVING              PLI                 VIEW
CTIME               IMMEDIATE           PRECISION           VOLUMES
CURRENT             IN                  PRIMARY             WHENEVER
CURSOR              INDEX               PRIQTY              WHERE
DATABASE            INDICATOR           PRIVILEGES          WITH
DATE                INDIRECT            PROCEDURE           WORK
DECIMAL             INSERT              PUBLIC
DECLARE             INT(EGER)?          REAL
DEFAULT
\end{verbatim}

\input{set}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Other topics to be included here in ``Administration of the Database''
% Could be one section apiece:
%    specifics about how texis does things
%    anything else about special data types supported by texis
%    automated method of getting dates & fnames in
%    loading big text in (i.e. doc the loader)
%    blobs, diff kinds of objects

% API stuff can all go here
